<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Solution Explanation - Advent of Code 2022 Solutions</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation and explanations for Advent of Code 2022 solutions">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Advent of Code 2022 Solutions</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day-8-solution-explanation"><a class="header" href="#day-8-solution-explanation">Day 8: Solution Explanation</a></h1>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<p>Day 8 involves analyzing a grid of trees to determine visibility and scenic scores. The solution breaks down into two main parts:</p>
<ol>
<li><strong>Visibility Analysis</strong>: Determine which trees are visible from outside the grid</li>
<li><strong>Scenic Score Calculation</strong>: Calculate the scenic score for each tree and find the maximum</li>
</ol>
<p>The key to solving both parts efficiently is to create appropriate data structures and algorithms for scanning the grid in different directions.</p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="core-data-structures"><a class="header" href="#core-data-structures">Core Data Structures</a></h3>
<h4 id="coordinates"><a class="header" href="#coordinates">Coordinates</a></h4>
<p>First, the solution defines a <code>Coord</code> struct to represent positions in the grid:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug,Copy, Clone)]
struct Coord {
    x: usize,
    y: usize
}
impl From&lt;(usize,usize)&gt; for Coord {
    fn from(p: (usize, usize)) -&gt; Self {
        Coord { x:p.0, y:p.1 }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This provides a clean way to handle grid positions and includes a convenient conversion from tuples.</p>
<h4 id="grid-structure"><a class="header" href="#grid-structure">Grid Structure</a></h4>
<p>The core of the solution is a generic <code>Grid&lt;T&gt;</code> structure that can store any type of data in a 2D grid:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Grid&lt;T&gt; {
    width: usize,
    height: usize,
    grid: Vec&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The grid is stored as a flat vector for efficiency, with methods to access elements by coordinates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn tree(&amp;self, p: Coord) -&gt; Option&lt;&amp;T&gt; {
    if !self.in_bounds(p) {
        return None
    }
    Some(&amp;self.grid[p.y * self.width + p.x])
}
<span class="boring">}</span></code></pre></pre>
<h3 id="visibility-analysis"><a class="header" href="#visibility-analysis">Visibility Analysis</a></h3>
<p>The visibility analysis is handled by the <code>Visibility</code> struct, which keeps track of which trees are visible:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Visibility&lt;'a&gt; {
    forest: &amp;'a Grid&lt;i32&gt;,       // Reference to the forest grid
    visible: Grid&lt;bool&gt;,         // Grid tracking visible trees
}
<span class="boring">}</span></code></pre></pre>
<p>The key method is <code>scan_visibility</code>, which processes a sequence of coordinates in a given direction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scan_visibility(&amp;mut self, direction: ScanSequence) -&gt; &amp;mut Self {
    direction.into_iter()
        .for_each(|pos| {
            let mut tallest = -1;
            pos.into_iter().for_each(|e| {
                let tree = self.visible.tree_mut(e).unwrap();
                let t= self.forest.tree(e).unwrap();
                if tallest.lt(t) {
                    tallest = *t;
                    *tree = true;
                }
            });
        });
    self
}
<span class="boring">}</span></code></pre></pre>
<p>This method:</p>
<ol>
<li>Takes a sequence of coordinate sequences (representing scan lines)</li>
<li>For each scan line, tracks the tallest tree seen so far</li>
<li>Marks trees as visible if they're taller than all previous trees in the scan line</li>
</ol>
<p>By calling this method with scan sequences from all four directions (left-to-right, right-to-left, top-to-bottom, bottom-to-top), we can determine all visible trees.</p>
<h3 id="scenic-score-calculation"><a class="header" href="#scenic-score-calculation">Scenic Score Calculation</a></h3>
<p>The scenic score calculation is handled by the <code>Scenic</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Scenic&lt;'a&gt; {
    forest: &amp;'a Grid&lt;i32&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The main methods are:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scenic_score_dir(&amp;mut self, p:Coord, (dx,dy):(isize,isize)) -&gt; usize {
    let line = (1..).map_while(|i| {
        let coord = Coord {
            x: p.x.checked_add_signed(dx * i)?,
            y: p.y.checked_add_signed(dy * i)?,
        };
        self.forest.tree(coord)
    });

    let mut total = 0;
    let our_height = self.forest.tree(p).unwrap();
    for height in line {
        total += 1;
        if height &gt;= our_height {
            break;
        }
    }
    total
}

fn scenic_score(&amp;mut self, p: Coord) -&gt; usize {
    let dirs =  [(-1, 0), (1, 0), (0, -1), (0, 1)];
    dirs.into_iter()
        .map(|dir| self.scenic_score_dir(p,dir) )
        .product()
}
<span class="boring">}</span></code></pre></pre>
<p>These methods:</p>
<ol>
<li>Calculate the viewing distance in a specific direction using <code>scenic_score_dir</code></li>
<li>Combine the viewing distances in all four directions using <code>scenic_score</code></li>
</ol>
<p>The viewing distance calculation uses an infinite iterator with <code>map_while</code> to look in a specific direction until it reaches the edge or a blocking tree.</p>
<h3 id="generating-scan-sequences"><a class="header" href="#generating-scan-sequences">Generating Scan Sequences</a></h3>
<p>To scan the grid in different directions, the solution defines helper functions that generate sequences of coordinates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn left_to_right(f: &amp;Grid&lt;i32&gt;) -&gt; ScanSequence {
    (0..f.height)
        .map(|y| (0..f.width).map(move |x| (x, y).into()).collect::&lt;Vec&lt;Coord&gt;&gt;() )
        .collect::&lt;Vec&lt;_&gt;&gt;()
}

fn right_to_left(f: &amp;Grid&lt;i32&gt;) -&gt; ScanSequence {
    (0..f.height)
        .map(|y| (0..f.width).rev().map(move |x| (x, y).into()).collect::&lt;Vec&lt;Coord&gt;&gt;() )
        .collect::&lt;Vec&lt;_&gt;&gt;()
}

// Similar functions for top_to_bottom and bottom_to_up
<span class="boring">}</span></code></pre></pre>
<p>Each function generates a sequence of scan lines, where each scan line is a sequence of coordinates.</p>
<h3 id="parsing-the-input"><a class="header" href="#parsing-the-input">Parsing the Input</a></h3>
<p>The input is parsed into a grid of tree heights:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_forest(data: &amp;str) -&gt; Grid&lt;i32&gt;  {
    let width = data.lines().next().unwrap().len();
    let height = data.lines().count();
    let mut grid = Grid::new(width,height);

    for (y,line) in data.lines().enumerate() {
        for (x, val) in line.bytes().enumerate() {
            *grid.tree_mut((x,y).into()).unwrap() = (val - b'0') as i32;
        }
    }
    grid
}
<span class="boring">}</span></code></pre></pre>
<p>This converts each digit character to an integer height value.</p>
<h3 id="main-solution"><a class="header" href="#main-solution">Main Solution</a></h3>
<p>The main solution flow is:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let data = std::fs::read_to_string("src/bin/day8_input.txt").expect("Ops!");
    let grid = parse_forest(data.as_str());

    // Part 1: Count visible trees
    let count = Visibility::new(&amp;grid)
        .scan_visibility(left_to_right(&amp;grid))
        .scan_visibility(top_to_bottom(&amp;grid))
        .scan_visibility(right_to_left(&amp;grid))
        .scan_visibility(bottom_to_up(&amp;grid))
        .count_visible();
    println!("Total Visible = {:?}", count);

    // Part 2: Find maximum scenic score
    let mut scenic = Scenic::new(&amp;grid);
    let max = left_to_right(&amp;grid).into_iter()
        .flat_map(|x| x)
        .map(|p| scenic.scenic_score(p))
        .max().unwrap();
    println!("Max scenic = {:?}", max);
}</code></pre></pre>
<p>For Part 1, it scans the grid from all four directions and counts the visible trees. For Part 2, it calculates the scenic score for every tree and finds the maximum.</p>
<h2 id="algorithm-analysis"><a class="header" href="#algorithm-analysis">Algorithm Analysis</a></h2>
<h3 id="time-complexity"><a class="header" href="#time-complexity">Time Complexity</a></h3>
<ul>
<li><strong>Visibility Analysis</strong>: O(n²) where n is the grid dimension (width or height), as we scan each cell in each direction</li>
<li><strong>Scenic Score Calculation</strong>: O(n³) in the worst case, as for each of the n² cells we might need to look n steps in each direction</li>
</ul>
<h3 id="space-complexity"><a class="header" href="#space-complexity">Space Complexity</a></h3>
<ul>
<li><strong>Grid Storage</strong>: O(n²) to store the forest grid and visibility grid</li>
<li><strong>Scan Sequences</strong>: O(n²) to store the coordinate sequences</li>
</ul>
<h2 id="alternative-approaches"><a class="header" href="#alternative-approaches">Alternative Approaches</a></h2>
<h3 id="single-pass-visibility-check"><a class="header" href="#single-pass-visibility-check">Single-Pass Visibility Check</a></h3>
<p>For the visibility check, an alternative approach would be to use dynamic programming to precompute the maximum height seen from each direction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Precompute maximum heights from left
let mut max_left = vec![vec![-1; width]; height];
for y in 0..height {
    for x in 0..width {
        if x &gt; 0 {
            max_left[y][x] = max(max_left[y][x-1], grid[y][x-1]);
        }
    }
}
// Similar for other directions

// Check visibility
for y in 0..height {
    for x in 0..width {
        if grid[y][x] &gt; max_left[y][x] || grid[y][x] &gt; max_right[y][x] || 
           grid[y][x] &gt; max_top[y][x] || grid[y][x] &gt; max_bottom[y][x] {
            visible[y][x] = true;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This would have the same asymptotic complexity but might be faster in practice due to better cache locality.</p>
<h3 id="optimized-scenic-score-calculation"><a class="header" href="#optimized-scenic-score-calculation">Optimized Scenic Score Calculation</a></h3>
<p>For the scenic score calculation, we could optimize by precomputing the viewing distance in each direction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut view_distance = vec![vec![(0, 0, 0, 0); width]; height];

// Compute left viewing distances
for y in 0..height {
    let mut last_height = vec![0; 10];
    for x in 0..width {
        let h = grid[y][x] as usize;
        view_distance[y][x].0 = x - *last_height[..=h].iter().max().unwrap_or(&amp;0);
        last_height[h] = x;
    }
}
// Similar for other directions
<span class="boring">}</span></code></pre></pre>
<p>This would reduce the time complexity to O(n²), but would be more complex to implement.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This solution demonstrates how to efficiently work with 2D grids and perform directional scanning operations. The use of custom data structures for coordinates and grids makes the code clean and maintainable, while the separation of visibility analysis and scenic score calculation into different structs keeps the code organized.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day8/problem.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../day8/code.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day8/problem.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../day8/code.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
