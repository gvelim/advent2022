<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Advent of Code 2022 Solutions</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation and explanations for Advent of Code 2022 solutions">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Advent of Code 2022 Solutions</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="advent-of-code-2022"><a class="header" href="#advent-of-code-2022">Advent of Code 2022</a></h1>
<p>This book documents solutions to the <a href="https://adventofcode.com/2022">Advent of Code 2022</a> programming puzzles implemented in Rust.</p>
<h2 id="about-advent-of-code"><a class="header" href="#about-advent-of-code">About Advent of Code</a></h2>
<p>Advent of Code is an annual set of Christmas-themed programming puzzles created by Eric Wastl. Each year, starting on December 1st, a new programming puzzle is released every day until December 25th. These puzzles can be solved in any programming language and cover a wide range of algorithms, data structures, and problem-solving techniques.</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>This project contains solutions for Advent of Code 2022 implemented in Rust. Each day's puzzle has its own binary in the <code>src/bin</code> directory with a corresponding input file. This book provides explanations, walkthroughs, and code snippets for each solution.</p>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to Use This Book</a></h2>
<p>You can navigate through the solutions using the sidebar. Each day's solution is organized into:</p>
<ul>
<li><strong>Problem Description</strong>: A summary of the day's challenge</li>
<li><strong>Solution Explanation</strong>: A detailed walkthrough of the approach used</li>
<li><strong>Code</strong>: The complete implementation with comments</li>
</ul>
<h2 id="running-the-solutions"><a class="header" href="#running-the-solutions">Running the Solutions</a></h2>
<p>To run any day's solution, use Cargo with the appropriate bin target. For example:</p>
<pre><code class="language-bash"># Run Day 1's solution
cargo run --bin day1
</code></pre>
<p>You can also compile and run in release mode for better performance:</p>
<pre><code class="language-bash">cargo run --release --bin day1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-1-calorie-counting"><a class="header" href="#day-1-calorie-counting">Day 1: Calorie Counting</a></h1>
<p>Day 1 involves calculating the total calories carried by elves and finding which elves carry the most calories.</p>
<h2 id="problem-overview"><a class="header" href="#problem-overview">Problem Overview</a></h2>
<p>The elves are on an expedition and each carries different food items with different calorie values. Your task is to:</p>
<ol>
<li>Calculate the total calories carried by each elf</li>
<li>Find which elf is carrying the most calories</li>
<li>Find the sum of calories carried by the top three elves</li>
</ol>
<h2 id="navigation"><a class="header" href="#navigation">Navigation</a></h2>
<ul>
<li><a href="day1/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day1/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day1/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-1-problem-description"><a class="header" href="#day-1-problem-description">Day 1: Problem Description</a></h1>
<h2 id="calorie-counting"><a class="header" href="#calorie-counting">Calorie Counting</a></h2>
<p>The jungle must be too overgrown and difficult to navigate in vehicles or access from the air; the Elves' expedition traditionally goes on foot. As your boats approach land, the Elves begin taking inventory of their supplies. One important consideration is food - in particular, the number of <strong>Calories</strong> each Elf is carrying.</p>
<p>The Elves take turns writing down the number of Calories contained in the various meals, snacks, rations, etc. that they've brought with them, one item per line. Each Elf separates their own inventory from the previous Elf's inventory (if any) by a blank line.</p>
<p>For example, suppose the Elves finish writing their items' Calories and end up with the following list:</p>
<pre><code>1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
</code></pre>
<p>This list represents the Calories of the food carried by five Elves:</p>
<ul>
<li>The first Elf is carrying food with 1000, 2000, and 3000 Calories, a total of <strong>6000</strong> Calories.</li>
<li>The second Elf is carrying one food item with <strong>4000</strong> Calories.</li>
<li>The third Elf is carrying food with 5000 and 6000 Calories, a total of <strong>11000</strong> Calories.</li>
<li>The fourth Elf is carrying food with 7000, 8000, and 9000 Calories, a total of <strong>24000</strong> Calories.</li>
<li>The fifth Elf is carrying one food item with <strong>10000</strong> Calories.</li>
</ul>
<h2 id="part-1"><a class="header" href="#part-1">Part 1</a></h2>
<p>In case the Elves get hungry and need extra snacks, they need to know which Elf to ask: they'd like to know how many Calories are being carried by the Elf carrying the <strong>most</strong> Calories. In the example above, this is <strong>24000</strong> (carried by the fourth Elf).</p>
<p>Find the Elf carrying the most Calories. <strong>How many total Calories is that Elf carrying?</strong></p>
<h2 id="part-2"><a class="header" href="#part-2">Part 2</a></h2>
<p>By the time you calculate the answer to the Elves' question, they've already realized that the Elf carrying the most Calories of food might eventually <strong>run out of snacks</strong>.</p>
<p>To avoid this unacceptable situation, the Elves would instead like to know the total Calories carried by the <strong>top three</strong> Elves carrying the most Calories. That way, even if one of those Elves runs out of snacks, they still have two backups.</p>
<p>In the example above, the top three Elves are the fourth Elf (with 24000 Calories), then the third Elf (with 11000 Calories), then the fifth Elf (with 10000 Calories). The sum of the Calories carried by these three elves is <strong>45000</strong>.</p>
<p>Find the top three Elves carrying the most Calories. <strong>How many Calories are those Elves carrying in total?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-1-solution-explanation"><a class="header" href="#day-1-solution-explanation">Day 1: Solution Explanation</a></h1>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<p>Day 1's problem requires us to parse a list of calorie values grouped by elves, calculate the total calories per elf, and then find either the maximum value (part 1) or the sum of the top three values (part 2).</p>
<h3 id="step-1-parse-the-input"><a class="header" href="#step-1-parse-the-input">Step 1: Parse the Input</a></h3>
<p>The input format consists of groups of numbers separated by blank lines. Each group represents the food items carried by a single elf. We need to:</p>
<ol>
<li>Split the input by blank lines to get each elf's inventory</li>
<li>For each elf's inventory, parse the individual calorie values and sum them</li>
</ol>
<h3 id="step-2-find-the-maximum-part-1"><a class="header" href="#step-2-find-the-maximum-part-1">Step 2: Find the Maximum (Part 1)</a></h3>
<p>Once we have the total calories for each elf, we simply find the maximum value among them.</p>
<h3 id="step-3-find-the-sum-of-top-three-part-2"><a class="header" href="#step-3-find-the-sum-of-top-three-part-2">Step 3: Find the Sum of Top Three (Part 2)</a></h3>
<p>To find the sum of the top three values:</p>
<ol>
<li>Sort the list of calorie sums in descending order</li>
<li>Take the first three elements</li>
<li>Sum them</li>
</ol>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="parsing-the-input"><a class="header" href="#parsing-the-input">Parsing the Input</a></h3>
<p>We use Rust's string splitting capabilities to parse the input:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_input(input: &amp;str) -&gt; Vec&lt;u32&gt; {
    input
        .split("\n\n") // Split by blank lines to get each elf's inventory
        .map(|elf| {
            elf.lines() // Split each elf's inventory by lines
                .filter_map(|line| line.parse::&lt;u32&gt;().ok()) // Parse each line to a number
                .sum() // Sum the calories for each elf
        })
        .collect() // Collect into a vector of total calories per elf
}
<span class="boring">}</span></code></pre></pre>
<h3 id="solving-part-1"><a class="header" href="#solving-part-1">Solving Part 1</a></h3>
<p>Finding the maximum value is straightforward:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn part1(calories: &amp;[u32]) -&gt; u32 {
    *calories.iter().max().unwrap_or(&amp;0)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="solving-part-2"><a class="header" href="#solving-part-2">Solving Part 2</a></h3>
<p>For part 2, we sort the values and sum the top three:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn part2(calories: &amp;[u32]) -&gt; u32 {
    let mut sorted = calories.to_vec();
    sorted.sort_unstable_by(|a, b| b.cmp(a)); // Sort in descending order
    sorted.iter().take(3).sum() // Sum the top three values
}
<span class="boring">}</span></code></pre></pre>
<h2 id="time-and-space-complexity"><a class="header" href="#time-and-space-complexity">Time and Space Complexity</a></h2>
<ul>
<li><strong>Time Complexity</strong>: O(n log n) where n is the number of elves, due to the sorting operation in part 2</li>
<li><strong>Space Complexity</strong>: O(n) for storing the calorie totals for each elf</li>
</ul>
<h2 id="alternative-approaches"><a class="header" href="#alternative-approaches">Alternative Approaches</a></h2>
<h3 id="using-a-priority-queue"><a class="header" href="#using-a-priority-queue">Using a Priority Queue</a></h3>
<p>Instead of sorting the entire list for part 2, we could use a min-heap of size 3 to keep track of the top three values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::BinaryHeap;
use std::cmp::Reverse;

fn part2_with_heap(calories: &amp;[u32]) -&gt; u32 {
    let mut heap = BinaryHeap::new();
    
    for &amp;calorie in calories {
        heap.push(Reverse(calorie));
        if heap.len() &gt; 3 {
            heap.pop();
        }
    }
    
    heap.into_iter().map(|Reverse(cal)| cal).sum()
}
<span class="boring">}</span></code></pre></pre>
<p>This approach has a time complexity of O(n log 3) â‰ˆ O(n), which is more efficient than sorting the entire list.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-1-code"><a class="header" href="#day-1-code">Day 1: Code</a></h1>
<p>Below is the complete code for Day 1's solution. The solution uses a <code>BinaryHeap</code> to efficiently track the elves with the most calories.</p>
<h2 id="full-solution"><a class="header" href="#full-solution">Full Solution</a></h2>
<pre><pre class="playground"><code class="language-rust no_run no_playground">use std::collections::BinaryHeap;
use std::str::FromStr;

fn main() {

    let fs = std::fs::read_to_string("./src/bin/day1_input.txt").unwrap_or_else(|e| panic!("{e}"));

    let out = fs.split("\n\n")
        .map(|e| e.split('\n'))
        .map(|v|
            v.filter_map(|e| u64::from_str(e).ok() ).collect::&lt;Vec&lt;u64&gt;&gt;()
        )
        .fold(BinaryHeap::new(), |mut out, v|{
            out.push(v.iter().sum::&lt;u64&gt;());
            out
        });
    println!("Q1: {:?}",out.iter().take(3).collect::&lt;Vec&lt;_&gt;&gt;());
    println!("Q2: {:?}",out.iter().take(3).sum::&lt;u64&gt;());

}</code></pre></pre>
<h2 id="code-walkthrough"><a class="header" href="#code-walkthrough">Code Walkthrough</a></h2>
<h3 id="imports"><a class="header" href="#imports">Imports</a></h3>
<pre><pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::BinaryHeap;
use std::str::FromStr;
<span class="boring">}</span></code></pre></pre>
<p>The solution imports:</p>
<ul>
<li><code>BinaryHeap</code> - A max-heap implementation for efficiently finding the largest elements</li>
<li><code>FromStr</code> - A trait for parsing strings into other types</li>
</ul>
<h3 id="input-parsing-and-solution"><a class="header" href="#input-parsing-and-solution">Input Parsing and Solution</a></h3>
<pre><pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let fs = std::fs::read_to_string("./src/bin/day1_input.txt").unwrap_or_else(|e| panic!("{e}"));

    let out = fs.split("\n\n")
        .map(|e| e.split('\n'))
        .map(|v|
            v.filter_map(|e| u64::from_str(e).ok() ).collect::&lt;Vec&lt;u64&gt;&gt;()
        )
        .fold(BinaryHeap::new(), |mut out, v|{
            out.push(v.iter().sum::&lt;u64&gt;());
            out
        });
<span class="boring">}</span></code></pre></pre>
<p>The code:</p>
<ol>
<li>Reads the input file as a string</li>
<li>Splits the input by double newlines (<code>\n\n</code>) to separate each elf's inventory</li>
<li>For each elf, splits their inventory by single newlines</li>
<li>Parses each line into a <code>u64</code> integer, filtering out any lines that can't be parsed</li>
<li>Collects each elf's calories into a vector</li>
<li>Uses <code>fold</code> to build a <code>BinaryHeap</code> containing the sum of calories for each elf</li>
</ol>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<pre><pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!("Q1: {:?}",out.iter().take(3).collect::&lt;Vec&lt;_&gt;&gt;());
    println!("Q2: {:?}",out.iter().take(3).sum::&lt;u64&gt;());
<span class="boring">}</span></code></pre></pre>
<p>The code outputs:</p>
<ol>
<li>For part 1: The top three calorie counts (the first one is the answer to part 1)</li>
<li>For part 2: The sum of the top three calorie counts</li>
</ol>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<ul>
<li>The solution leverages Rust's <code>BinaryHeap</code> which is a max-heap, automatically giving us the largest elements first</li>
<li>Instead of sorting the entire list of elf calorie totals, this approach is more efficient because it directly gives us the largest values first</li>
<li>The solution combines both part 1 and part 2 into a single processing pipeline</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-2-rock-paper-scissors"><a class="header" href="#day-2-rock-paper-scissors">Day 2: Rock Paper Scissors</a></h1>
<p>Day 2 involves implementing the rules of Rock Paper Scissors and calculating scores based on different strategy interpretations.</p>
<h2 id="problem-overview-1"><a class="header" href="#problem-overview-1">Problem Overview</a></h2>
<p>You need to play Rock Paper Scissors against elves. Given an encrypted strategy guide with two columns, you need to:</p>
<ol>
<li>Calculate your total score following the first interpretation of the guide</li>
<li>Calculate your total score following the second interpretation of the guide</li>
</ol>
<p>Your score for each round is the sum of:</p>
<ul>
<li>Points for the shape you selected (1 for Rock, 2 for Paper, 3 for Scissors)</li>
<li>Points for the outcome (0 for loss, 3 for draw, 6 for win)</li>
</ul>
<h2 id="navigation-1"><a class="header" href="#navigation-1">Navigation</a></h2>
<ul>
<li><a href="day2/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day2/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day2/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-2-problem-description"><a class="header" href="#day-2-problem-description">Day 2: Problem Description</a></h1>
<h2 id="rock-paper-scissors"><a class="header" href="#rock-paper-scissors">Rock Paper Scissors</a></h2>
<p>The Elves begin to set up camp on the beach. To decide whose tent gets to be closest to the snack storage, a giant Rock Paper Scissors tournament is already in progress.</p>
<p>Rock Paper Scissors is a game between two players. Each game contains many rounds; in each round, the players each simultaneously choose one of Rock, Paper, or Scissors using a hand shape. Then, a winner for that round is selected: Rock defeats Scissors, Scissors defeats Paper, and Paper defeats Rock. If both players choose the same shape, the round instead ends in a draw.</p>
<p>Appreciative of your help yesterday, one Elf gives you an <strong>encrypted strategy guide</strong> (your puzzle input) that they say will be sure to help you win. "The first column is what your opponent is going to play: A for Rock, B for Paper, and C for Scissors. The second column--" Suddenly, the Elf is called away to help with someone's tent.</p>
<p>The second column, you reason, must be what you should play in response: X for Rock, Y for Paper, and Z for Scissors. Winning every time would be suspicious, so the responses must have been carefully chosen.</p>
<p>The winner of the whole tournament is the player with the highest score. Your <strong>total score</strong> is the sum of your scores for each round. The score for a single round is the score for the <strong>shape you selected</strong> (1 for Rock, 2 for Paper, and 3 for Scissors) plus the score for the <strong>outcome of the round</strong> (0 if you lost, 3 if the round was a draw, and 6 if you won).</p>
<p>For example, suppose you were given the following strategy guide:</p>
<pre><code>A Y
B X
C Z
</code></pre>
<p>This strategy guide predicts and recommends the following:</p>
<ul>
<li>In the first round, your opponent will choose Rock (A), and you should choose Paper (Y). This ends in a win for you with a score of 8 (2 for choosing Paper + 6 for winning).</li>
<li>In the second round, your opponent will choose Paper (B), and you should choose Rock (X). This ends in a loss for you with a score of 1 (1 for choosing Rock + 0 for losing).</li>
<li>In the third round, your opponent will choose Scissors (C), and you should choose Scissors (Z). This ends in a draw with a score of 6 (3 for choosing Scissors + 3 for drawing).</li>
</ul>
<p>So, in this example, if you were to follow the strategy guide, you would get a total score of <strong>15</strong> (8 + 1 + 6).</p>
<h2 id="part-1-1"><a class="header" href="#part-1-1">Part 1</a></h2>
<p><strong>What would your total score be if everything goes exactly according to your strategy guide?</strong></p>
<h2 id="part-2-1"><a class="header" href="#part-2-1">Part 2</a></h2>
<p>The Elf finishes helping with the tent and sneaks back over to you. "Anyway, the second column says how the round needs to end: X means you need to lose, Y means you need to end the round in a draw, and Z means you need to win. Good luck!"</p>
<p>Now, you need to figure out what shape to choose so the round ends as indicated. The total score is still calculated in the same way, but now you need to figure out what shape to choose so the round ends as indicated.</p>
<p>For example, suppose you were given the same strategy guide:</p>
<pre><code>A Y
B X
C Z
</code></pre>
<p>This strategy guide now predicts and recommends the following:</p>
<ul>
<li>In the first round, your opponent will choose Rock (A), and you need to end the round in a draw (Y), so you also choose Rock. This gives you a score of 4 (1 + 3).</li>
<li>In the second round, your opponent will choose Paper (B), and you need to lose (X), so you choose Rock. This gives you a score of 1 (1 + 0).</li>
<li>In the third round, your opponent will choose Scissors (C), and you need to win (Z), so you choose Rock. This gives you a score of 7 (1 + 6).</li>
</ul>
<p>Following this new interpretation of the strategy guide, you would get a total score of <strong>12</strong> (4 + 1 + 7).</p>
<p><strong>Following the Elf's instructions for the second column, what would your total score be if everything goes exactly according to your strategy guide?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-2-solution-explanation"><a class="header" href="#day-2-solution-explanation">Day 2: Solution Explanation</a></h1>
<h2 id="approach-1"><a class="header" href="#approach-1">Approach</a></h2>
<p>Day 2's problem requires implementing a Rock Paper Scissors game with two different interpretations of a strategy guide. We need to:</p>
<ol>
<li>Parse the input into rounds of play</li>
<li>Calculate scores for each round according to both interpretations</li>
<li>Sum the scores to get the total</li>
</ol>
<h3 id="strategy-1-vs-strategy-2"><a class="header" href="#strategy-1-vs-strategy-2">Strategy 1 vs Strategy 2</a></h3>
<p>The key difference between the two strategies is the interpretation of the second column:</p>
<ul>
<li><strong>Strategy 1</strong>: The second column (X, Y, Z) represents your move (Rock, Paper, Scissors)</li>
<li><strong>Strategy 2</strong>: The second column represents the desired outcome (Lose, Draw, Win)</li>
</ul>
<h3 id="game-logic"><a class="header" href="#game-logic">Game Logic</a></h3>
<p>To implement the game, we need to model:</p>
<ol>
<li>The possible moves (Rock, Paper, Scissors)</li>
<li>The possible outcomes (Win, Loss, Draw)</li>
<li>The scoring rules for moves and outcomes</li>
<li>The winning relationships between moves</li>
<li>How to derive a move given an opponent's move and a desired outcome</li>
</ol>
<h2 id="implementation-details-1"><a class="header" href="#implementation-details-1">Implementation Details</a></h2>
<h3 id="the-move-enum"><a class="header" href="#the-move-enum">The Move Enum</a></h3>
<p>We define a <code>Move</code> enum with values for Rock, Paper, and Scissors, each with its corresponding score value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug,Copy,Clone,PartialEq)]
enum Move { Rock=1, Paper, Scissors }
<span class="boring">}</span></code></pre></pre>
<p>The numeric values (1, 2, 3) are automatically assigned based on the enum declaration order.</p>
<h3 id="parsing-input"><a class="header" href="#parsing-input">Parsing Input</a></h3>
<p>We implement the <code>From&lt;u8&gt;</code> trait to convert characters from the input into <code>Move</code> values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;u8&gt; for Move {
    fn from(c: u8) -&gt; Self {
        match c {
            b'A' | b'X' =&gt; Move::Rock,
            b'B' | b'Y' =&gt; Move::Paper,
            b'C' | b'Z' =&gt; Move::Scissors,
            _ =&gt; unreachable!()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="determining-outcomes"><a class="header" href="#determining-outcomes">Determining Outcomes</a></h3>
<p>We implement a method to determine if one move wins against another:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_winning(&amp;self, other:&amp;Self) -&gt; bool {
    matches!(
        (other,self),
        (Move::Rock, Move::Paper) |
        (Move::Paper, Move::Scissors) |
        (Move::Scissors, Move::Rock)
    )
}
<span class="boring">}</span></code></pre></pre>
<p>And a method to determine the outcome of a round:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn outcome(&amp;self, other:&amp;Self) -&gt; Outcome {
    if self.is_winning(other) {
        Outcome::Win
    } else if other.is_winning(self) {
        Outcome::Loss
    } else {
        Outcome::Draw
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="strategy-2-deriving-moves"><a class="header" href="#strategy-2-deriving-moves">Strategy 2: Deriving Moves</a></h3>
<p>For Strategy 2, we need to determine what move to make given an opponent's move and a desired outcome:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn derive(&amp;self, out:Outcome) -&gt; Move {
    let iter = once(Move::Rock).chain(once(Move::Paper)).chain(once(Move::Scissors)).cycle();
    iter.skip_while(|e| self != e).skip(out as usize).next().unwrap()
}
<span class="boring">}</span></code></pre></pre>
<p>This is a clever solution that creates a circular iterator of moves and skips to the move that produces the desired outcome.</p>
<h3 id="scoring"><a class="header" href="#scoring">Scoring</a></h3>
<p>We define an <code>Outcome</code> enum and implement scoring for outcomes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Outcome { Draw, Win, Loss }

impl Outcome {
    fn score_value(&amp;self) -&gt; u64 {
        match self {
            Outcome::Loss =&gt; 0,
            Outcome::Draw =&gt; 3,
            Outcome::Win =&gt; 6
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="combining-everything"><a class="header" href="#combining-everything">Combining Everything</a></h3>
<p>We create a <code>Round</code> struct to represent a round of Rock Paper Scissors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Round(Move,Move);

impl Round {
    fn score(&amp;self) -&gt; u64 {
        let Round(other, me) = self;
        me.outcome(other).score_value() + *me as u64
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Each round is scored by adding the outcome value to the value of the move chosen.</p>
<h3 id="processing-the-input"><a class="header" href="#processing-the-input">Processing the Input</a></h3>
<p>Finally, we process the input file, calculating scores for both strategies:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let (score1, score2) = std::fs::read_to_string("./src/bin/day2_input.txt")
        .unwrap()
        .lines()
        .map(|round| (
            Round::new(round).score(),      // Strategy 1
            Round::derived(round).score()   // Strategy 2
        ))
        .reduce(|sum, round| {
            (sum.0 + round.0, sum.1 + round.1)
        })
        .unwrap_or_else(|| panic!("Empty iterator ?"));
    
    println!("Strategy 1 : {:?}",score1);
    println!("Strategy 2 : {:?}",score2);
}</code></pre></pre>
<p>We map each line to a tuple of scores for both strategies, then reduce the results to get the total scores.</p>
<h2 id="alternative-approaches-1"><a class="header" href="#alternative-approaches-1">Alternative Approaches</a></h2>
<h3 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h3>
<p>A simpler approach could use direct pattern matching for each input combination:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn strategy_1(round:&amp;str) -&gt; u64 {
    match round {
        "A X" =&gt; 3+1, // Rock vs Rock = Draw (3) + Rock (1)
        "A Y" =&gt; 6+2, // Rock vs Paper = Win (6) + Paper (2)
        "A Z" =&gt; 0+3, // Rock vs Scissors = Loss (0) + Scissors (3)
        // ... other combinations
        _ =&gt; panic!("unknown input")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>While this approach is more direct, it's less flexible and doesn't model the game's logic as cleanly.</p>
<h2 id="optimization-considerations"><a class="header" href="#optimization-considerations">Optimization Considerations</a></h2>
<ul>
<li>The current solution uses enums to represent both moves and outcomes, which makes the code clear and easy to understand.</li>
<li>The <code>derive</code> method is particularly elegant, using Rust's iterator functionality to find the right move.</li>
<li>For very large inputs, we could consider using a lookup table for move derivation instead of the iterator approach.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-2-code"><a class="header" href="#day-2-code">Day 2: Code</a></h1>
<p>Below is the complete code for Day 2's solution, which implements Rock Paper Scissors with two different interpretations of the strategy guide.</p>
<h2 id="full-solution-1"><a class="header" href="#full-solution-1">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">use std::iter::once;

#[derive(Debug,Copy,Clone,PartialEq)]
enum Move { Rock=1, Paper, Scissors }
impl From&lt;u8&gt; for Move {
    fn from(c: u8) -&gt; Self {
        match c {
            b'A' | b'X' =&gt; Move::Rock,
            b'B' | b'Y' =&gt; Move::Paper,
            b'C' | b'Z' =&gt; Move::Scissors,
            _ =&gt; unreachable!()
        }
    }
}
impl Move {
    fn is_winning(&amp;self, other:&amp;Self) -&gt; bool {
        matches!(
            (other,self),
            (Move::Rock, Move::Paper) |
            (Move::Paper, Move::Scissors) |
            (Move::Scissors, Move::Rock)
        )
    }
    fn outcome(&amp;self, other:&amp;Self) -&gt; Outcome {
        if self.is_winning(other) {
            Outcome::Win
        } else if other.is_winning(self) {
            Outcome::Loss
        } else {
            Outcome::Draw
        }
    }
    fn derive(&amp;self, out:Outcome) -&gt; Move {
        let iter = once(Move::Rock).chain(once(Move::Paper)).chain(once(Move::Scissors)).cycle();
        // match out {
        //     Outcome::Draw =&gt; iter.skip_while(|e| self != e).skip(0).next(),
        //     Outcome::Win =&gt; iter.skip_while(|e| self != e).skip(1).next()
        //     Outcome::Loss =&gt; iter.skip_while(|e| self != e).skip(2).next(),
        // }.unwrap()
        iter.skip_while(|e| self != e).skip(out as usize).next().unwrap()
    }
}
#[derive(Debug,Copy,Clone)]
enum Outcome { Draw, Win, Loss }
impl From&lt;Move&gt; for Outcome {
    fn from(m: Move) -&gt; Self {
        match m {
            Move::Rock =&gt; Outcome::Loss,
            Move::Paper =&gt; Outcome::Draw,
            Move::Scissors =&gt; Outcome::Win
        }
    }
}
impl Outcome {
    fn score_value(&amp;self) -&gt; u64 {
        match self {
            Outcome::Loss =&gt; 0,
            Outcome::Draw =&gt; 3,
            Outcome::Win =&gt; 6
        }
    }
}
#[derive(Debug,Copy,Clone)]
struct Round(Move,Move);
impl Round {
    fn new(round:&amp;str) -&gt; Round {
        if let &amp;[a,_,b] = round.as_bytes() { Round(Move::from(a), Move::from(b)) } else { unreachable!() }
    }
    fn derived(round:&amp;str) -&gt; Round {
        let Round(a,b) = Round::new(round);
        Round(a, a.derive(Outcome::from(b)))
    }
    fn score(&amp;self) -&gt; u64 {
        let Round(other, me) = self;
        me.outcome(other).score_value() + *me as u64
    }
}

fn main() {
    let (score1, score2) = std::fs::read_to_string("./src/bin/day2_input.txt")
        .unwrap()
        .lines()
        .map(|round| (
            Round::new(round).score(),
            Round::derived(round).score()
        ))
        .reduce(|sum, round| {
            (sum.0 + round.0, sum.1 + round.1)
        })
        .unwrap_or_else(|| panic!("Empty iterator ?"));
    println!("Strategy 1 : 15632 {:?}",score1);
    println!("Strategy 2 : 14416 {:?}",score2);
}

// fn strategy_1(round:&amp;str) -&gt; u64 {
//     match round {
//         // Question 1: ABC, XYZ denotes player choices
//         "A X" =&gt; 3+1,
//         "A Y" =&gt; 6+2,
//         "A Z" =&gt; 0+3,
//         "B X" =&gt; 0+1,
//         "B Y" =&gt; 3+2,
//         "B Z" =&gt; 6+3,
//         "C X" =&gt; 6+1,
//         "C Y" =&gt; 0+2,
//         "C Z" =&gt; 3+3,
//         _ =&gt; panic!("unknown input")
//     }
// }
// fn strategy_2(round:&amp;str) -&gt; u64 {
//     match round {
//         // Question 2: XYZ denotes your choice results to loose, draw, win
//         "A X" =&gt; 0+3,
//         "A Y" =&gt; 3+1,
//         "A Z" =&gt; 6+2,
//         "B X" =&gt; 0+1,
//         "B Y" =&gt; 3+2,
//         "B Z" =&gt; 6+3,
//         "C X" =&gt; 0+2,
//         "C Y" =&gt; 3+3,
//         "C Z" =&gt; 6+1,
//         _ =&gt; panic!("unknown input")
//     }
// }</code></pre>
<h2 id="code-walkthrough-1"><a class="header" href="#code-walkthrough-1">Code Walkthrough</a></h2>
<h3 id="core-types"><a class="header" href="#core-types">Core Types</a></h3>
<p>The solution uses three main types:</p>
<ol>
<li><strong>Move Enum</strong>: Represents Rock, Paper, or Scissors with their score values:</li>
</ol>
<pre><code class="language-rust no_run noplayground">#[derive(Debug,Copy,Clone,PartialEq)]
enum Move { Rock=1, Paper, Scissors }</code></pre>
<ol start="2">
<li><strong>Outcome Enum</strong>: Represents the possible outcomes of a round:</li>
</ol>
<pre><code class="language-rust no_run noplayground">enum Outcome { Draw, Win, Loss }
impl From&lt;Move&gt; for Outcome {</code></pre>
<ol start="3">
<li><strong>Round Struct</strong>: Represents a round of Rock Paper Scissors:</li>
</ol>
<pre><code class="language-rust no_run noplayground">#[derive(Debug,Copy,Clone)]
struct Round(Move,Move);</code></pre>
<h3 id="game-logic-1"><a class="header" href="#game-logic-1">Game Logic</a></h3>
<p>The solution implements several key methods:</p>
<ol>
<li><strong>Determining Win Conditions</strong>:</li>
</ol>
<pre><code class="language-rust no_run noplayground">    fn is_winning(&amp;self, other:&amp;Self) -&gt; bool {
        matches!(
            (other,self),
            (Move::Rock, Move::Paper) |
            (Move::Paper, Move::Scissors) |
            (Move::Scissors, Move::Rock)
        )
    }</code></pre>
<ol start="2">
<li><strong>Determining Game Outcomes</strong>:</li>
</ol>
<pre><code class="language-rust no_run noplayground">    fn outcome(&amp;self, other:&amp;Self) -&gt; Outcome {
        if self.is_winning(other) {
            Outcome::Win
        } else if other.is_winning(self) {
            Outcome::Loss
        } else {
            Outcome::Draw
        }
    }</code></pre>
<ol start="3">
<li><strong>Deriving Moves Based on Desired Outcome</strong>:</li>
</ol>
<pre><code class="language-rust no_run noplayground">    fn derive(&amp;self, out:Outcome) -&gt; Move {
        let iter = once(Move::Rock).chain(once(Move::Paper)).chain(once(Move::Scissors)).cycle();
        // match out {
        //     Outcome::Draw =&gt; iter.skip_while(|e| self != e).skip(0).next(),
        //     Outcome::Win =&gt; iter.skip_while(|e| self != e).skip(1).next()
        //     Outcome::Loss =&gt; iter.skip_while(|e| self != e).skip(2).next(),
        // }.unwrap()
        iter.skip_while(|e| self != e).skip(out as usize).next().unwrap()
    }</code></pre>
<h3 id="processing-input"><a class="header" href="#processing-input">Processing Input</a></h3>
<p>The solution processes the input file and calculates scores for both strategies in a single pass:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    let (score1, score2) = std::fs::read_to_string("./src/bin/day2_input.txt")
        .unwrap()
        .lines()
        .map(|round| (
            Round::new(round).score(),
            Round::derived(round).score()
        ))
        .reduce(|sum, round| {
            (sum.0 + round.0, sum.1 + round.1)
        })
        .unwrap_or_else(|| panic!("Empty iterator ?"));
    println!("Strategy 1 : 15632 {:?}",score1);
    println!("Strategy 2 : 14416 {:?}",score2);
}</code></pre>
<h3 id="alternative-approach"><a class="header" href="#alternative-approach">Alternative Approach</a></h3>
<p>The commented-out functions at the end show an alternative approach using direct pattern matching for each input combination:</p>
<pre><code class="language-rust no_run noplayground">// fn strategy_1(round:&amp;str) -&gt; u64 {
//     match round {
//         // Question 1: ABC, XYZ denotes player choices
//         "A X" =&gt; 3+1,
//         "A Y" =&gt; 6+2,
//         "A Z" =&gt; 0+3,
//         "B X" =&gt; 0+1,
//         "B Y" =&gt; 3+2,
//         "B Z" =&gt; 6+3,
//         "C X" =&gt; 6+1,
//         "C Y" =&gt; 0+2,
//         "C Z" =&gt; 3+3,
//         _ =&gt; panic!("unknown input")
//     }
// }
// fn strategy_2(round:&amp;str) -&gt; u64 {
//     match round {
//         // Question 2: XYZ denotes your choice results to loose, draw, win
//         "A X" =&gt; 0+3,
//         "A Y" =&gt; 3+1,
//         "A Z" =&gt; 6+2,
//         "B X" =&gt; 0+1,
//         "B Y" =&gt; 3+2,
//         "B Z" =&gt; 6+3,
//         "C X" =&gt; 0+2,
//         "C Y" =&gt; 3+3,
//         "C Z" =&gt; 6+1,
//         _ =&gt; panic!("unknown input")
//     }
// }</code></pre>
<p>This approach is more direct but less flexible than modeling the game with proper types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-3-rucksack-reorganization"><a class="header" href="#day-3-rucksack-reorganization">Day 3: Rucksack Reorganization</a></h1>
<p>Day 3 involves finding common items in rucksacks and determining their priorities.</p>
<h2 id="problem-overview-2"><a class="header" href="#problem-overview-2">Problem Overview</a></h2>
<p>Elves packed their rucksacks incorrectly, and you need to help them find the misplaced items. Each rucksack has two compartments, and items of the same type should go in the same compartment. Your tasks:</p>
<ol>
<li>Find items that appear in both compartments of each rucksack</li>
<li>Find badges (items common to each group of three elves)</li>
<li>Calculate the sum of priorities for these items</li>
</ol>
<p>Each item type is identified by a single letter (case-sensitive) and has a priority value:</p>
<ul>
<li>Lowercase letters (a-z) have priorities 1-26</li>
<li>Uppercase letters (A-Z) have priorities 27-52</li>
</ul>
<h2 id="navigation-2"><a class="header" href="#navigation-2">Navigation</a></h2>
<ul>
<li><a href="day3/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day3/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day3/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-3-problem-description"><a class="header" href="#day-3-problem-description">Day 3: Problem Description</a></h1>
<h2 id="rucksack-reorganization"><a class="header" href="#rucksack-reorganization">Rucksack Reorganization</a></h2>
<p>One Elf has the important job of loading all of the rucksacks with supplies for the jungle journey. Unfortunately, that Elf didn't quite follow the packing instructions, and so a few items now need to be rearranged.</p>
<p>Each rucksack has two large <strong>compartments</strong>. All items of a given type are meant to go into exactly one of the two compartments. The Elf that did the packing failed to follow this rule for exactly one item type per rucksack.</p>
<p>The Elves have made a list of all of the items currently in each rucksack (your puzzle input), but they need your help finding the errors. Every item type is identified by a single lowercase or uppercase letter (that is, a and A refer to different types of items).</p>
<p>The list of items for each rucksack is given as characters all on a single line. A given rucksack always has the same number of items in each of its two compartments, so the first half of the characters represent items in the first compartment, while the second half of the characters represent items in the second compartment.</p>
<p>For example, suppose you have the following list of contents from six rucksacks:</p>
<pre><code>vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
</code></pre>
<ul>
<li>The first rucksack contains the items <code>vJrwpWtwJgWrhcsFMMfFFhFp</code>, which means its first compartment contains the items <code>vJrwpWtwJgWr</code>, while the second compartment contains the items <code>hcsFMMfFFhFp</code>. The only item type that appears in both compartments is lowercase <strong>p</strong>.</li>
<li>The second rucksack's compartments contain <code>jqHRNqRjqzjGDLGL</code> and <code>rsFMfFZSrLrFZsSL</code>. The only item type that appears in both compartments is uppercase <strong>L</strong>.</li>
<li>The third rucksack's compartments contain <code>PmmdzqPrV</code> and <code>vPwwTWBwg</code>. The only item type that appears in both compartments is uppercase <strong>P</strong>.</li>
<li>The fourth rucksack's compartments only share item type <strong>v</strong>.</li>
<li>The fifth rucksack's compartments only share item type <strong>t</strong>.</li>
<li>The sixth rucksack's compartments only share item type <strong>s</strong>.</li>
</ul>
<p>To help prioritize item rearrangement, every item type can be converted to a <strong>priority</strong>:</p>
<ul>
<li>Lowercase item types a through z have priorities 1 through 26.</li>
<li>Uppercase item types A through Z have priorities 27 through 52.</li>
</ul>
<p>In the above example, the priority of the item type that appears in both compartments of each rucksack is 16 (p), 38 (L), 42 (P), 22 (v), 20 (t), and 19 (s); the sum of these is <strong>157</strong>.</p>
<h2 id="part-1-2"><a class="header" href="#part-1-2">Part 1</a></h2>
<p>Find the item type that appears in both compartments of each rucksack. <strong>What is the sum of the priorities of those item types?</strong></p>
<h2 id="part-2-2"><a class="header" href="#part-2-2">Part 2</a></h2>
<p>As you finish identifying the misplaced items, the Elves come to you with another issue.</p>
<p>For safety, the Elves are divided into groups of three. Every Elf carries a badge that identifies their group. For efficiency, within each group of three Elves, the badge is the <strong>only item type carried by all three Elves</strong>. That is, if a group's badge is item type B, then all three Elves will have item type B somewhere in their rucksack, and at most two of the Elves will be carrying any other item type.</p>
<p>The problem is that someone forgot to put this year's updated authenticity sticker on the badges. All of the badges need to be pulled out of the rucksacks so the new authenticity stickers can be attached.</p>
<p>Additionally, nobody wrote down which item type corresponds to each group's badges. The only way to tell which item type is the right one is by finding the one item type that is <strong>common between all three Elves</strong> in each group.</p>
<p>Every set of three lines in your list corresponds to a single group, but each group can have a different badge item type. So, in the above example, the first group's rucksacks are the first three lines:</p>
<pre><code>vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
</code></pre>
<p>And the second group's rucksacks are the next three lines:</p>
<pre><code>wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
</code></pre>
<p>In the first group, the only item type that appears in all three rucksacks is lowercase <strong>r</strong>; this must be their badges. In the second group, their badge item type must be <strong>Z</strong>.</p>
<p>Priorities for these items must still be found to organize the sticker attachment efforts: here, they are 18 (r) for the first group and 52 (Z) for the second group. The sum of these is <strong>70</strong>.</p>
<p><strong>Find the item type that corresponds to the badges of each three-Elf group. What is the sum of the priorities of those item types?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-3-solution-explanation"><a class="header" href="#day-3-solution-explanation">Day 3: Solution Explanation</a></h1>
<h2 id="approach-2"><a class="header" href="#approach-2">Approach</a></h2>
<p>Day 3's problem involves finding common items across different sets and calculating their priorities. We need to:</p>
<ol>
<li><strong>Part 1</strong>: Find items that appear in both compartments of each rucksack</li>
<li><strong>Part 2</strong>: Find the common item (badge) among each group of three elves</li>
</ol>
<p>The key techniques we'll use are:</p>
<ul>
<li>String splitting to divide rucksacks into compartments</li>
<li>HashSets for efficiently finding common elements</li>
<li>Character mapping to calculate priorities</li>
</ul>
<h2 id="implementation-details-2"><a class="header" href="#implementation-details-2">Implementation Details</a></h2>
<h3 id="part-1-finding-common-items-in-compartments"><a class="header" href="#part-1-finding-common-items-in-compartments">Part 1: Finding Common Items in Compartments</a></h3>
<p>The approach for Part 1 is:</p>
<ol>
<li>Split each rucksack into two equal compartments</li>
<li>Find the characters that appear in both compartments</li>
<li>Calculate the priority of each common character</li>
<li>Sum the priorities</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn component_1(lines: &amp;str) -&gt; u32 {
    lines.lines()
        .map(|line| line.split_at(line.len()&gt;&gt;1))
        .map(|(compa, compb)| {
            compa.chars()
                .filter(|&amp;c| compb.find(c).is_some())
                .collect::&lt;HashSet&lt;_&gt;&gt;()
        })
        .map(|set| set.into_iter().map(calculate_priority).sum::&lt;u32&gt;())
        .reduce(|sum, v| sum + v)
        .unwrap_or_else(|| unreachable!())
}
<span class="boring">}</span></code></pre></pre>
<p>Key points about this implementation:</p>
<ul>
<li><code>line.split_at(line.len()&gt;&gt;1)</code> divides the string into two equal halves</li>
<li><code>compb.find(c).is_some()</code> checks if character <code>c</code> appears in the second compartment</li>
<li>We use a <code>HashSet</code> to ensure we count each common character only once</li>
</ul>
<h3 id="part-2-finding-common-items-across-groups"><a class="header" href="#part-2-finding-common-items-across-groups">Part 2: Finding Common Items Across Groups</a></h3>
<p>The approach for Part 2 is:</p>
<ol>
<li>Group the rucksacks into sets of three</li>
<li>For each group, find the characters that appear in all three rucksacks</li>
<li>Calculate the priority of each common character</li>
<li>Sum the priorities</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn component_2(lines:&amp;str) -&gt; u32 {
    lines.lines()
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .chunks(3)
        .map(|group| {
            group.iter()
                .map(|a| a.chars().collect::&lt;HashSet&lt;_&gt;&gt;())
                .reduce(|a, b| a.intersection(&amp;b).copied().collect::&lt;HashSet&lt;_&gt;&gt;())
                .unwrap_or_else(|| panic!("Ops!"))
        })
        .map(|set| set.into_iter().map(calculate_priority).sum::&lt;u32&gt;())
        .sum::&lt;u32&gt;()
}
<span class="boring">}</span></code></pre></pre>
<p>Key points about this implementation:</p>
<ul>
<li><code>.chunks(3)</code> splits the lines into groups of three</li>
<li>We convert each rucksack into a <code>HashSet</code> of characters</li>
<li>We use <code>reduce</code> with <code>intersection</code> to find characters common to all three rucksacks</li>
</ul>
<h3 id="priority-calculation"><a class="header" href="#priority-calculation">Priority Calculation</a></h3>
<p>Both parts use the same logic to calculate priorities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_priority(c: char) -&gt; u32 {
    match c {
        'a'..='z' =&gt; u32::from(c) - u32::from('a') + 1,   // 1-26
        'A'..='Z' =&gt; u32::from(c) - u32::from('A') + 27,  // 27-52
        _ =&gt; panic!("use only alphabetic characters")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This function:</p>
<ul>
<li>Maps lowercase letters (a-z) to priorities 1-26</li>
<li>Maps uppercase letters (A-Z) to priorities 27-52</li>
</ul>
<h2 id="optimization-and-efficiency"><a class="header" href="#optimization-and-efficiency">Optimization and Efficiency</a></h2>
<h3 id="time-complexity"><a class="header" href="#time-complexity">Time Complexity</a></h3>
<ul>
<li><strong>Part 1</strong>: O(n) where n is the total number of characters across all rucksacks</li>
<li><strong>Part 2</strong>: O(n) where n is the total number of characters across all rucksacks</li>
</ul>
<p>The solution makes use of HashSets for efficient intersection operations.</p>
<h3 id="space-complexity"><a class="header" href="#space-complexity">Space Complexity</a></h3>
<ul>
<li>O(m) where m is the number of unique characters in the largest compartment/rucksack</li>
</ul>
<h3 id="alternative-approaches-2"><a class="header" href="#alternative-approaches-2">Alternative Approaches</a></h3>
<h4 id="bitsets-for-character-tracking"><a class="header" href="#bitsets-for-character-tracking">Bitsets for Character Tracking</a></h4>
<p>An alternative approach could use bitsets to track character presence:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn using_bitsets(lines: &amp;str) -&gt; u32 {
    lines.lines()
        .map(|line| {
            let half_len = line.len() / 2;
            let first_half = &amp;line[0..half_len];
            let second_half = &amp;line[half_len..];
            
            let mut first_set = 0u64;
            let mut second_set = 0u64;
            
            for c in first_half.chars() {
                let bit = if c.is_lowercase() {
                    1u64 &lt;&lt; (c as u8 - b'a')
                } else {
                    1u64 &lt;&lt; (c as u8 - b'A' + 26)
                };
                first_set |= bit;
            }
            
            for c in second_half.chars() {
                let bit = if c.is_lowercase() {
                    1u64 &lt;&lt; (c as u8 - b'a')
                } else {
                    1u64 &lt;&lt; (c as u8 - b'A' + 26)
                };
                second_set |= bit;
            }
            
            let common = first_set &amp; second_set;
            common.trailing_zeros() + 1
        })
        .sum()
}
<span class="boring">}</span></code></pre></pre>
<p>This approach would be more memory-efficient but slightly more complex to implement.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>The solution uses Rust's powerful iterators and collection types to create a clean, functional implementation. The use of HashSets makes finding common elements efficient, while the string manipulation functions allow for straightforward parsing of the input.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-3-code"><a class="header" href="#day-3-code">Day 3: Code</a></h1>
<p>Below is the complete code for Day 3, which solves the Rucksack Reorganization problem.</p>
<h2 id="full-solution-2"><a class="header" href="#full-solution-2">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">use std::collections::HashSet;

fn main() {
    // let lines = "vJrwpWtwJgWrhcsFMMfFFhFp\n\
    // jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL\n\
    // PmmdzqPrVvPwwTWBwg\n\
    // wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn\n\
    // ttgJtRGJQctTZtZT\n\
    // CrZsJsPPZsGzwwsLwLmpwMDw";

    let lines = std::fs::read_to_string("./src/bin/day3.txt").unwrap_or_else(|e| panic!("{e}"));

    println!("{:?}",component_1(&amp;lines));
    println!("{:?}",component_2(&amp;lines));
}

fn component_2(lines:&amp;str) -&gt; u32 {
    lines.lines()
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .chunks(3)
        .map(|group| {
            group.iter()
                .map(|a| a.chars().collect::&lt;HashSet&lt;_&gt;&gt;())
                .reduce(|a, b|
                    a.intersection(&amp;b).copied().collect::&lt;HashSet&lt;_&gt;&gt;()
                )
                .unwrap_or_else(|| panic!("Ops!"))
        })
        .map(|set|
            set.into_iter()
                .map(|c|
                    match c {
                        'a'..='z' =&gt; u32::from(c) - u32::from('a') + 1,
                        'A'..='Z' =&gt; u32::from(c) - u32::from('A') + 27,
                        _ =&gt; panic!("use only alphabetic characters")
                    }
                )
                .sum::&lt;u32&gt;()
        )
        .sum::&lt;u32&gt;()
}

fn component_1(lines: &amp;str) -&gt; u32 {
    lines.lines()
        .map(|line| line.split_at( line.len()&gt;&gt;1 ) )
        .map(|(compa, compb)| {
            compa.chars()
                .filter(|&amp;c| compb.find(c).is_some() )
                .collect::&lt;HashSet&lt;_&gt;&gt;()
        })
        .map(|set|
            set.into_iter()
                .map(|c|
                    match c {
                        'a'..='z' =&gt; u32::from(c) - u32::from('a') + 1,
                        'A'..='Z' =&gt; u32::from(c) - u32::from('A') + 27,
                        _ =&gt; panic!("use only alphabetic characters")
                    }
                )
                .sum::&lt;u32&gt;()
        )
        .reduce(|sum, v| sum + v )
        .unwrap_or_else(|| unreachable!())
}</code></pre>
<h2 id="code-walkthrough-2"><a class="header" href="#code-walkthrough-2">Code Walkthrough</a></h2>
<h3 id="imports-and-setup"><a class="header" href="#imports-and-setup">Imports and Setup</a></h3>
<pre><code class="language-rust no_run noplayground">use std::collections::HashSet;

fn main() {
    // let lines = "vJrwpWtwJgWrhcsFMMfFFhFp\n\
    // jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL\n\
    // PmmdzqPrVvPwwTWBwg\n\
    // wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn\n\
    // ttgJtRGJQctTZtZT\n\
    // CrZsJsPPZsGzwwsLwLmpwMDw";

    let lines = std::fs::read_to_string("./src/bin/day3.txt").unwrap_or_else(|e| panic!("{e}"));

    println!("{:?}",component_1(&amp;lines));
    println!("{:?}",component_2(&amp;lines));
}</code></pre>
<p>The solution imports the <code>HashSet</code> collection type which is used to efficiently find common elements. The main function reads the input file and calls the two component functions that solve parts 1 and 2 of the problem.</p>
<h3 id="part-1-finding-common-items-between-compartments"><a class="header" href="#part-1-finding-common-items-between-compartments">Part 1: Finding Common Items Between Compartments</a></h3>
<pre><code class="language-rust no_run noplayground">fn component_1(lines: &amp;str) -&gt; u32 {
    lines.lines()
        .map(|line| line.split_at( line.len()&gt;&gt;1 ) )
        .map(|(compa, compb)| {
            compa.chars()
                .filter(|&amp;c| compb.find(c).is_some() )
                .collect::&lt;HashSet&lt;_&gt;&gt;()
        })
        .map(|set|
            set.into_iter()
                .map(|c|
                    match c {
                        'a'..='z' =&gt; u32::from(c) - u32::from('a') + 1,
                        'A'..='Z' =&gt; u32::from(c) - u32::from('A') + 27,
                        _ =&gt; panic!("use only alphabetic characters")
                    }
                )
                .sum::&lt;u32&gt;()
        )
        .reduce(|sum, v| sum + v )
        .unwrap_or_else(|| unreachable!())
}</code></pre>
<p>This function handles Part 1 of the problem, finding items that appear in both compartments of each rucksack.</p>
<p>The solution works by:</p>
<ol>
<li>Splitting each rucksack into two halves using <code>split_at</code></li>
<li>Finding characters that appear in both halves using <code>filter</code></li>
<li>Using a <code>HashSet</code> to ensure each common character is counted only once</li>
<li>Calculating the priority of each common character</li>
<li>Summing all priorities</li>
</ol>
<h3 id="part-2-finding-group-badges"><a class="header" href="#part-2-finding-group-badges">Part 2: Finding Group Badges</a></h3>
<pre><code class="language-rust no_run noplayground">fn component_2(lines:&amp;str) -&gt; u32 {
    lines.lines()
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .chunks(3)
        .map(|group| {
            group.iter()
                .map(|a| a.chars().collect::&lt;HashSet&lt;_&gt;&gt;())
                .reduce(|a, b|
                    a.intersection(&amp;b).copied().collect::&lt;HashSet&lt;_&gt;&gt;()
                )
                .unwrap_or_else(|| panic!("Ops!"))
        })
        .map(|set|
            set.into_iter()
                .map(|c|
                    match c {
                        'a'..='z' =&gt; u32::from(c) - u32::from('a') + 1,
                        'A'..='Z' =&gt; u32::from(c) - u32::from('A') + 27,
                        _ =&gt; panic!("use only alphabetic characters")
                    }
                )
                .sum::&lt;u32&gt;()
        )
        .sum::&lt;u32&gt;()
}</code></pre>
<p>This function handles Part 2 of the problem, finding the common item (badge) among each group of three elves.</p>
<p>The solution works by:</p>
<ol>
<li>Grouping rucksacks into sets of three using <code>chunks(3)</code></li>
<li>For each group, converting each rucksack into a <code>HashSet</code> of characters</li>
<li>Using <code>reduce</code> with <code>intersection</code> to find characters common to all three rucksacks</li>
<li>Calculating the priority of the common character</li>
<li>Summing all priorities</li>
</ol>
<h2 id="implementation-notes-1"><a class="header" href="#implementation-notes-1">Implementation Notes</a></h2>
<ul>
<li><strong>Bit Shift Operation</strong>: <code>line.len()&gt;&gt;1</code> is a bit shift operation that divides the length by 2, efficiently splitting the rucksack into equal compartments.</li>
<li><strong>HashSet Usage</strong>: The use of HashSets eliminates duplicate characters in the results, ensuring each common character is counted exactly once.</li>
<li><strong>Character Priority Calculation</strong>: The solution uses character code arithmetic to calculate priorities, mapping 'a'-'z' to 1-26 and 'A'-'Z' to 27-52.</li>
<li><strong>Functional Programming Style</strong>: The implementation uses a functional programming style with method chaining, which makes the code concise and expressive.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-4-camp-cleanup"><a class="header" href="#day-4-camp-cleanup">Day 4: Camp Cleanup</a></h1>
<p>Day 4 involves checking for overlapping section assignments among pairs of elves cleaning the camp.</p>
<h2 id="problem-overview-3"><a class="header" href="#problem-overview-3">Problem Overview</a></h2>
<p>The elves have been assigned to clean different sections of the camp. Each elf has a range of section IDs they're responsible for. Your task is to:</p>
<ol>
<li>Count how many assignment pairs have one range fully containing the other</li>
<li>Count how many assignment pairs have ranges that overlap at all</li>
</ol>
<p>This problem tests your ability to work with ranges and determine subset and intersection relationships.</p>
<h2 id="navigation-3"><a class="header" href="#navigation-3">Navigation</a></h2>
<ul>
<li><a href="day4/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day4/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day4/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-4-problem-description"><a class="header" href="#day-4-problem-description">Day 4: Problem Description</a></h1>
<h2 id="camp-cleanup"><a class="header" href="#camp-cleanup">Camp Cleanup</a></h2>
<p>Space needs to be cleared before the last supplies can be unloaded from the ships, and so several Elves have been assigned the job of cleaning up sections of the camp. Every section has a unique <strong>ID number</strong>, and each Elf is assigned a range of section IDs.</p>
<p>However, as some of the Elves compare their section assignments with each other, they've noticed that many of the assignments <strong>overlap</strong>. To try to quickly find overlaps and reduce duplicated effort, the Elves pair up and make a <strong>big list of the section assignments for each pair</strong> (your puzzle input).</p>
<p>For example, consider the following list of section assignment pairs:</p>
<pre><code>2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
</code></pre>
<p>For the first few pairs, this list means:</p>
<ul>
<li>Within the first pair of Elves, the first Elf was assigned sections 2-4 (sections 2, 3, and 4), while the second Elf was assigned sections 6-8 (sections 6, 7, 8).</li>
<li>The Elves in the second pair were assigned sections 2-3 and 4-5.</li>
<li>The Elves in the third pair were assigned sections 5-7 and 7-9.</li>
<li>The Elves in the fourth pair were assigned sections 2-8 and 3-7.</li>
<li>The Elves in the fifth pair were assigned sections 6-6 and 4-6.</li>
<li>The Elves in the sixth pair were assigned sections 2-6 and 4-8.</li>
</ul>
<h2 id="part-1-3"><a class="header" href="#part-1-3">Part 1</a></h2>
<p>Some of the pairs have noticed that one of their assignments <strong>fully contains</strong> the other. For example, 2-8 fully contains 3-7, and 6-6 is fully contained by 4-6. In pairs where one assignment fully contains the other, one Elf in the pair would be exclusively cleaning sections their partner will already be cleaning, so these seem like the most in need of reconsideration. In this example, there are <strong>2</strong> such pairs.</p>
<p><strong>In how many assignment pairs does one range fully contain the other?</strong></p>
<h2 id="part-2-3"><a class="header" href="#part-2-3">Part 2</a></h2>
<p>It seems like there is still quite a bit of duplicate work planned. Instead, the Elves would like to know the number of pairs that <strong>overlap at all</strong>.</p>
<p>In the above example, the first two pairs (2-4,6-8 and 2-3,4-5) don't overlap, while the remaining four pairs (5-7,7-9, 2-8,3-7, 6-6,4-6, and 2-6,4-8) do overlap:</p>
<ul>
<li>5-7,7-9 overlaps in a single section, 7.</li>
<li>2-8,3-7 overlaps all of the sections 3 through 7.</li>
<li>6-6,4-6 overlaps in a single section, 6.</li>
<li>2-6,4-8 overlaps in sections 4, 5, and 6.</li>
</ul>
<p>So, in this example, the number of overlapping assignment pairs is <strong>4</strong>.</p>
<p><strong>In how many assignment pairs do the ranges overlap?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-4-solution-explanation"><a class="header" href="#day-4-solution-explanation">Day 4: Solution Explanation</a></h1>
<h2 id="approach-3"><a class="header" href="#approach-3">Approach</a></h2>
<p>Day 4's problem involves working with ranges and determining relationships between them. We need to check:</p>
<ol>
<li><strong>Part 1</strong>: Whether one range fully contains the other (subset relationship)</li>
<li><strong>Part 2</strong>: Whether two ranges overlap at all (intersection relationship)</li>
</ol>
<p>The core of the solution is to extend Rust's <code>RangeInclusive</code> type with functionality to check for these two conditions.</p>
<h2 id="implementation-details-3"><a class="header" href="#implementation-details-3">Implementation Details</a></h2>
<h3 id="range-extension-trait"><a class="header" href="#range-extension-trait">Range Extension Trait</a></h3>
<p>The most elegant part of this solution is defining a trait to extend the functionality of Rust's built-in <code>RangeInclusive</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait InclusiveRangeExt {
    fn is_subset(&amp;self, other: &amp;Self) -&gt; bool;
    fn is_overlapping(&amp;self, other: &amp;Self) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<p>This trait adds two methods to <code>RangeInclusive</code>:</p>
<ul>
<li><code>is_subset</code> - Checks if the other range is fully contained within this range</li>
<li><code>is_overlapping</code> - Checks if this range overlaps with the other range at all</li>
</ul>
<h3 id="implementing-the-trait"><a class="header" href="#implementing-the-trait">Implementing the Trait</a></h3>
<p>The implementation uses the <code>contains</code> method that's built into <code>RangeInclusive</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; InclusiveRangeExt for RangeInclusive&lt;T&gt;
    where T : PartialOrd {
    fn is_subset(&amp;self, other: &amp;Self) -&gt; bool {
        self.contains(other.start()) &amp;&amp; self.contains(other.end())
    }
    fn is_overlapping(&amp;self, other: &amp;Self) -&gt; bool {
        self.contains(other.start()) || self.contains(other.end())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The generic implementation works for any type <code>T</code> that can be compared (<code>PartialOrd</code>), which includes the integers we're using in this problem.</p>
<h3 id="parsing-the-input-1"><a class="header" href="#parsing-the-input-1">Parsing the Input</a></h3>
<p>The input consists of pairs of ranges in the format <code>a-b,c-d</code>. We parse this into pairs of <code>RangeInclusive&lt;u32&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pairs = data.lines()
    .map(|line|
        line.split(|c:char| c.is_ascii_punctuation())
            .map(|c| u32::from_str(c).unwrap_or_else(|e| panic!("{e}")) )
            .collect::&lt;Vec&lt;_&gt;&gt;()
    )
    .map(|pair| {
        let [a, b, c, d] = pair[..] else { panic!("") };
        ((a..=b), (c..=d))
    })
    .collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<p>The parsing works by:</p>
<ol>
<li>Splitting each line by punctuation characters (hyphens and commas)</li>
<li>Converting each part to a <code>u32</code></li>
<li>Creating a pair of ranges using the inclusive range syntax <code>a..=b</code></li>
</ol>
<h3 id="solving-part-1-full-containment"><a class="header" href="#solving-part-1-full-containment">Solving Part 1: Full Containment</a></h3>
<p>With our ranges parsed and the extension trait implemented, solving Part 1 is straightforward:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let out = pairs.iter()
    .filter(|(a,b)|
        a.is_subset(b) || b.is_subset(a)
    )
    .count();
<span class="boring">}</span></code></pre></pre>
<p>We check each pair to see if either range is a subset of the other, and count the number of pairs that satisfy this condition.</p>
<h3 id="solving-part-2-overlapping"><a class="header" href="#solving-part-2-overlapping">Solving Part 2: Overlapping</a></h3>
<p>Similarly, for Part 2, we count pairs where ranges overlap at all:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let out = pairs.iter()
    .filter(|(a,b)|
        a.is_overlapping(b) || b.is_overlapping(a)
    )
    .count();
<span class="boring">}</span></code></pre></pre>
<h2 id="alternative-solutions"><a class="header" href="#alternative-solutions">Alternative Solutions</a></h2>
<h3 id="direct-range-comparison"><a class="header" href="#direct-range-comparison">Direct Range Comparison</a></h3>
<p>Instead of using a trait extension, we could have compared range endpoints directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if range a fully contains range b
fn is_subset(a: &amp;(u32, u32), b: &amp;(u32, u32)) -&gt; bool {
    a.0 &lt;= b.0 &amp;&amp; a.1 &gt;= b.1
}

// Check if ranges a and b overlap
fn is_overlapping(a: &amp;(u32, u32), b: &amp;(u32, u32)) -&gt; bool {
    a.0 &lt;= b.1 &amp;&amp; a.1 &gt;= b.0
}
<span class="boring">}</span></code></pre></pre>
<p>This approach would use tuples instead of ranges, which is simpler but less expressive.</p>
<h3 id="using-set-operations"><a class="header" href="#using-set-operations">Using Set Operations</a></h3>
<p>Another approach could model ranges as sets and use set operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

fn range_to_set(start: u32, end: u32) -&gt; HashSet&lt;u32&gt; {
    (start..=end).collect()
}

fn is_subset(a: &amp;HashSet&lt;u32&gt;, b: &amp;HashSet&lt;u32&gt;) -&gt; bool {
    a.is_subset(b) || b.is_subset(a)
}

fn is_overlapping(a: &amp;HashSet&lt;u32&gt;, b: &amp;HashSet&lt;u32&gt;) -&gt; bool {
    !a.is_disjoint(b)
}
<span class="boring">}</span></code></pre></pre>
<p>However, this would be less efficient for large ranges due to the memory required to store every integer in each range.</p>
<h2 id="time-and-space-complexity-1"><a class="header" href="#time-and-space-complexity-1">Time and Space Complexity</a></h2>
<ul>
<li><strong>Time Complexity</strong>: O(n) where n is the number of range pairs, since we process each pair once with constant-time operations.</li>
<li><strong>Space Complexity</strong>: O(n) to store the parsed pairs.</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>This solution demonstrates how Rust's trait system can be used to extend existing types with new functionality. By using trait extensions, we achieve an elegant and readable solution that clearly expresses the problem's domain concepts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-4-code"><a class="header" href="#day-4-code">Day 4: Code</a></h1>
<p>Below is the complete code for Day 4's solution, which handles range containment and overlap checks.</p>
<h2 id="full-solution-3"><a class="header" href="#full-solution-3">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">use std::ops::RangeInclusive;
use std::str::FromStr;

trait InclusiveRangeExt {
    fn is_subset(&amp;self, other: &amp;Self) -&gt; bool;
    fn is_overlapping(&amp;self, other: &amp;Self) -&gt; bool;
}

impl&lt;T&gt; InclusiveRangeExt for RangeInclusive&lt;T&gt;
    where T : PartialOrd {
    fn is_subset(&amp;self, other: &amp;Self) -&gt; bool {
        self.contains(other.start()) &amp;&amp; self.contains(other.end())
    }
    fn is_overlapping(&amp;self, other: &amp;Self) -&gt; bool {
        self.contains(other.start()) || self.contains(other.end())
    }
}

fn main() {

    let data = std::fs::read_to_string("src/bin/day4_input.txt").expect("Ops! Cannot read file");
    let pairs = data.lines()
        .map(|line|
            line.split(|c:char| c.is_ascii_punctuation())
                .map(|c| u32::from_str(c).unwrap_or_else(|e| panic!("{e}")) )
                .collect::&lt;Vec&lt;_&gt;&gt;()
        )
        .map(|pair| {
            let [a, b, c, d] = pair[..] else { panic!("") };
            ((a..=b), (c..=d))
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    let out = pairs.iter()
        .filter(|(a,b)|
            a.is_subset(b) || b.is_subset(a)
        )
        .count();
    println!("Component 1 = {out}");

    let out = pairs.iter()
        .filter(|(a,b)|
            a.is_overlapping(b) || b.is_overlapping(a)
        )
        .count();
    println!("Component 2 = {out}");
}</code></pre>
<h2 id="code-walkthrough-3"><a class="header" href="#code-walkthrough-3">Code Walkthrough</a></h2>
<h3 id="extending-ranges-with-a-trait"><a class="header" href="#extending-ranges-with-a-trait">Extending Ranges with a Trait</a></h3>
<pre><code class="language-rust no_run noplayground">trait InclusiveRangeExt {
    fn is_subset(&amp;self, other: &amp;Self) -&gt; bool;
    fn is_overlapping(&amp;self, other: &amp;Self) -&gt; bool;
}</code></pre>
<p>The solution defines a trait to extend Rust's <code>RangeInclusive</code> type with two new methods for checking containment relationships:</p>
<ul>
<li><code>is_subset</code> - Checks if one range is fully contained within another</li>
<li><code>is_overlapping</code> - Checks if two ranges overlap at all</li>
</ul>
<h3 id="implementing-the-trait-1"><a class="header" href="#implementing-the-trait-1">Implementing the Trait</a></h3>
<pre><code class="language-rust no_run noplayground">impl&lt;T&gt; InclusiveRangeExt for RangeInclusive&lt;T&gt;
    where T : PartialOrd {
    fn is_subset(&amp;self, other: &amp;Self) -&gt; bool {
        self.contains(other.start()) &amp;&amp; self.contains(other.end())
    }
    fn is_overlapping(&amp;self, other: &amp;Self) -&gt; bool {
        self.contains(other.start()) || self.contains(other.end())
    }
}</code></pre>
<p>The trait is implemented generically for any <code>RangeInclusive&lt;T&gt;</code> where <code>T</code> supports partial ordering. This allows the solution to work with ranges of any comparable type, not just integers.</p>
<h3 id="parsing-input-1"><a class="header" href="#parsing-input-1">Parsing Input</a></h3>
<pre><code class="language-rust no_run noplayground">    let data = std::fs::read_to_string("src/bin/day4_input.txt").expect("Ops! Cannot read file");
    let pairs = data.lines()
        .map(|line|
            line.split(|c:char| c.is_ascii_punctuation())
                .map(|c| u32::from_str(c).unwrap_or_else(|e| panic!("{e}")) )
                .collect::&lt;Vec&lt;_&gt;&gt;()
        )
        .map(|pair| {
            let [a, b, c, d] = pair[..] else { panic!("") };
            ((a..=b), (c..=d))
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<p>The parsing involves several steps:</p>
<ol>
<li>Read the input file as a string</li>
<li>Split each line into parts using punctuation characters (hyphens and commas)</li>
<li>Convert each part to a <code>u32</code> number</li>
<li>Group the numbers into pairs of ranges using Rust's inclusive range syntax <code>a..=b</code></li>
</ol>
<h3 id="part-1-checking-subset-relationships"><a class="header" href="#part-1-checking-subset-relationships">Part 1: Checking Subset Relationships</a></h3>
<pre><code class="language-rust no_run noplayground">    let out = pairs.iter()
        .filter(|(a,b)|
            a.is_subset(b) || b.is_subset(a)
        )
        .count();</code></pre>
<p>This part counts pairs where one range fully contains the other by applying the <code>is_subset</code> method and checking in both directions.</p>
<h3 id="part-2-checking-overlap-relationships"><a class="header" href="#part-2-checking-overlap-relationships">Part 2: Checking Overlap Relationships</a></h3>
<pre><code class="language-rust no_run noplayground">    let out = pairs.iter()
        .filter(|(a,b)|
            a.is_overlapping(b) || b.is_overlapping(a)
        )
        .count();</code></pre>
<p>This part counts pairs where the ranges overlap at all by applying the <code>is_overlapping</code> method and checking in both directions.</p>
<h2 id="implementation-notes-2"><a class="header" href="#implementation-notes-2">Implementation Notes</a></h2>
<ul>
<li><strong>Trait Extensions</strong>: This solution demonstrates Rust's powerful trait system by extending an existing type with new functionality.</li>
<li><strong>Generic Programming</strong>: The trait implementation works with any ordered type, not just the specific integers used in this problem.</li>
<li><strong>Pattern Matching</strong>: The solution uses Rust's pattern matching to destructure the parsed values into range pairs.</li>
<li><strong>Error Handling</strong>: The solution uses <code>expect</code> and <code>unwrap_or_else</code> for error handling, though a more robust solution might handle errors more gracefully.</li>
</ul>
<p>The implementation is concise and idiomatic, leveraging Rust's type system and functional programming features to solve the problem elegantly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-5-supply-stacks"><a class="header" href="#day-5-supply-stacks">Day 5: Supply Stacks</a></h1>
<p>Day 5 involves rearranging stacks of crates following a series of move instructions.</p>
<h2 id="problem-overview-4"><a class="header" href="#problem-overview-4">Problem Overview</a></h2>
<p>The elves are loading supplies onto a cargo ship, and the crates need to be rearranged. Each crate is marked with a letter, and the crates are arranged in stacks. Your task is to:</p>
<ol>
<li>Parse the initial arrangement of crates and the move instructions</li>
<li>Simulate the crate movement using two different crane models</li>
<li>Report which crates end up on top of each stack</li>
</ol>
<p>This problem tests your ability to work with stacks, parse complex input formats, and implement different movement rules.</p>
<h2 id="navigation-4"><a class="header" href="#navigation-4">Navigation</a></h2>
<ul>
<li><a href="day5/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day5/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day5/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-5-problem-description"><a class="header" href="#day-5-problem-description">Day 5: Problem Description</a></h1>
<h2 id="supply-stacks"><a class="header" href="#supply-stacks">Supply Stacks</a></h2>
<p>The expedition can depart as soon as the final supplies have been unloaded from the ships. Supplies are stored in stacks of marked <strong>crates</strong>, but because the needed supplies are buried under many other crates, the crates need to be rearranged.</p>
<p>The ship has a <strong>giant cargo crane</strong> capable of moving crates between stacks. To ensure none of the crates get crushed or fall over, the crane operator will rearrange them in a series of carefully-planned steps. After the crates are rearranged, the desired crates will be at the top of each stack.</p>
<p>The Elves don't want to interrupt the crane operator during this delicate procedure, but they forgot to ask her which crate will end up where, and they want to be ready to unload them as soon as possible so they can embark.</p>
<p>They do, however, have a drawing of the starting stacks of crates <strong>and</strong> the rearrangement procedure (your puzzle input). For example:</p>
<pre><code>    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2
</code></pre>
<p>In this example, there are three stacks of crates. Stack 1 contains two crates: crate <code>Z</code> is on the bottom, and crate <code>N</code> is on top. Stack 2 contains three crates: from bottom to top, crates <code>M</code>, <code>C</code>, and <code>D</code>. Finally, stack 3 contains a single crate, <code>P</code>.</p>
<p>Then, the rearrangement procedure is given. In each step of the procedure, a quantity of crates is moved from one stack to a different stack. In the first step of the above rearrangement procedure, one crate is moved from stack 2 to stack 1, resulting in this configuration:</p>
<pre><code>[D]        
[N] [C]    
[Z] [M] [P]
 1   2   3 
</code></pre>
<p>In the second step, three crates are moved from stack 1 to stack 3. Crates are moved <strong>one at a time</strong>, so the first crate to be moved (<code>D</code>) ends up below the second and third crates:</p>
<pre><code>        [Z]
        [N]
    [C] [D]
    [M] [P]
 1   2   3
</code></pre>
<p>Then, the third step moves two crates from stack 2 to stack 1. Again, because crates are moved <strong>one at a time</strong>, crate <code>C</code> ends up below crate <code>M</code>:</p>
<pre><code>        [Z]
        [N]
[M]     [D]
[C]     [P]
 1   2   3
</code></pre>
<p>Finally, the fourth step moves one crate from stack 1 to stack 2:</p>
<pre><code>        [Z]
        [N]
        [D]
[C] [M] [P]
 1   2   3
</code></pre>
<p>The Elves just need to know <strong>which crate will end up on top of each stack</strong>; in this example, the top crates are <code>C</code> in stack 1, <code>M</code> in stack 2, and <code>Z</code> in stack 3, so you should combine these together and give the Elves the message <strong><code>CMZ</code></strong>.</p>
<h2 id="part-1-4"><a class="header" href="#part-1-4">Part 1</a></h2>
<p><strong>After the rearrangement procedure completes, what crate ends up on top of each stack?</strong></p>
<h2 id="part-2-4"><a class="header" href="#part-2-4">Part 2</a></h2>
<p>As you watch the crane operator expertly rearrange the crates, you notice the process isn't following your prediction.</p>
<p>Some mud was covering the writing on the side of the crane, and you quickly wipe it away. The crane isn't a CrateMover 9000 - it's a <strong>CrateMover 9001</strong>.</p>
<p>The CrateMover 9001 is notable for many new and exciting features: air conditioning, leather seats, an extra cup holder, and <strong>the ability to pick up and move multiple crates at once</strong>.</p>
<p>Again considering the example above, the crates begin in the same configuration:</p>
<pre><code>    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 
</code></pre>
<p>Moving a single crate from stack 2 to stack 1 behaves the same as before:</p>
<pre><code>[D]        
[N] [C]    
[Z] [M] [P]
 1   2   3 
</code></pre>
<p>However, the action of moving three crates from stack 1 to stack 3 means that those three crates stay <strong>in the same order</strong>, resulting in this new configuration:</p>
<pre><code>        [D]
        [N]
    [C] [Z]
    [M] [P]
 1   2   3
</code></pre>
<p>Next, as both crates are moved from stack 2 to stack 1, they <strong>retain their order</strong> as well:</p>
<pre><code>        [D]
        [N]
[C]     [Z]
[M]     [P]
 1   2   3
</code></pre>
<p>Finally, a single crate is still moved from stack 1 to stack 2, but now it's crate <code>C</code> that gets moved:</p>
<pre><code>        [D]
        [N]
        [Z]
[M] [C] [P]
 1   2   3
</code></pre>
<p>In this example, the CrateMover 9001 has put the crates in a totally different order: <strong><code>MCD</code></strong>.</p>
<p><strong>Before the rearrangement process finishes, update your simulation so that the Elves know where they should stand to be ready to unload the final supplies. After the rearrangement procedure completes, what crate ends up on top of each stack?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-5-solution-explanation"><a class="header" href="#day-5-solution-explanation">Day 5: Solution Explanation</a></h1>
<h2 id="approach-4"><a class="header" href="#approach-4">Approach</a></h2>
<p>Day 5's problem involves parsing a complex input format and simulating moving crates between stacks using different rules. The solution involves three main parts:</p>
<ol>
<li><strong>Parsing the input</strong> - Extracting the initial crate configuration and move instructions</li>
<li><strong>Simulating crate movements</strong> - Implementing both the CrateMover 9000 and CrateMover 9001 rules</li>
<li><strong>Reading the result</strong> - Determining which crates end up on top of each stack</li>
</ol>
<h2 id="implementation-details-4"><a class="header" href="#implementation-details-4">Implementation Details</a></h2>
<h3 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h3>
<p>The solution uses two main structures:</p>
<ol>
<li><strong>Move</strong> - Represents a single move instruction:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug,Copy,Clone)]
struct Move {
    count: usize,   // Number of crates to move
    from: usize,    // Source stack
    to: usize,      // Destination stack
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Buckets</strong> - Represents the stacks of crates:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Buckets {
    buckets: HashMap&lt;usize,Vec&lt;char&gt;&gt;,  // Stacks of crates
    keys: Vec&lt;usize&gt;                     // Ordered list of stack IDs
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Buckets</code> structure uses a <code>HashMap</code> to store each stack, with vectors representing the crates in each stack (with the top crate at the end of the vector). It also maintains an ordered list of keys to ensure consistent access to stacks.</p>
<h3 id="parsing-the-input-2"><a class="header" href="#parsing-the-input-2">Parsing the Input</a></h3>
<p>The input consists of two parts: the initial crate configuration and the move instructions.</p>
<h4 id="parsing-the-initial-configuration"><a class="header" href="#parsing-the-initial-configuration">Parsing the Initial Configuration</a></h4>
<p>The initial crate configuration is parsed by starting from the bottom of the diagram and working upward:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(start: &amp;str) -&gt; Buckets {
    let buckets = start.lines()
        .rev()                            // Start from the bottom of the diagram
        .map(|line| line.split("").filter_map(|e| e.chars().next()).collect::&lt;Vec&lt;_&gt;&gt;())
        .fold(HashMap::new(), |map, e| {
            e.into_iter()
                .enumerate()
                .filter(|(_, c)| c.is_alphanumeric())   // Keep only letters and numbers
                .fold(map, |mut out, (key, val)| {
                    out.entry(key)
                        .or_insert(Vec::default())
                        .push(val);                      // Add each crate to its stack
                    out
                })
        });
    let mut keys = buckets.keys().copied().collect::&lt;Vec&lt;_&gt;&gt;();
    keys.sort();                          // Sort keys for consistent access
    Buckets {
        buckets,
        keys
    }
}
<span class="boring">}</span></code></pre></pre>
<p>By reading the input in reverse order, we can build each stack from bottom to top.</p>
<h4 id="parsing-the-move-instructions"><a class="header" href="#parsing-the-move-instructions">Parsing the Move Instructions</a></h4>
<p>The move instructions are parsed using the <code>FromStr</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FromStr for Move {
    type Err = ParseIntError;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        if let [_,count,_,from,_,to] = s.split(' ').collect::&lt;Vec&lt;_&gt;&gt;()[..] {
            Ok(
                Move {
                    count: usize::from_str(count)?,
                    from: usize::from_str(from)?,
                    to: usize::from_str(to)?,
                }
            )
        } else {
            unreachable!()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This parses strings like "move 1 from 2 to 1" into a <code>Move</code> structure with <code>count=1</code>, <code>from=2</code>, and <code>to=1</code>.</p>
<h3 id="simulating-crate-movements"><a class="header" href="#simulating-crate-movements">Simulating Crate Movements</a></h3>
<p>The solution implements two different crate-moving strategies:</p>
<h4 id="cratemover-9000-moving-one-crate-at-a-time"><a class="header" href="#cratemover-9000-moving-one-crate-at-a-time">CrateMover 9000: Moving One Crate at a Time</a></h4>
<p>For the CrateMover 9000, crates are moved one at a time, so they end up in reverse order:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn crate_mover9000(&amp;mut self, m: Move) {
    let (from, to) = self.get_keys(m);
    (0..m.count)
        .for_each(|_|{
            if let Some(c) = self.buckets.get_mut(&amp;from).expect("").pop() {
                self.buckets.get_mut(&amp;to).expect("").push(c)
            }
    });
}
<span class="boring">}</span></code></pre></pre>
<p>This simply pops a crate from the source stack and pushes it onto the destination stack, repeating for the specified number of crates.</p>
<h4 id="cratemover-9001-moving-multiple-crates-at-once"><a class="header" href="#cratemover-9001-moving-multiple-crates-at-once">CrateMover 9001: Moving Multiple Crates at Once</a></h4>
<p>For the CrateMover 9001, multiple crates are moved at once, preserving their order:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn crate_mover9001(&amp;mut self, m: Move) {
    let (from, to) = self.get_keys(m);
    let v = (0..m.count)
        .fold(vec![],|mut out,_|{
            if let Some(c) = self.buckets.get_mut(&amp;from).expect("").pop() { out.push(c) }
            out
        });
    self.buckets.get_mut(&amp;to).expect("").extend(v.iter().rev());
}
<span class="boring">}</span></code></pre></pre>
<p>This code:</p>
<ol>
<li>Removes the specified number of crates from the source stack</li>
<li>Collects them in a temporary vector (in reverse order)</li>
<li>Extends the destination stack with the temporary vector (reversed again)</li>
</ol>
<p>By applying a double reversal, the original order of the crates is preserved.</p>
<h3 id="reading-the-result"><a class="header" href="#reading-the-result">Reading the Result</a></h3>
<p>After all moves are applied, we need to read the top crate from each stack:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scoop_top(&amp;self) -&gt; String {
    self.keys.iter()
        .filter_map(|key| self.buckets.get(key))   // Get each stack
        .filter_map(|arr| arr.last().copied() )    // Get the top crate
        .fold(String::new(),|mut out,s| { out.push(s); out })  // Combine into a string
}
<span class="boring">}</span></code></pre></pre>
<p>This iterates through all stacks in order, gets the top crate from each, and concatenates them into a string.</p>
<h2 id="challenge-insights"><a class="header" href="#challenge-insights">Challenge Insights</a></h2>
<h3 id="input-parsing-complexity"><a class="header" href="#input-parsing-complexity">Input Parsing Complexity</a></h3>
<p>The most challenging part of this problem is parsing the initial crate configuration, which is a visual representation of stacks rather than a straightforward data format. The solution handles this by:</p>
<ol>
<li>Reading the diagram from bottom to top</li>
<li>Converting each line into a sequence of characters</li>
<li>Filtering out non-alphanumeric characters</li>
<li>Building up stacks based on the position of each character</li>
</ol>
<h3 id="mapping-between-visual-and-logical-indexes"><a class="header" href="#mapping-between-visual-and-logical-indexes">Mapping Between Visual and Logical Indexes</a></h3>
<p>The input uses 1-based indexing for stacks, but our internal representation uses 0-based indexing. The <code>get_keys</code> method handles this conversion:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_keys(&amp;self, m:Move) -&gt; (usize,usize) {
    (self.keys[m.from-1],self.keys[m.to-1])
}
<span class="boring">}</span></code></pre></pre>
<h3 id="different-movement-rules"><a class="header" href="#different-movement-rules">Different Movement Rules</a></h3>
<p>Implementing two different movement rules shows how small changes in requirements can lead to significantly different behavior. The CrateMover 9000 causes a reversal of crate order, while the CrateMover 9001 preserves it.</p>
<h2 id="alternative-approaches-3"><a class="header" href="#alternative-approaches-3">Alternative Approaches</a></h2>
<h3 id="direct-vector-manipulation"><a class="header" href="#direct-vector-manipulation">Direct Vector Manipulation</a></h3>
<p>Instead of using a HashMap, we could use a Vec&lt;Vec<char>&gt; to represent the stacks directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Buckets {
    stacks: Vec&lt;Vec&lt;char&gt;&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>This would simplify some of the code but would make parsing the initial configuration more complex.</p>
<h3 id="using-a-stack-data-structure"><a class="header" href="#using-a-stack-data-structure">Using a Stack Data Structure</a></h3>
<p>We could use an explicit stack data structure for each pile of crates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::VecDeque;

struct Buckets {
    stacks: Vec&lt;VecDeque&lt;char&gt;&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>However, Rust's <code>Vec</code> already provides all the necessary stack operations (<code>push</code> and <code>pop</code>), so there's no need for a separate data structure.</p>
<h2 id="time-and-space-complexity-2"><a class="header" href="#time-and-space-complexity-2">Time and Space Complexity</a></h2>
<ul>
<li><strong>Time Complexity</strong>: O(n * m), where n is the number of move instructions and m is the maximum number of crates moved in a single instruction.</li>
<li><strong>Space Complexity</strong>: O(c), where c is the total number of crates.</li>
</ul>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>This solution demonstrates how to parse complex, visually-oriented input and simulate two different sets of rules using appropriate data structures. The use of Rust's traits (like <code>FromStr</code>) and collections (like <code>HashMap</code> and <code>Vec</code>) makes the implementation clean and efficient.</p>
<div style="break-before: page; page-break-before: always;"></div><p>{{REWRITTEN_CODE}}</p>
<h1 id="day-5-code"><a class="header" href="#day-5-code">Day 5: Code</a></h1>
<p>Below is the complete code for Day 5's solution, which handles rearranging stacks of crates.</p>
<h2 id="full-solution-4"><a class="header" href="#full-solution-4">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">use std::collections::HashMap;
use std::num::ParseIntError;
use std::str::FromStr;

#[derive(Debug,Copy,Clone)]
struct Move {
    count: usize,
    from: usize,
    to: usize
}
impl FromStr for Move {
    type Err = ParseIntError;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        if let [_,count,_,from,_,to] = s.split(' ').collect::&lt;Vec&lt;_&gt;&gt;()[..] {
            Ok(
                Move {
                    count: usize::from_str(count)?,
                    from: usize::from_str(from)?,
                    to: usize::from_str(to)?,
                }
            )
        } else {
            unreachable!()
        }
    }
}
impl Move {
    fn parse_moves(moves:&amp;str) -&gt; Vec&lt;Move&gt; {
        moves.lines()
            .map(|line| Move::from_str(line).unwrap_or_else(|e| panic!("{e}")) )
            .collect()
    }
}
#[derive(Debug)]
struct Buckets {
    buckets: HashMap&lt;usize,Vec&lt;char&gt;&gt;,
    keys: Vec&lt;usize&gt;
}
impl Buckets {
    fn new(start: &amp;str) -&gt; Buckets {
        let buckets = start.lines()
            .rev()
            .map(|line| line.split("").filter_map(|e| e.chars().next()).collect::&lt;Vec&lt;_&gt;&gt;())
            .fold(HashMap::new(), |map, e| {
                e.into_iter()
                    .enumerate()
                    .filter(|(_, c)| c.is_alphanumeric())
                    .fold(map, |mut out, (key, val)| {
                        out.entry(key)
                            .or_insert(Vec::default())
                            .push(val);
                        out
                    })
            });
        let mut keys = buckets.keys().copied().collect::&lt;Vec&lt;_&gt;&gt;();
        keys.sort();
        Buckets {
            buckets,
            keys
        }
    }
    fn crate_mover9000(&amp;mut self, m: Move) {
        let (from, to) = self.get_keys(m);
        (0..m.count)
            .for_each(|_|{
                if let Some(c) = self.buckets.get_mut(&amp;from).expect("").pop() {
                    self.buckets.get_mut(&amp;to).expect("").push(c)
                }
        });
    }
    fn crate_mover9001(&amp;mut self, m: Move) {
        let (from, to) = self.get_keys(m);
        let v = (0..m.count)
            .fold(vec![],|mut out,_|{
                if let Some(c) = self.buckets.get_mut(&amp;from).expect("").pop() { out.push(c) }
                out
            });
        self.buckets.get_mut(&amp;to).expect("").extend(v.iter().rev());
    }
    fn scoop_top(&amp;self) -&gt; String {
        self.keys.iter()
            .filter_map(|key| self.buckets.get(key))
            .filter_map(|arr| arr.last().copied() )
            .fold(String::new(),|mut out,s| { out.push(s); out })
    }
    fn get_keys(&amp;self, m:Move) -&gt; (usize,usize) {
        (self.keys[m.from-1],self.keys[m.to-1])
    }
}

fn main() {

    let data = std::fs::read_to_string("src/bin/day5_input.txt").expect("Ops!");

    let [start,moves] = data.split("\n\n").collect::&lt;Vec&lt;_&gt;&gt;()[..] else { panic!("") };

    let mut buckets = Buckets::new(start);
    let moves = Move::parse_moves(moves);

    moves.iter().for_each(|&amp;m| buckets.crate_mover9000(m) );
    println!("{:?}",buckets.scoop_top());

    moves.iter().for_each(|&amp;m| buckets.crate_mover9001(m) );
    println!("{:?}",buckets.scoop_top());

}</code></pre>
<h2 id="code-walkthrough-4"><a class="header" href="#code-walkthrough-4">Code Walkthrough</a></h2>
<h3 id="data-structures-1"><a class="header" href="#data-structures-1">Data Structures</a></h3>
<p>The solution uses two main structures:</p>
<ol>
<li><strong>Move</strong> - Represents a single move instruction:</li>
</ol>
<pre><code class="language-rust no_run noplayground">#[derive(Debug,Copy,Clone)]
struct Move {
    count: usize,
    from: usize,
    to: usize
}</code></pre>
<ol start="2">
<li><strong>Buckets</strong> - Represents the stacks of crates:</li>
</ol>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
struct Buckets {
    buckets: HashMap&lt;usize,Vec&lt;char&gt;&gt;,
    keys: Vec&lt;usize&gt;
}</code></pre>
<h3 id="parsing"><a class="header" href="#parsing">Parsing</a></h3>
<h4 id="parsing-move-instructions"><a class="header" href="#parsing-move-instructions">Parsing Move Instructions</a></h4>
<p>The <code>FromStr</code> trait implementation for <code>Move</code> allows parsing strings like "move 1 from 2 to 1":</p>
<pre><code class="language-rust no_run noplayground">impl FromStr for Move {
    type Err = ParseIntError;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        if let [_,count,_,from,_,to] = s.split(' ').collect::&lt;Vec&lt;_&gt;&gt;()[..] {
            Ok(
                Move {
                    count: usize::from_str(count)?,
                    from: usize::from_str(from)?,
                    to: usize::from_str(to)?,
                }
            )
        } else {
            unreachable!()
        }
    }
}</code></pre>
<p>The helper method <code>parse_moves</code> processes multiple move instructions:</p>
<pre><code class="language-rust no_run noplayground">impl Move {
    fn parse_moves(moves:&amp;str) -&gt; Vec&lt;Move&gt; {
        moves.lines()
            .map(|line| Move::from_str(line).unwrap_or_else(|e| panic!("{e}")) )
            .collect()
    }</code></pre>
<h4 id="parsing-initial-crate-configuration"><a class="header" href="#parsing-initial-crate-configuration">Parsing Initial Crate Configuration</a></h4>
<p>The <code>new</code> method of <code>Buckets</code> parses the initial crate configuration:</p>
<pre><code class="language-rust no_run noplayground">    fn new(start: &amp;str) -&gt; Buckets {
        let buckets = start.lines()
            .rev()
            .map(|line| line.split("").filter_map(|e| e.chars().next()).collect::&lt;Vec&lt;_&gt;&gt;())
            .fold(HashMap::new(), |map, e| {
                e.into_iter()
                    .enumerate()
                    .filter(|(_, c)| c.is_alphanumeric())
                    .fold(map, |mut out, (key, val)| {
                        out.entry(key)
                            .or_insert(Vec::default())
                            .push(val);
                        out
                    })
            });
        let mut keys = buckets.keys().copied().collect::&lt;Vec&lt;_&gt;&gt;();
        keys.sort();
        Buckets {
            buckets,
            keys
        }
    }</code></pre>
<p>This method works by:</p>
<ol>
<li>Reading the input in reverse order (bottom to top)</li>
<li>Splitting each line into characters</li>
<li>Filtering out non-alphanumeric characters (keeping only crate letters)</li>
<li>Building each stack based on character positions</li>
</ol>
<h3 id="crane-operations"><a class="header" href="#crane-operations">Crane Operations</a></h3>
<h4 id="cratemover-9000-moving-one-at-a-time"><a class="header" href="#cratemover-9000-moving-one-at-a-time">CrateMover 9000: Moving One at a Time</a></h4>
<pre><code class="language-rust no_run noplayground">    fn crate_mover9000(&amp;mut self, m: Move) {
        let (from, to) = self.get_keys(m);
        (0..m.count)
            .for_each(|_|{
                if let Some(c) = self.buckets.get_mut(&amp;from).expect("").pop() {
                    self.buckets.get_mut(&amp;to).expect("").push(c)
                }
        });
    }</code></pre>
<p>This method moves crates one at a time, popping from the source stack and pushing to the destination.</p>
<h4 id="cratemover-9001-moving-multiple-at-once"><a class="header" href="#cratemover-9001-moving-multiple-at-once">CrateMover 9001: Moving Multiple at Once</a></h4>
<pre><code class="language-rust no_run noplayground">    fn crate_mover9001(&amp;mut self, m: Move) {
        let (from, to) = self.get_keys(m);
        let v = (0..m.count)
            .fold(vec![],|mut out,_|{
                if let Some(c) = self.buckets.get_mut(&amp;from).expect("").pop() { out.push(c) }
                out
            });
        self.buckets.get_mut(&amp;to).expect("").extend(v.iter().rev());
    }</code></pre>
<p>This method moves multiple crates at once, preserving their order through a double-reversal process.</p>
<h3 id="getting-the-final-result"><a class="header" href="#getting-the-final-result">Getting the Final Result</a></h3>
<pre><code class="language-rust no_run noplayground">    fn scoop_top(&amp;self) -&gt; String {
        self.keys.iter()
            .filter_map(|key| self.buckets.get(key))
            .filter_map(|arr| arr.last().copied() )
            .fold(String::new(),|mut out,s| { out.push(s); out })
    }</code></pre>
<p>This method retrieves the top crate from each stack and combines them into a string.</p>
<h3 id="main-function"><a class="header" href="#main-function">Main Function</a></h3>
<pre><code class="language-rust no_run noplayground">fn main() {

    let data = std::fs::read_to_string("src/bin/day5_input.txt").expect("Ops!");

    let [start,moves] = data.split("\n\n").collect::&lt;Vec&lt;_&gt;&gt;()[..] else { panic!("") };

    let mut buckets = Buckets::new(start);
    let moves = Move::parse_moves(moves);

    moves.iter().for_each(|&amp;m| buckets.crate_mover9000(m) );
    println!("{:?}",buckets.scoop_top());

    moves.iter().for_each(|&amp;m| buckets.crate_mover9001(m) );
    println!("{:?}",buckets.scoop_top());

}</code></pre>
<p>The main function:</p>
<ol>
<li>Reads the input file</li>
<li>Splits it into the initial configuration and move instructions</li>
<li>Creates the stacks and parses the moves</li>
<li>Applies the CrateMover 9000 rules and prints the result (Part 1)</li>
<li>Applies the CrateMover 9001 rules and prints the result (Part 2)</li>
</ol>
<h2 id="implementation-notes-3"><a class="header" href="#implementation-notes-3">Implementation Notes</a></h2>
<ul>
<li><strong>Functional Programming Style</strong>: The solution makes extensive use of iterators and functional programming patterns.</li>
<li><strong>Key Transformation</strong>: The <code>get_keys</code> method handles the conversion between 1-based indexing (in the input) and 0-based indexing (in the code).</li>
<li><strong>Parsing Approach</strong>: The solution parses the visual representation of the crates by reading from the bottom up and using character positions.</li>
<li><strong>Double Reversal</strong>: The CrateMover 9001 uses a double reversal technique to preserve the order of crates when moving multiple at once.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-6-tuning-trouble"><a class="header" href="#day-6-tuning-trouble">Day 6: Tuning Trouble</a></h1>
<p>Day 6 involves analyzing a datastream to find marker patterns of unique characters.</p>
<h2 id="problem-overview-5"><a class="header" href="#problem-overview-5">Problem Overview</a></h2>
<p>You're trying to tune a communication device, which requires finding markers in the datastream. A marker is a sequence of characters where all characters are different. Your task is to:</p>
<ol>
<li>Find the position where the first start-of-packet marker (4 unique characters) appears</li>
<li>Find the position where the first start-of-message marker (14 unique characters) appears</li>
</ol>
<p>This problem tests your ability to search for patterns in a stream of data and identify unique sequences of characters.</p>
<h2 id="navigation-5"><a class="header" href="#navigation-5">Navigation</a></h2>
<ul>
<li><a href="day6/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day6/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day6/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-6-problem-description"><a class="header" href="#day-6-problem-description">Day 6: Problem Description</a></h1>
<h2 id="tuning-trouble"><a class="header" href="#tuning-trouble">Tuning Trouble</a></h2>
<p>The preparations are finally complete; you and the Elves leave camp on foot and begin to make your way toward the <strong>star</strong> fruit grove.</p>
<p>As you move through the dense undergrowth, one of the Elves gives you a handheld <strong>device</strong>. He says that it has many fancy features, but the most important one to set up right now is the <strong>communication system</strong>.</p>
<p>However, because he's heard you have significant <strong>experience dealing with signal-based systems</strong>, he convinced the other Elves that it would be okay to give you their one malfunctioning device - surely you'll have no problem fixing it.</p>
<p>As if inspired by comedic timing, the device emits a few colorful sparks.</p>
<p>To be able to communicate with the Elves, the device needs to <strong>lock on to their signal</strong>. The signal is a series of seemingly-random characters that the device receives one at a time.</p>
<p>To fix the communication system, you need to add a subroutine to the device that detects a <strong>start-of-packet marker</strong> in the datastream. In the protocol being used by the Elves, the start of a packet is indicated by a sequence of <strong>four characters that are all different</strong>.</p>
<p>The device will send your subroutine a datastream buffer (your puzzle input); your subroutine needs to identify the first position where the four most recently received characters were all different. Specifically, it needs to report the number of characters from the beginning of the buffer to the end of the first such four-character marker.</p>
<p>For example, suppose you receive the following datastream buffer:</p>
<pre><code>mjqjpqmgbljsphdztnvjfqwrcgsmlb
</code></pre>
<p>After the first three characters (<code>mjq</code>) have been received, there haven't been enough characters received yet to find the marker. The first time a marker could occur is after the fourth character is received, making the most recent four characters <code>mjqj</code>. Because <code>j</code> is repeated, this isn't a marker.</p>
<p>The first time a marker appears is after the <strong>seventh</strong> character arrives. Once it does, the last four characters received are <code>jpqm</code>, which are all different. In this case, your subroutine should report the value <code>7</code>, because the first start-of-packet marker is complete after 7 characters have been processed.</p>
<p>Here are a few more examples:</p>
<ul>
<li><code>bvwbjplbgvbhsrlpgdmjqwftvncz</code>: first marker after character <code>5</code></li>
<li><code>nppdvjthqldpwncqszvftbrmjlhg</code>: first marker after character <code>6</code></li>
<li><code>nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg</code>: first marker after character <code>10</code></li>
<li><code>zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw</code>: first marker after character <code>11</code></li>
</ul>
<h2 id="part-1-5"><a class="header" href="#part-1-5">Part 1</a></h2>
<p><strong>How many characters need to be processed before the first start-of-packet marker is detected?</strong></p>
<h2 id="part-2-5"><a class="header" href="#part-2-5">Part 2</a></h2>
<p>Your device's communication system is correctly detecting packets, but still isn't working. It looks like it also needs to look for <strong>messages</strong>.</p>
<p>A <strong>start-of-message marker</strong> is just like a start-of-packet marker, except it consists of <strong>14 distinct characters</strong> rather than 4.</p>
<p>Here are the first positions of start-of-message markers for all of the above examples:</p>
<ul>
<li><code>mjqjpqmgbljsphdztnvjfqwrcgsmlb</code>: first marker after character <code>19</code></li>
<li><code>bvwbjplbgvbhsrlpgdmjqwftvncz</code>: first marker after character <code>23</code></li>
<li><code>nppdvjthqldpwncqszvftbrmjlhg</code>: first marker after character <code>23</code></li>
<li><code>nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg</code>: first marker after character <code>29</code></li>
<li><code>zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw</code>: first marker after character <code>26</code></li>
</ul>
<p><strong>How many characters need to be processed before the first start-of-message marker is detected?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-6-solution-explanation"><a class="header" href="#day-6-solution-explanation">Day 6: Solution Explanation</a></h1>
<h2 id="approach-5"><a class="header" href="#approach-5">Approach</a></h2>
<p>Day 6's problem involves finding the first occurrence of a sequence of unique characters in a datastream. The approach is to:</p>
<ol>
<li>Process the input datastream as a sequence of bytes</li>
<li>Examine consecutive windows of characters (of length 4 for part 1, 14 for part 2)</li>
<li>Check each window for duplicate characters</li>
<li>Find the position of the first window that contains no duplicates</li>
</ol>
<p>The solution uses Rust's trait system to create reusable functionality for checking duplicates and finding marker positions.</p>
<h2 id="implementation-details-5"><a class="header" href="#implementation-details-5">Implementation Details</a></h2>
<h3 id="detecting-duplicates"><a class="header" href="#detecting-duplicates">Detecting Duplicates</a></h3>
<p>The first key component is a trait for checking whether a slice contains any duplicate elements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Duplicate {
    fn has_duplicates(&amp;self) -&gt; bool;
}

impl&lt;T&gt; Duplicate for [T] where T: Debug + Copy + PartialEq + Ord {
    fn has_duplicates(&amp;self) -&gt; bool {
        let mut tmp = self.to_vec();
        tmp.sort();
        tmp.windows(2).any(|a| a[0]==a[1])
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This implementation:</p>
<ol>
<li>Creates a copy of the slice</li>
<li>Sorts the copy (bringing identical elements next to each other)</li>
<li>Checks adjacent pairs for equality using <code>windows(2)</code></li>
</ol>
<p>The trait is implemented generically for any slice type <code>[T]</code> where <code>T</code> supports debugging, copying, equality comparison, and ordering.</p>
<h3 id="finding-marker-positions"><a class="header" href="#finding-marker-positions">Finding Marker Positions</a></h3>
<p>The second key component is a trait for finding the position of a marker in a datastream:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Signaling {
    fn marker_position(&amp;self, len:usize) -&gt; usize;
}

impl&lt;T&gt; Signaling for [T] where T : Debug + Copy + PartialEq + Ord {
    fn marker_position(&amp;self, len: usize) -&gt; usize {
        self.windows(len)
            .enumerate()
            .skip_while(|&amp;(_,stm)| stm.has_duplicates() )
            .next()
            .map(|(i,_)| i + len)
            .unwrap_or_else(|| panic!("marker_position(): Ops!"))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This implementation:</p>
<ol>
<li>Creates sliding windows of the specified length using <code>windows(len)</code></li>
<li>Pairs each window with its index using <code>enumerate()</code></li>
<li>Skips windows that contain duplicates using <code>skip_while</code></li>
<li>Takes the first window that has no duplicates</li>
<li>Returns the position after this window (index + window length)</li>
</ol>
<h3 id="main-solution"><a class="header" href="#main-solution">Main Solution</a></h3>
<p>With these traits defined, the main solution becomes remarkably simple:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let data = std::fs::read_to_string("src/bin/day6_input.txt").expect("");

    let out = data.bytes().collect::&lt;Vec&lt;_&gt;&gt;();
    println!("Marker Length @4 = {}", out.marker_position(4));
    println!("Marker Length @14 = {}", out.marker_position(14));
}</code></pre></pre>
<p>The solution reads the input file, converts it to a vector of bytes, and then calls <code>marker_position</code> with the appropriate lengths for part 1 (4) and part 2 (14).</p>
<h2 id="algorithm-analysis"><a class="header" href="#algorithm-analysis">Algorithm Analysis</a></h2>
<h3 id="time-complexity-1"><a class="header" href="#time-complexity-1">Time Complexity</a></h3>
<p>The time complexity of this solution depends on the length of the input (<code>n</code>) and the marker length (<code>m</code>):</p>
<ul>
<li>Checking for duplicates in a window takes O(m log m) time due to the sorting operation</li>
<li>In the worst case, we check every window in the input, giving us O(n) windows</li>
<li>Overall time complexity: O(n * m log m)</li>
</ul>
<p>For this problem, <code>m</code> is small (4 or 14), so the logarithmic factor isn't significant, making the effective complexity close to O(n).</p>
<h3 id="space-complexity-1"><a class="header" href="#space-complexity-1">Space Complexity</a></h3>
<p>The space complexity is O(n) to store the input as a vector of bytes, plus O(m) temporary storage for each duplicate check.</p>
<h2 id="alternative-approaches-4"><a class="header" href="#alternative-approaches-4">Alternative Approaches</a></h2>
<h3 id="using-a-hashset-for-duplicate-detection"><a class="header" href="#using-a-hashset-for-duplicate-detection">Using a HashSet for Duplicate Detection</a></h3>
<p>A common alternative approach would be to use a <code>HashSet</code> to check for duplicates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn has_unique_chars(window: &amp;[u8]) -&gt; bool {
    let mut set = HashSet::new();
    window.iter().all(|&amp;c| set.insert(c))
}
<span class="boring">}</span></code></pre></pre>
<p>This would have O(m) time complexity for checking duplicates instead of O(m log m), but at the cost of using <code>HashSet</code> which has more overhead than simple sorting for small datasets.</p>
<h3 id="using-frequency-counting"><a class="header" href="#using-frequency-counting">Using Frequency Counting</a></h3>
<p>Another approach would be to count the frequency of each character:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn has_unique_chars(window: &amp;[u8]) -&gt; bool {
    let mut counts = [0; 256]; // For ASCII
    for &amp;c in window {
        counts[c as usize] += 1;
        if counts[c as usize] &gt; 1 {
            return false;
        }
    }
    true
}
<span class="boring">}</span></code></pre></pre>
<p>This has O(m) time complexity and uses a fixed amount of space, but is limited to ASCII or other bounded character sets.</p>
<h3 id="using-a-bit-set"><a class="header" href="#using-a-bit-set">Using a Bit Set</a></h3>
<p>For even more efficiency, a bit set could be used for the specific case of lowercase ASCII characters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn has_unique_chars(window: &amp;[u8]) -&gt; bool {
    let mut bits = 0u32;
    for &amp;c in window {
        let mask = 1 &lt;&lt; (c - b'a');
        if (bits &amp; mask) != 0 {
            return false;
        }
        bits |= mask;
    }
    true
}
<span class="boring">}</span></code></pre></pre>
<p>This has O(m) time complexity and uses only a single integer for storage, but is limited to a single case of character set.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>The solution demonstrates the power of Rust's traits for creating reusable, generic functionality. By separating the concerns of duplicate detection and marker finding into traits, the code becomes more modular and expressive. The generic implementation allows the solution to work with any type of element, not just characters, making it more versatile than specialized approaches.</p>
<div style="break-before: page; page-break-before: always;"></div><p>{{REWRITTEN_CODE}}</p>
<h1 id="day-6-code"><a class="header" href="#day-6-code">Day 6: Code</a></h1>
<p>Below is the complete code for Day 6's solution, which finds marker patterns in a datastream.</p>
<h2 id="full-solution-5"><a class="header" href="#full-solution-5">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">use std::fmt::Debug;

trait Duplicate {
    fn has_duplicates(&amp;self) -&gt; bool;
}
impl&lt;T&gt; Duplicate for [T] where T: Debug + Copy + PartialEq + Ord {
    fn has_duplicates(&amp;self) -&gt; bool {
        let mut tmp = self.to_vec();
        tmp.sort();
        tmp.windows(2).any(|a| a[0]==a[1])
    }
}

trait Signaling {
    fn marker_position(&amp;self, len:usize) -&gt; usize;
}
impl&lt;T&gt; Signaling for [T] where T : Debug + Copy + PartialEq + Ord {
    fn marker_position(&amp;self, len: usize) -&gt; usize {
        self.windows(len)
            .enumerate()
            .skip_while(|&amp;(_,stm)| stm.has_duplicates() )
            .next()
            .map(|(i,_)| i + len)
            .unwrap_or_else(|| panic!("marker_position(): Ops!"))
    }
}

fn main() {
    let data = std::fs::read_to_string("src/bin/day6_input.txt").expect("");

    let out = data.bytes().collect::&lt;Vec&lt;_&gt;&gt;();
    println!("Marker Length @4 = {}", out.marker_position(4));
    println!("Marker Length @14 = {}", out.marker_position(14));
}</code></pre>
<h2 id="code-walkthrough-5"><a class="header" href="#code-walkthrough-5">Code Walkthrough</a></h2>
<h3 id="duplicate-detection-trait"><a class="header" href="#duplicate-detection-trait">Duplicate Detection Trait</a></h3>
<pre><code class="language-rust no_run noplayground">trait Duplicate {
    fn has_duplicates(&amp;self) -&gt; bool;
}
impl&lt;T&gt; Duplicate for [T] where T: Debug + Copy + PartialEq + Ord {
    fn has_duplicates(&amp;self) -&gt; bool {
        let mut tmp = self.to_vec();
        tmp.sort();
        tmp.windows(2).any(|a| a[0]==a[1])
    }
}</code></pre>
<p>This trait provides a method to check if a slice contains duplicate elements:</p>
<ol>
<li><code>Duplicate</code> trait defines a single method <code>has_duplicates</code> that returns a boolean</li>
<li>The implementation for slices <code>[T]</code> works with any type that can be debugged, copied, compared for equality, and ordered</li>
<li>The implementation creates a temporary copy of the slice, sorts it (bringing identical elements adjacent to each other), and then checks if any adjacent elements are equal</li>
<li>The <code>windows(2)</code> method creates sliding windows of 2 elements, and <code>any</code> checks if the predicate is true for any window</li>
</ol>
<h3 id="marker-detection-trait"><a class="header" href="#marker-detection-trait">Marker Detection Trait</a></h3>
<pre><code class="language-rust no_run noplayground">trait Signaling {
    fn marker_position(&amp;self, len:usize) -&gt; usize;
}
impl&lt;T&gt; Signaling for [T] where T : Debug + Copy + PartialEq + Ord {
    fn marker_position(&amp;self, len: usize) -&gt; usize {
        self.windows(len)
            .enumerate()
            .skip_while(|&amp;(_,stm)| stm.has_duplicates() )
            .next()
            .map(|(i,_)| i + len)
            .unwrap_or_else(|| panic!("marker_position(): Ops!"))
    }
}</code></pre>
<p>This trait provides a method to find the position of the first marker of a specified length:</p>
<ol>
<li><code>Signaling</code> trait defines a single method <code>marker_position</code> that takes a length parameter and returns a position</li>
<li>The implementation creates sliding windows of the specified length using <code>windows(len)</code></li>
<li>Each window is paired with its position using <code>enumerate()</code></li>
<li>Windows containing duplicates are skipped using <code>skip_while</code></li>
<li>The first window without duplicates is selected with <code>next()</code></li>
<li>The marker position is calculated as the window index plus the window length</li>
</ol>
<h3 id="main-function-1"><a class="header" href="#main-function-1">Main Function</a></h3>
<pre><code class="language-rust no_run noplayground">fn main() {
    let data = std::fs::read_to_string("src/bin/day6_input.txt").expect("");

    let out = data.bytes().collect::&lt;Vec&lt;_&gt;&gt;();
    println!("Marker Length @4 = {}", out.marker_position(4));
    println!("Marker Length @14 = {}", out.marker_position(14));
}</code></pre>
<p>The main function:</p>
<ol>
<li>Reads the input file into a string</li>
<li>Converts the string to a vector of bytes using <code>bytes().collect()</code></li>
<li>Calls <code>marker_position(4)</code> to solve Part 1 (finding a start-of-packet marker)</li>
<li>Calls <code>marker_position(14)</code> to solve Part 2 (finding a start-of-message marker)</li>
</ol>
<h2 id="implementation-notes-4"><a class="header" href="#implementation-notes-4">Implementation Notes</a></h2>
<ul>
<li><strong>Traits for Reusability</strong>: The solution uses Rust's trait system to create reusable behaviors</li>
<li><strong>Generic Implementation</strong>: Both traits work with any type that meets the trait bounds, not just bytes or characters</li>
<li><strong>Functional Approach</strong>: The code uses a functional programming style with method chaining for concise and expressive code</li>
<li><strong>Algorithm Choice</strong>: The solution uses sorting for duplicate detection, which is efficient for small windows (like the 4 and 14 character windows in this problem)</li>
</ul>
<p>The implementation is elegant and leverages Rust's powerful type system to create a generic, reusable solution that can handle both parts of the problem with the same code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-7-no-space-left-on-device"><a class="header" href="#day-7-no-space-left-on-device">Day 7: No Space Left On Device</a></h1>
<p>Day 7 involves parsing terminal output to build a directory structure and calculate directory sizes.</p>
<h2 id="problem-overview-6"><a class="header" href="#problem-overview-6">Problem Overview</a></h2>
<p>You're trying to free up space on your device by analyzing the file system. Given a terminal output showing the commands you executed and their results, you need to:</p>
<ol>
<li>Build a directory tree from the commands and output</li>
<li>Calculate the total size of each directory (including subdirectories)</li>
<li>Find directories smaller than a certain size</li>
<li>Find the smallest directory that, when deleted, would free enough space</li>
</ol>
<p>This problem tests your ability to parse structured text, build a tree data structure, and perform size calculations on it.</p>
<h2 id="navigation-6"><a class="header" href="#navigation-6">Navigation</a></h2>
<ul>
<li><a href="day7/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day7/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day7/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-7-problem-description"><a class="header" href="#day-7-problem-description">Day 7: Problem Description</a></h1>
<h2 id="no-space-left-on-device"><a class="header" href="#no-space-left-on-device">No Space Left On Device</a></h2>
<p>You can hear birds chirping and raindrops hitting leaves as the expedition proceeds. Occasionally, you can even hear much louder sounds in the distance; how big do the animals get out here, anyway?</p>
<p>The device the Elves gave you has problems with more than just its communication system. You try to run a system update:</p>
<pre><code>$ system-update --please --pretty-please-with-sugar-on-top
Error: No space left on device
</code></pre>
<p>Perhaps you can delete some files to make space for the update?</p>
<p>You browse around the filesystem to assess the situation and save the resulting terminal output (your puzzle input). For example:</p>
<pre><code>$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k
</code></pre>
<p>The filesystem consists of a tree of files (plain data) and directories (which can contain other directories or files). The outermost directory is called <code>/</code>. You can navigate around the filesystem, moving into or out of directories and listing the contents of the directory you're currently in.</p>
<p>Within the terminal output, lines that begin with <code>$</code> are <strong>commands you executed</strong>, very much like some modern computers:</p>
<ul>
<li><code>cd</code> means <strong>change directory</strong>. This changes which directory is the current directory, but the specific result depends on the argument:
<ul>
<li><code>cd x</code> moves <strong>in</strong> one level: it looks in the current directory for the directory named <code>x</code> and makes it the current directory.</li>
<li><code>cd ..</code> moves <strong>out</strong> one level: it finds the directory that contains the current directory, then makes that directory the current directory.</li>
<li><code>cd /</code> switches the current directory to the outermost directory, <code>/</code>.</li>
</ul>
</li>
<li><code>ls</code> means <strong>list</strong>. It prints out all of the files and directories immediately contained by the current directory:
<ul>
<li><code>123 abc</code> means that the current directory contains a file named <code>abc</code> with size <code>123</code>.</li>
<li><code>dir xyz</code> means that the current directory contains a directory named <code>xyz</code>.</li>
</ul>
</li>
</ul>
<p>Given the commands and output in the example above, you can determine that the filesystem looks visually like this:</p>
<pre><code>- / (dir)
  - a (dir)
    - e (dir)
      - i (file, size=584)
    - f (file, size=29116)
    - g (file, size=2557)
    - h.lst (file, size=62596)
  - b.txt (file, size=14848514)
  - c.dat (file, size=8504156)
  - d (dir)
    - j (file, size=4060174)
    - d.log (file, size=8033020)
    - d.ext (file, size=5626152)
    - k (file, size=7214296)
</code></pre>
<p>Here, there are four directories: <code>/</code> (the outermost directory), <code>a</code> and <code>d</code> (which are in <code>/</code>), and <code>e</code> (which is in <code>a</code>). These directories also contain files of various sizes.</p>
<p>Since the disk is full, your first step should probably be to find directories that are good candidates for deletion. To do this, you need to determine the <strong>total size</strong> of each directory. The total size of a directory is the sum of the sizes of the files it contains, directly or indirectly. (Directories themselves do not count as having any intrinsic size.)</p>
<p>The total sizes of the directories above can be found as follows:</p>
<ul>
<li>The total size of directory <code>e</code> is <strong>584</strong> because it contains a single file <code>i</code> of size 584 and no other directories.</li>
<li>The directory <code>a</code> has total size <strong>94853</strong> because it contains files <code>f</code> (size 29116), <code>g</code> (size 2557), and <code>h.lst</code> (size 62596), plus file <code>i</code> indirectly (<code>a</code> contains <code>e</code> which contains <code>i</code>).</li>
<li>Directory <code>d</code> has total size <strong>24933642</strong>.</li>
<li>As the outermost directory, <code>/</code> contains every file. Its total size is <strong>48381165</strong>, the sum of the size of every file.</li>
</ul>
<p>To begin, find all of the directories with a total size of <strong>at most 100000</strong>, then calculate the sum of their total sizes. In the example above, these directories are <code>a</code> and <code>e</code>; the sum of their total sizes is <strong>95437</strong> (94853 + 584). (As in this example, this process can count files more than once!)</p>
<h2 id="part-1-6"><a class="header" href="#part-1-6">Part 1</a></h2>
<p>Find all of the directories with a total size of at most 100000. <strong>What is the sum of the total sizes of those directories?</strong></p>
<h2 id="part-2-6"><a class="header" href="#part-2-6">Part 2</a></h2>
<p>Now, you're ready to choose a directory to delete.</p>
<p>The total disk space available to the filesystem is <strong>70000000</strong>. To run the update, you need unused space of at least <strong>30000000</strong>. You need to find a directory you can delete that will <strong>free up enough space</strong> to run the update.</p>
<p>In the example above, the total size of the outermost directory (and thus the total amount of used space) is 48381165; this means that the size of the <strong>unused</strong> space must currently be 21618835, which isn't quite the 30000000 required by the update. Therefore, the update still requires a directory with total size of at least 8381165 to be deleted before it can run.</p>
<p>To achieve this, you have the following options:</p>
<ul>
<li>Delete directory <code>e</code>, which would increase unused space by 584.</li>
<li>Delete directory <code>a</code>, which would increase unused space by 94853.</li>
<li>Delete directory <code>d</code>, which would increase unused space by 24933642.</li>
<li>Delete directory <code>/</code>, which would increase unused space by 48381165.</li>
</ul>
<p>Directories <code>e</code> and <code>a</code> are both too small; deleting them would not free up enough space. However, directories <code>d</code> and <code>/</code> are both big enough! Between these, choose the <strong>smallest</strong>: <code>d</code>, increasing unused space by <strong>24933642</strong>.</p>
<p><strong>Find the smallest directory that, if deleted, would free up enough space on the filesystem to run the update. What is the total size of that directory?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-7-solution-explanation"><a class="header" href="#day-7-solution-explanation">Day 7: Solution Explanation</a></h1>
<h2 id="approach-6"><a class="header" href="#approach-6">Approach</a></h2>
<p>Day 7's problem involves building a directory tree and calculating directory sizes from terminal output. The solution breaks down into several key steps:</p>
<ol>
<li>Parse the terminal output into commands and results</li>
<li>Build a directory tree structure based on the commands</li>
<li>Calculate the total size of each directory (including its subdirectories)</li>
<li>Find directories matching the specified size criteria</li>
</ol>
<p>The solution uses a tree structure with nodes representing directories, where each node keeps track of its contents and size.</p>
<h2 id="implementation-details-6"><a class="header" href="#implementation-details-6">Implementation Details</a></h2>
<h3 id="data-structures-2"><a class="header" href="#data-structures-2">Data Structures</a></h3>
<p>The solution uses several custom types to represent the file system:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
enum ResultType {
    File(String, usize),  // File name and size
    Dir(String)           // Directory name
}

#[derive(Debug)]
enum CommandType {
    Cd(String),  // Change directory with target
    List          // List directory contents
}

#[derive(Debug)]
enum LineType {
    Cmd(CommandType),  // A command
    Rst(ResultType)    // Output from a command
}
<span class="boring">}</span></code></pre></pre>
<p>These enums represent the different types of lines in the terminal output.</p>
<h3 id="path-representation"><a class="header" href="#path-representation">Path Representation</a></h3>
<p>A custom <code>Path</code> struct is used to represent file paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Hash, Eq, PartialEq)]
struct Path(String);

impl Path {
    fn new(path:String) -&gt; Path {
        Path(path)
    }
    fn append(&amp;self, dir: &amp;str) -&gt; Path {
        Path(format!("{}{}",self.0,dir))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This struct wraps a string and provides methods for creating and appending to paths. It's also made to be hashable so it can be used as a key in a <code>HashMap</code>.</p>
<h3 id="directory-tree-structure"><a class="header" href="#directory-tree-structure">Directory Tree Structure</a></h3>
<p>The directory tree is represented by two structures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Node {
    parent: Path,            // Parent directory path
    content: Vec&lt;ResultType&gt;, // Contents (files and subdirectories)
    size: usize              // Size of files directly in this directory
}

#[derive(Debug)]
struct Tree {
    map: HashMap&lt;Path,Node&gt;, // Maps paths to nodes
    totals: RefCell&lt;Vec&lt;(Path,usize)&gt;&gt; // Stores total sizes for each directory
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Node</code> structure represents a directory with its parent, contents, and direct file size. The <code>Tree</code> structure contains a map from paths to nodes and a list of total sizes for all directories.</p>
<h3 id="parsing-the-terminal-output"><a class="header" href="#parsing-the-terminal-output">Parsing the Terminal Output</a></h3>
<p>The terminal output is parsed line by line using an iterator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct History();
impl History {
    fn iterator(history:&amp;str) -&gt; impl Iterator&lt;Item=LineType&gt; + '_ {
        history.lines()
            .filter_map(|e| {
                let p:Vec&lt;_&gt; = e.split(' ').collect();
                match p[0] {
                    "$" =&gt; match p[1] {
                        "ls" =&gt; Some(LineType::Cmd(CommandType::List)),
                        "cd" =&gt; Some(LineType::Cmd(CommandType::Cd(String::from(p[2])))),
                        _ =&gt; None
                    }
                    "dir" =&gt; Some(LineType::Rst(ResultType::Dir(p[1].to_string()))),
                    _ =&gt; Some(LineType::Rst(ResultType::File(p[1].to_string(), usize::from_str(p[0]).unwrap())))
                }
            })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This iterator converts each line into a <code>LineType</code> (either a command or a result) based on the line format.</p>
<h3 id="building-the-directory-tree"><a class="header" href="#building-the-directory-tree">Building the Directory Tree</a></h3>
<p>The directory tree is built by processing each command and its results:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_history(history: impl Iterator&lt;Item=LineType&gt;) -&gt; Tree {
    use LineType::*;

    let mut map = HashMap::&lt;Path,Node&gt;::new();
    let mut path = Path::new("".to_string());

    history
        .for_each(|lt| {
            match lt {
                Cmd(CommandType::Cd(dir)) if dir.contains("..") =&gt; path = map[&amp;path].parent.clone(),
                Cmd(CommandType::Cd(dir)) =&gt; {
                    let cpath = path.append(dir.as_str());
                    map.entry(cpath.clone())
                        .or_insert(Node { parent: path.clone(), content: Vec::new(), size: 0 });
                    path = cpath;
                }
                Rst(res) =&gt; {
                    let node = map.get_mut(&amp;path).unwrap();
                    node.content.push(res.clone());
                    if let ResultType::File(_,fsize) = res {
                        node.size += fsize;
                    }
                }
                Cmd(CommandType::List) =&gt; {},
            }
        });
    Tree { map, totals: RefCell::new(Vec::new()) }
}
<span class="boring">}</span></code></pre></pre>
<p>As commands are processed, a current path is maintained, and nodes are added to the tree as needed. When file results are encountered, they're added to the current directory's contents and their sizes are added to the directory's direct size.</p>
<h3 id="calculating-directory-sizes"><a class="header" href="#calculating-directory-sizes">Calculating Directory Sizes</a></h3>
<p>To calculate the total size of each directory (including subdirectories), a recursive function is used:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calc_dirs_totals(&amp;self, path: &amp;Path) -&gt; usize {
    let mut sum = self.dir_size(path);
    for dir in self.children(path) {
        let cpath = path.append(dir);
        sum += self.calc_dirs_totals(&amp;cpath);
    }
    self.totals.borrow_mut().push((path.clone(), sum));
    sum
}
<span class="boring">}</span></code></pre></pre>
<p>This function calculates the total size of a directory by adding its direct size to the total sizes of its subdirectories. It also stores the total size in the <code>totals</code> list.</p>
<h3 id="solving-part-1-1"><a class="header" href="#solving-part-1-1">Solving Part 1</a></h3>
<p>For Part 1, the solution finds all directories with a total size of at most 100,000 and sums their sizes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dirs.iter()
    .filter(|(_,size)| *size &lt; 100000 )
    .map(|&amp;(_,size)| size)
    .sum::&lt;usize&gt;()
<span class="boring">}</span></code></pre></pre>
<h3 id="solving-part-2-1"><a class="header" href="#solving-part-2-1">Solving Part 2</a></h3>
<p>For Part 2, the solution finds the smallest directory that, when deleted, would free enough space:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let total_space = 70000000;
let min_free_space = 30000000;
let &amp;(_,total_used) = dirs.last().unwrap();
let min_space_to_free = min_free_space - (total_space - total_used);

dirs.iter()
    .filter(|(_,size)| *size &gt;= min_space_to_free )
    .min_by(|&amp;a,&amp;b| a.1.cmp(&amp;b.1))
<span class="boring">}</span></code></pre></pre>
<p>It calculates the minimum amount of space that needs to be freed, then finds the smallest directory that is at least that size.</p>
<h2 id="algorithmic-analysis"><a class="header" href="#algorithmic-analysis">Algorithmic Analysis</a></h2>
<h3 id="time-complexity-2"><a class="header" href="#time-complexity-2">Time Complexity</a></h3>
<ul>
<li>Parsing the terminal output: O(n), where n is the number of lines</li>
<li>Building the directory tree: O(n)</li>
<li>Calculating directory sizes: O(d), where d is the number of directories</li>
<li>Finding directories by size: O(d)</li>
</ul>
<p>Overall time complexity: O(n + d), which simplifies to O(n) since d â‰¤ n</p>
<h3 id="space-complexity-2"><a class="header" href="#space-complexity-2">Space Complexity</a></h3>
<ul>
<li>Directory tree: O(n) to store all files and directories</li>
<li>Totals list: O(d) to store the size of each directory</li>
</ul>
<p>Overall space complexity: O(n)</p>
<h2 id="alternative-approaches-5"><a class="header" href="#alternative-approaches-5">Alternative Approaches</a></h2>
<h3 id="using-a-real-file-system-library"><a class="header" href="#using-a-real-file-system-library">Using a Real File System Library</a></h3>
<p>Instead of implementing a custom file system representation, we could use a file system library that supports virtual file systems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::PathBuf;
use memfs::MemFs;

let fs = MemFs::new();

// Process commands and build the file system
for line in input.lines() {
    // Parse and execute commands...
}

// Calculate directory sizes
fn dir_size(fs: &amp;MemFs, path: &amp;PathBuf) -&gt; usize {
    // Calculate size recursively
}
<span class="boring">}</span></code></pre></pre>
<p>This would leverage existing file system implementations but might be more complex to set up.</p>
<h3 id="using-a-graph-library"><a class="header" href="#using-a-graph-library">Using a Graph Library</a></h3>
<p>Another approach would be to use a graph library to represent the directory structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use petgraph::graph::{DiGraph, NodeIndex};
use petgraph::visit::DfsPostOrder;

let mut graph = DiGraph::new();
let mut node_map = HashMap::new();

// Build the graph
// ...

// Calculate sizes with a post-order traversal
let mut dfs = DfsPostOrder::new(&amp;graph, root);
while let Some(node) = dfs.next(&amp;graph) {
    // Calculate size based on children's sizes
}
<span class="boring">}</span></code></pre></pre>
<p>This would use well-tested graph algorithms but adds an external dependency.</p>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>This solution demonstrates how to parse structured text and build a tree representation of a file system. The use of custom types like <code>Path</code>, <code>Node</code>, and <code>Tree</code> makes the code expressive and organized. The recursive calculation of directory sizes is a natural fit for the hierarchical nature of the file system.</p>
<div style="break-before: page; page-break-before: always;"></div><p>{{REWRITTEN_CODE}}</p>
<h1 id="day-7-code"><a class="header" href="#day-7-code">Day 7: Code</a></h1>
<p>Below is the complete code for Day 7's solution, which parses terminal output to build a directory tree and analyze directory sizes.</p>
<h2 id="full-solution-6"><a class="header" href="#full-solution-6">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">use std::cell::RefCell;
use std::collections::HashMap;
use std::str::FromStr;

#[derive(Debug, Clone)]
enum ResultType {
    File(String, usize),
    Dir(String)
}
#[derive(Debug)]
enum CommandType {
    Cd(String),
    List
}
#[derive(Debug)]
enum LineType {
    Cmd(CommandType),
    Rst(ResultType)
}
#[derive(Debug, Clone, Hash, Eq, PartialEq)]
struct Path(String);
impl Path {
    fn new(path:String) -&gt; Path {
        Path(path)
    }
    fn append(&amp;self, dir: &amp;str) -&gt; Path {
        Path(format!("{}{}",self.0,dir))
    }
}
#[derive(Debug)]
struct Node {
    parent: Path,
    content: Vec&lt;ResultType&gt;,
    size: usize
}
#[derive(Debug)]
struct Tree {
    map: HashMap&lt;Path,Node&gt;,
    totals: RefCell&lt;Vec&lt;(Path,usize)&gt;&gt;
}
impl Tree {
    fn children(&amp;self, path: &amp;Path) -&gt; Vec&lt;&amp;String&gt; {
        self.map[path]
            .content
            .iter()
            .filter_map(|rt|
                if let ResultType::Dir(dir) = rt {
                    Some(dir)
                } else {
                    None
                }
            )
            .collect()
    }
    fn dir_size(&amp;self, path: &amp;Path) -&gt; usize {
        self.map[path].size
    }
    fn totals(&amp;self) -&gt; Vec&lt;(Path, usize)&gt; {
        self.totals.take()
    }
    fn parse_history(history: impl Iterator&lt;Item=LineType&gt;) -&gt; Tree {
        use LineType::*;

        let mut map = HashMap::&lt;Path,Node&gt;::new();
        let mut path = Path::new("".to_string());

        history
            // .inspect(|line| println!("{:?}",line))
            .for_each(|lt| {
                match lt {
                    Cmd(CommandType::Cd(dir)) if dir.contains("..") =&gt; path = map[&amp;path].parent.clone(),
                    Cmd(CommandType::Cd(dir)) =&gt; {
                        let cpath = path.append(dir.as_str());
                        println!("{:?}",cpath);
                        map.entry(cpath.clone())
                            .or_insert(Node { parent: path.clone(), content: Vec::new(), size: 0 });
                        path = cpath;
                    }
                    Rst(res) =&gt; {
                        let node = map.get_mut(&amp;path).unwrap();
                        node.content.push(res.clone());
                        if let ResultType::File(_,fsize) = res {
                            node.size += fsize;
                        }
                    }
                    Cmd(CommandType::List) =&gt; {},
                }
            });
        Tree { map, totals: RefCell::new(Vec::new()) }
    }
    fn calc_dirs_totals(&amp;self, path: &amp;Path) -&gt; usize {
        let mut sum = self.dir_size(path);
        for dir in self.children(path) {
            let cpath = path.append(dir);
            sum += self.calc_dirs_totals(&amp;cpath);
        }
        // println!("{:?}:{:?}", path, sum);
        self.totals.borrow_mut().push((path.clone(), sum));
        sum
    }
}

struct History();
impl History {
    fn iterator(history:&amp;str) -&gt; impl Iterator&lt;Item=LineType&gt; + '_{
        history.lines()
            .filter_map(|e| {
                let p:Vec&lt;_&gt; = e.split(' ').collect();
                match p[0] {
                    "$" =&gt; match p[1] {
                        "ls" =&gt; Some(LineType::Cmd(CommandType::List)),
                        "cd" =&gt; Some(LineType::Cmd(CommandType::Cd(String::from(p[2])))),
                        _ =&gt; None
                    }
                    "dir" =&gt; Some(LineType::Rst(ResultType::Dir(p[1].to_string()))),
                    _ =&gt; Some(LineType::Rst(ResultType::File(p[1].to_string(), usize::from_str(p[0]).unwrap())))
                }
            })
    }
}

fn main() {

    let history = std::fs::read_to_string("src/bin/day7_input.txt").expect("");

    let tree = Tree::parse_history(
        History::iterator(history.as_str())
    );

    tree.calc_dirs_totals(&amp;Path::new("/".to_string()));
    let dirs = tree.totals();

    println!("Directories &lt; 100000 \n====================");
    println!("{:?}",
             dirs.iter()
                 .filter(|(_,size)| *size &lt; 100000 )
                 .inspect(|&amp;p| println!("{:?}",p))
                 .map(|&amp;(_,size)| size)</code></pre>
<h2 id="code-walkthrough-6"><a class="header" href="#code-walkthrough-6">Code Walkthrough</a></h2>
<h3 id="data-types"><a class="header" href="#data-types">Data Types</a></h3>
<p>The solution defines several types to represent the file system and terminal output:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone)]
enum ResultType {
    File(String, usize),
    Dir(String)
}
#[derive(Debug)]
enum CommandType {
    Cd(String),
    List
}
#[derive(Debug)]
enum LineType {
    Cmd(CommandType),
    Rst(ResultType)
}</code></pre>
<p>These enums represent:</p>
<ul>
<li><code>ResultType</code>: Either a file (with name and size) or a directory (with name)</li>
<li><code>CommandType</code>: Either a change directory command or a list command</li>
<li><code>LineType</code>: Either a command or a result</li>
</ul>
<h3 id="path-representation-1"><a class="header" href="#path-representation-1">Path Representation</a></h3>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone, Hash, Eq, PartialEq)]
struct Path(String);
impl Path {
    fn new(path:String) -&gt; Path {
        Path(path)
    }
    fn append(&amp;self, dir: &amp;str) -&gt; Path {
        Path(format!("{}{}",self.0,dir))
    }
}</code></pre>
<p>The <code>Path</code> struct encapsulates a string representing a file path and provides methods to create and append to paths.</p>
<h3 id="directory-tree"><a class="header" href="#directory-tree">Directory Tree</a></h3>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
struct Node {
    parent: Path,
    content: Vec&lt;ResultType&gt;,
    size: usize
}
#[derive(Debug)]
struct Tree {
    map: HashMap&lt;Path,Node&gt;,
    totals: RefCell&lt;Vec&lt;(Path,usize)&gt;&gt;
}</code></pre>
<p>The directory tree consists of:</p>
<ul>
<li><code>Node</code>: Represents a directory with its parent, contents, and direct size</li>
<li><code>Tree</code>: Contains a map of paths to nodes and a list of total sizes</li>
</ul>
<h3 id="directory-tree-methods"><a class="header" href="#directory-tree-methods">Directory Tree Methods</a></h3>
<pre><code class="language-rust no_run noplayground">impl Tree {
    fn children(&amp;self, path: &amp;Path) -&gt; Vec&lt;&amp;String&gt; {
        self.map[path]
            .content
            .iter()
            .filter_map(|rt|
                if let ResultType::Dir(dir) = rt {
                    Some(dir)
                } else {
                    None
                }
            )
            .collect()
    }
    fn dir_size(&amp;self, path: &amp;Path) -&gt; usize {
        self.map[path].size
    }
    fn totals(&amp;self) -&gt; Vec&lt;(Path, usize)&gt; {
        self.totals.take()
    }</code></pre>
<p>These methods provide functionality to:</p>
<ul>
<li>Get a list of child directories</li>
<li>Get the direct size of a directory</li>
<li>Take the list of total sizes</li>
</ul>
<h3 id="parsing-terminal-output"><a class="header" href="#parsing-terminal-output">Parsing Terminal Output</a></h3>
<pre><code class="language-rust no_run noplayground">    fn parse_history(history: impl Iterator&lt;Item=LineType&gt;) -&gt; Tree {
        use LineType::*;

        let mut map = HashMap::&lt;Path,Node&gt;::new();
        let mut path = Path::new("".to_string());

        history
            // .inspect(|line| println!("{:?}",line))
            .for_each(|lt| {
                match lt {
                    Cmd(CommandType::Cd(dir)) if dir.contains("..") =&gt; path = map[&amp;path].parent.clone(),
                    Cmd(CommandType::Cd(dir)) =&gt; {
                        let cpath = path.append(dir.as_str());
                        println!("{:?}",cpath);
                        map.entry(cpath.clone())
                            .or_insert(Node { parent: path.clone(), content: Vec::new(), size: 0 });
                        path = cpath;
                    }
                    Rst(res) =&gt; {
                        let node = map.get_mut(&amp;path).unwrap();
                        node.content.push(res.clone());
                        if let ResultType::File(_,fsize) = res {
                            node.size += fsize;
                        }
                    }
                    Cmd(CommandType::List) =&gt; {},
                }
            });
        Tree { map, totals: RefCell::new(Vec::new()) }
    }</code></pre>
<p>This method builds a directory tree by processing terminal commands:</p>
<ul>
<li>For <code>cd ..</code> commands, it moves up to the parent directory</li>
<li>For other <code>cd</code> commands, it creates a new directory if needed and moves into it</li>
<li>For result lines, it adds files or directories to the current directory's contents</li>
</ul>
<h3 id="calculating-total-sizes"><a class="header" href="#calculating-total-sizes">Calculating Total Sizes</a></h3>
<pre><code class="language-rust no_run noplayground">    fn calc_dirs_totals(&amp;self, path: &amp;Path) -&gt; usize {
        let mut sum = self.dir_size(path);
        for dir in self.children(path) {
            let cpath = path.append(dir);
            sum += self.calc_dirs_totals(&amp;cpath);
        }
        // println!("{:?}:{:?}", path, sum);
        self.totals.borrow_mut().push((path.clone(), sum));
        sum
    }</code></pre>
<p>This recursive method calculates the total size of each directory by adding its direct size to the total sizes of its subdirectories.</p>
<h3 id="creating-the-line-iterator"><a class="header" href="#creating-the-line-iterator">Creating the Line Iterator</a></h3>
<pre><code class="language-rust no_run noplayground">struct History();
impl History {
    fn iterator(history:&amp;str) -&gt; impl Iterator&lt;Item=LineType&gt; + '_{
        history.lines()
            .filter_map(|e| {
                let p:Vec&lt;_&gt; = e.split(' ').collect();
                match p[0] {
                    "$" =&gt; match p[1] {
                        "ls" =&gt; Some(LineType::Cmd(CommandType::List)),
                        "cd" =&gt; Some(LineType::Cmd(CommandType::Cd(String::from(p[2])))),
                        _ =&gt; None
                    }
                    "dir" =&gt; Some(LineType::Rst(ResultType::Dir(p[1].to_string()))),
                    _ =&gt; Some(LineType::Rst(ResultType::File(p[1].to_string(), usize::from_str(p[0]).unwrap())))
                }
            })
    }
}</code></pre>
<p>This creates an iterator that converts terminal output lines into <code>LineType</code> values by parsing each line based on its format.</p>
<h3 id="main-function-2"><a class="header" href="#main-function-2">Main Function</a></h3>
<pre><code class="language-rust no_run noplayground">fn main() {

    let history = std::fs::read_to_string("src/bin/day7_input.txt").expect("");

    let tree = Tree::parse_history(
        History::iterator(history.as_str())
    );

    tree.calc_dirs_totals(&amp;Path::new("/".to_string()));
    let dirs = tree.totals();

    println!("Directories &lt; 100000 \n====================");
    println!("{:?}",
             dirs.iter()
                 .filter(|(_,size)| *size &lt; 100000 )
                 .inspect(|&amp;p| println!("{:?}",p))
                 .map(|&amp;(_,size)| size)
                 .sum::&lt;usize&gt;()
    );

    let total_space = 70000000;
    let min_free_space = 30000000;
    let &amp;(_,total_used) = dirs.last().unwrap();
    let min_space_to_free = min_free_space - (total_space - total_used);
    println!("Directories ~ 30000000 \n====================");
    println!("{:?}",
             dirs.iter()
                 .filter(|(_,size)| *size &gt;= min_space_to_free )
                 .inspect(|&amp;p| println!("{:?}",p))
                 .min_by(|&amp;a,&amp;b| a.1.cmp(&amp;b.1))
    );
}</code></pre>
<p>The main function:</p>
<ol>
<li>Reads the terminal output from a file</li>
<li>Creates an iterator to parse the output</li>
<li>Builds a directory tree using the parsed commands</li>
<li>Calculates the total size of each directory</li>
<li>For Part 1: Finds directories smaller than 100,000 and sums their sizes</li>
<li>For Part 2: Finds the smallest directory that would free enough space when deleted</li>
</ol>
<h2 id="implementation-notes-5"><a class="header" href="#implementation-notes-5">Implementation Notes</a></h2>
<ul>
<li><strong>RefCell Usage</strong>: The solution uses a <code>RefCell</code> to store the list of total sizes, allowing it to be modified during the recursive calculation</li>
<li><strong>Path Representation</strong>: Paths are represented as strings for simplicity, but with a custom wrapper type for safety</li>
<li><strong>Tree Structure</strong>: The directory tree uses a map-based representation with explicit parent references, making it easy to navigate up and down the tree</li>
<li><strong>Functional Approach</strong>: The solution makes extensive use of iterators and functional programming patterns</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-8-treetop-tree-house"><a class="header" href="#day-8-treetop-tree-house">Day 8: Treetop Tree House</a></h1>
<p>Day 8 involves analyzing a grid of trees to determine visibility and scenic scores.</p>
<h2 id="problem-overview-7"><a class="header" href="#problem-overview-7">Problem Overview</a></h2>
<p>You're trying to find the best spot for a treehouse in a forest. Given a grid where each cell contains a tree with a certain height, you need to:</p>
<ol>
<li>Determine which trees are visible from outside the grid by looking horizontally or vertically</li>
<li>Calculate a "scenic score" for each tree based on viewing distance in four directions</li>
<li>Find the tree with the highest scenic score</li>
</ol>
<p>This problem tests your ability to work with 2D grids and perform directional scanning operations.</p>
<h2 id="navigation-7"><a class="header" href="#navigation-7">Navigation</a></h2>
<ul>
<li><a href="day8/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day8/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day8/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-8-problem-description"><a class="header" href="#day-8-problem-description">Day 8: Problem Description</a></h1>
<h2 id="treetop-tree-house"><a class="header" href="#treetop-tree-house">Treetop Tree House</a></h2>
<p>The expedition comes across a peculiar patch of tall trees all planted carefully in a grid. The Elves explain that a previous expedition planted these trees as a reforestation effort. Now, they're curious if this would be a good location for a tree house.</p>
<p>First, determine whether there is enough tree cover here to keep a tree house <strong>hidden</strong>. To do this, you need to count the number of trees that are <strong>visible from outside the grid</strong> when looking directly along a row or column.</p>
<p>The Elves have already launched a quadcopter to generate a map with the height of each tree (your puzzle input). For example:</p>
<pre><code>30373
25512
65332
33549
35390
</code></pre>
<p>Each tree is represented as a single digit whose value is its height, where <code>0</code> is the shortest and <code>9</code> is the tallest.</p>
<p>A tree is <strong>visible</strong> if all of the other trees between it and an edge of the grid are <strong>shorter</strong> than it. Only consider trees in the same row or column; that is, only look up, down, left, or right from any given tree.</p>
<p>All of the trees around the edge of the grid are <strong>visible</strong> - since they are already on the edge, there are no trees to block the view. In this example, that accounts for 16 trees.</p>
<p>Consider the middle 5:</p>
<ul>
<li>The top-left 5 is <strong>visible</strong> from the left and top. (It isn't visible from the right or bottom since other trees of height 5 are in the way.)</li>
<li>The top-middle 5 is <strong>visible</strong> from the top and right.</li>
<li>The top-right 1 is not visible from any direction; for it to be visible, there would need to be only trees of height 0 between it and an edge.</li>
<li>The left-middle 5 is <strong>visible</strong>, but only from the right.</li>
<li>The center 3 is not visible from any direction; for it to be visible, there would need to be only trees of at most height 2 between it and an edge.</li>
</ul>
<p>In total, in this example, <strong>21</strong> trees are visible from outside the grid.</p>
<h2 id="part-1-7"><a class="header" href="#part-1-7">Part 1</a></h2>
<p>Consider your map; <strong>how many trees are visible from outside the grid?</strong></p>
<h2 id="part-2-7"><a class="header" href="#part-2-7">Part 2</a></h2>
<p>Content with the amount of tree cover available, the Elves just need to know the best spot to build their tree house: they would like to be able to see a lot of <strong>trees</strong>.</p>
<p>To measure the viewing distance from a given tree, look up, down, left, and right from that tree; stop if you reach an edge or at the first tree that is the same height or taller than the tree under consideration. (If a tree is right on the edge, at least one of its viewing distances will be zero.)</p>
<p>The Elves don't care about distant trees taller than those found by the rules above; the proposed tree house has large eaves to keep it dry, so they wouldn't be able to see higher than the tree house anyway.</p>
<p>In the example above, consider the middle 5 in the second row:</p>
<pre><code>30373
25512
65332
33549
35390
</code></pre>
<ul>
<li>Looking up, its view is not blocked; it can see <strong>1</strong> tree (of height 3).</li>
<li>Looking left, its view is blocked immediately; it can see only <strong>1</strong> tree (of height 5, right next to it).</li>
<li>Looking right, its view is not blocked; it can see <strong>2</strong> trees.</li>
<li>Looking down, its view is blocked eventually; it can see <strong>2</strong> trees (one of height 3, then the tree of height 5 that blocks its view).</li>
</ul>
<p>A tree's <strong>scenic score</strong> is found by <strong>multiplying together</strong> its viewing distance in each of the four directions. For this tree, this is <strong>4</strong> (1 * 1 * 2 * 2).</p>
<p>However, you can do even better: consider the tree of height 5 in the middle of the fourth row:</p>
<pre><code>30373
25512
65332
33549
35390
</code></pre>
<ul>
<li>Looking up, its view is blocked at <strong>2</strong> trees (by another tree with a height of 5).</li>
<li>Looking left, its view is not blocked; it can see <strong>2</strong> trees.</li>
<li>Looking down, its view is also not blocked; it can see <strong>1</strong> tree.</li>
<li>Looking right, its view is blocked at <strong>2</strong> trees (by a massive tree of height 9).</li>
</ul>
<p>This tree's scenic score is <strong>8</strong> (2 * 2 * 1 * 2).</p>
<p>Consider each tree on your map. <strong>What is the highest scenic score possible for any tree?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-8-solution-explanation"><a class="header" href="#day-8-solution-explanation">Day 8: Solution Explanation</a></h1>
<h2 id="approach-7"><a class="header" href="#approach-7">Approach</a></h2>
<p>Day 8 involves analyzing a grid of trees to determine visibility and scenic scores. The solution breaks down into two main parts:</p>
<ol>
<li><strong>Visibility Analysis</strong>: Determine which trees are visible from outside the grid</li>
<li><strong>Scenic Score Calculation</strong>: Calculate the scenic score for each tree and find the maximum</li>
</ol>
<p>The key to solving both parts efficiently is to create appropriate data structures and algorithms for scanning the grid in different directions.</p>
<h2 id="implementation-details-7"><a class="header" href="#implementation-details-7">Implementation Details</a></h2>
<h3 id="core-data-structures"><a class="header" href="#core-data-structures">Core Data Structures</a></h3>
<h4 id="coordinates"><a class="header" href="#coordinates">Coordinates</a></h4>
<p>First, the solution defines a <code>Coord</code> struct to represent positions in the grid:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug,Copy, Clone)]
struct Coord {
    x: usize,
    y: usize
}
impl From&lt;(usize,usize)&gt; for Coord {
    fn from(p: (usize, usize)) -&gt; Self {
        Coord { x:p.0, y:p.1 }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This provides a clean way to handle grid positions and includes a convenient conversion from tuples.</p>
<h4 id="grid-structure"><a class="header" href="#grid-structure">Grid Structure</a></h4>
<p>The core of the solution is a generic <code>Grid&lt;T&gt;</code> structure that can store any type of data in a 2D grid:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Grid&lt;T&gt; {
    width: usize,
    height: usize,
    grid: Vec&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The grid is stored as a flat vector for efficiency, with methods to access elements by coordinates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn tree(&amp;self, p: Coord) -&gt; Option&lt;&amp;T&gt; {
    if !self.in_bounds(p) {
        return None
    }
    Some(&amp;self.grid[p.y * self.width + p.x])
}
<span class="boring">}</span></code></pre></pre>
<h3 id="visibility-analysis"><a class="header" href="#visibility-analysis">Visibility Analysis</a></h3>
<p>The visibility analysis is handled by the <code>Visibility</code> struct, which keeps track of which trees are visible:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Visibility&lt;'a&gt; {
    forest: &amp;'a Grid&lt;i32&gt;,       // Reference to the forest grid
    visible: Grid&lt;bool&gt;,         // Grid tracking visible trees
}
<span class="boring">}</span></code></pre></pre>
<p>The key method is <code>scan_visibility</code>, which processes a sequence of coordinates in a given direction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scan_visibility(&amp;mut self, direction: ScanSequence) -&gt; &amp;mut Self {
    direction.into_iter()
        .for_each(|pos| {
            let mut tallest = -1;
            pos.into_iter().for_each(|e| {
                let tree = self.visible.tree_mut(e).unwrap();
                let t= self.forest.tree(e).unwrap();
                if tallest.lt(t) {
                    tallest = *t;
                    *tree = true;
                }
            });
        });
    self
}
<span class="boring">}</span></code></pre></pre>
<p>This method:</p>
<ol>
<li>Takes a sequence of coordinate sequences (representing scan lines)</li>
<li>For each scan line, tracks the tallest tree seen so far</li>
<li>Marks trees as visible if they're taller than all previous trees in the scan line</li>
</ol>
<p>By calling this method with scan sequences from all four directions (left-to-right, right-to-left, top-to-bottom, bottom-to-top), we can determine all visible trees.</p>
<h3 id="scenic-score-calculation"><a class="header" href="#scenic-score-calculation">Scenic Score Calculation</a></h3>
<p>The scenic score calculation is handled by the <code>Scenic</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Scenic&lt;'a&gt; {
    forest: &amp;'a Grid&lt;i32&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The main methods are:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scenic_score_dir(&amp;mut self, p:Coord, (dx,dy):(isize,isize)) -&gt; usize {
    let line = (1..).map_while(|i| {
        let coord = Coord {
            x: p.x.checked_add_signed(dx * i)?,
            y: p.y.checked_add_signed(dy * i)?,
        };
        self.forest.tree(coord)
    });

    let mut total = 0;
    let our_height = self.forest.tree(p).unwrap();
    for height in line {
        total += 1;
        if height &gt;= our_height {
            break;
        }
    }
    total
}

fn scenic_score(&amp;mut self, p: Coord) -&gt; usize {
    let dirs =  [(-1, 0), (1, 0), (0, -1), (0, 1)];
    dirs.into_iter()
        .map(|dir| self.scenic_score_dir(p,dir) )
        .product()
}
<span class="boring">}</span></code></pre></pre>
<p>These methods:</p>
<ol>
<li>Calculate the viewing distance in a specific direction using <code>scenic_score_dir</code></li>
<li>Combine the viewing distances in all four directions using <code>scenic_score</code></li>
</ol>
<p>The viewing distance calculation uses an infinite iterator with <code>map_while</code> to look in a specific direction until it reaches the edge or a blocking tree.</p>
<h3 id="generating-scan-sequences"><a class="header" href="#generating-scan-sequences">Generating Scan Sequences</a></h3>
<p>To scan the grid in different directions, the solution defines helper functions that generate sequences of coordinates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn left_to_right(f: &amp;Grid&lt;i32&gt;) -&gt; ScanSequence {
    (0..f.height)
        .map(|y| (0..f.width).map(move |x| (x, y).into()).collect::&lt;Vec&lt;Coord&gt;&gt;() )
        .collect::&lt;Vec&lt;_&gt;&gt;()
}

fn right_to_left(f: &amp;Grid&lt;i32&gt;) -&gt; ScanSequence {
    (0..f.height)
        .map(|y| (0..f.width).rev().map(move |x| (x, y).into()).collect::&lt;Vec&lt;Coord&gt;&gt;() )
        .collect::&lt;Vec&lt;_&gt;&gt;()
}

// Similar functions for top_to_bottom and bottom_to_up
<span class="boring">}</span></code></pre></pre>
<p>Each function generates a sequence of scan lines, where each scan line is a sequence of coordinates.</p>
<h3 id="parsing-the-input-3"><a class="header" href="#parsing-the-input-3">Parsing the Input</a></h3>
<p>The input is parsed into a grid of tree heights:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_forest(data: &amp;str) -&gt; Grid&lt;i32&gt;  {
    let width = data.lines().next().unwrap().len();
    let height = data.lines().count();
    let mut grid = Grid::new(width,height);

    for (y,line) in data.lines().enumerate() {
        for (x, val) in line.bytes().enumerate() {
            *grid.tree_mut((x,y).into()).unwrap() = (val - b'0') as i32;
        }
    }
    grid
}
<span class="boring">}</span></code></pre></pre>
<p>This converts each digit character to an integer height value.</p>
<h3 id="main-solution-1"><a class="header" href="#main-solution-1">Main Solution</a></h3>
<p>The main solution flow is:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let data = std::fs::read_to_string("src/bin/day8_input.txt").expect("Ops!");
    let grid = parse_forest(data.as_str());

    // Part 1: Count visible trees
    let count = Visibility::new(&amp;grid)
        .scan_visibility(left_to_right(&amp;grid))
        .scan_visibility(top_to_bottom(&amp;grid))
        .scan_visibility(right_to_left(&amp;grid))
        .scan_visibility(bottom_to_up(&amp;grid))
        .count_visible();
    println!("Total Visible = {:?}", count);

    // Part 2: Find maximum scenic score
    let mut scenic = Scenic::new(&amp;grid);
    let max = left_to_right(&amp;grid).into_iter()
        .flat_map(|x| x)
        .map(|p| scenic.scenic_score(p))
        .max().unwrap();
    println!("Max scenic = {:?}", max);
}</code></pre></pre>
<p>For Part 1, it scans the grid from all four directions and counts the visible trees. For Part 2, it calculates the scenic score for every tree and finds the maximum.</p>
<h2 id="algorithm-analysis-1"><a class="header" href="#algorithm-analysis-1">Algorithm Analysis</a></h2>
<h3 id="time-complexity-3"><a class="header" href="#time-complexity-3">Time Complexity</a></h3>
<ul>
<li><strong>Visibility Analysis</strong>: O(nÂ²) where n is the grid dimension (width or height), as we scan each cell in each direction</li>
<li><strong>Scenic Score Calculation</strong>: O(nÂ³) in the worst case, as for each of the nÂ² cells we might need to look n steps in each direction</li>
</ul>
<h3 id="space-complexity-3"><a class="header" href="#space-complexity-3">Space Complexity</a></h3>
<ul>
<li><strong>Grid Storage</strong>: O(nÂ²) to store the forest grid and visibility grid</li>
<li><strong>Scan Sequences</strong>: O(nÂ²) to store the coordinate sequences</li>
</ul>
<h2 id="alternative-approaches-6"><a class="header" href="#alternative-approaches-6">Alternative Approaches</a></h2>
<h3 id="single-pass-visibility-check"><a class="header" href="#single-pass-visibility-check">Single-Pass Visibility Check</a></h3>
<p>For the visibility check, an alternative approach would be to use dynamic programming to precompute the maximum height seen from each direction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Precompute maximum heights from left
let mut max_left = vec![vec![-1; width]; height];
for y in 0..height {
    for x in 0..width {
        if x &gt; 0 {
            max_left[y][x] = max(max_left[y][x-1], grid[y][x-1]);
        }
    }
}
// Similar for other directions

// Check visibility
for y in 0..height {
    for x in 0..width {
        if grid[y][x] &gt; max_left[y][x] || grid[y][x] &gt; max_right[y][x] || 
           grid[y][x] &gt; max_top[y][x] || grid[y][x] &gt; max_bottom[y][x] {
            visible[y][x] = true;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This would have the same asymptotic complexity but might be faster in practice due to better cache locality.</p>
<h3 id="optimized-scenic-score-calculation"><a class="header" href="#optimized-scenic-score-calculation">Optimized Scenic Score Calculation</a></h3>
<p>For the scenic score calculation, we could optimize by precomputing the viewing distance in each direction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut view_distance = vec![vec![(0, 0, 0, 0); width]; height];

// Compute left viewing distances
for y in 0..height {
    let mut last_height = vec![0; 10];
    for x in 0..width {
        let h = grid[y][x] as usize;
        view_distance[y][x].0 = x - *last_height[..=h].iter().max().unwrap_or(&amp;0);
        last_height[h] = x;
    }
}
// Similar for other directions
<span class="boring">}</span></code></pre></pre>
<p>This would reduce the time complexity to O(nÂ²), but would be more complex to implement.</p>
<h2 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h2>
<p>This solution demonstrates how to efficiently work with 2D grids and perform directional scanning operations. The use of custom data structures for coordinates and grids makes the code clean and maintainable, while the separation of visibility analysis and scenic score calculation into different structs keeps the code organized.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-8-code"><a class="header" href="#day-8-code">Day 8: Code</a></h1>
<p>Below is the complete code for Day 8's solution, which analyzes a grid of trees to determine visibility and scenic scores.</p>
<h2 id="full-solution-7"><a class="header" href="#full-solution-7">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">
type ScanSequence = Vec&lt;Vec&lt;Coord&gt;&gt;;

#[derive(Debug,Copy, Clone)]
struct Coord {
    x: usize,
    y: usize
}
impl From&lt;(usize,usize)&gt; for Coord {
    fn from(p: (usize, usize)) -&gt; Self {
        Coord { x:p.0, y:p.1 }
    }
}

#[derive(Debug)]
struct Grid&lt;T&gt; {
    width: usize,
    height: usize,
    grid: Vec&lt;T&gt;,
}
impl&lt;T&gt; Grid&lt;T&gt; where T : Default + Copy {
    fn new(height: usize, width: usize) -&gt; Grid&lt;T&gt; {
        Grid {
            height,
            width,
            grid: vec![T::default(); width * height]
        }
    }
    fn in_bounds(&amp;self, p:Coord) -&gt; bool {
        p.x &lt; self.width &amp;&amp; p.y &lt; self.height
    }
    fn tree(&amp;self, p: Coord) -&gt; Option&lt;&amp;T&gt; {
        if !self.in_bounds(p) {
            return None
        }
        Some(&amp;self.grid[p.y * self.width + p.x])
    }
    fn tree_mut(&amp;mut self, p: Coord) -&gt; Option&lt;&amp;mut T&gt; {
        if !self.in_bounds(p) {
            return None
        }
        Some(&amp;mut self.grid[p.y * self.width + p.x])
    }
}

#[derive(Debug)]
struct Visibility&lt;'a&gt; {
    forest: &amp;'a Grid&lt;i32&gt;,
    visible: Grid&lt;bool&gt;,
}
impl Visibility&lt;'_&gt; {
    fn new(forest: &amp;Grid&lt;i32&gt;) -&gt; Visibility {
        Visibility {
            forest,
            visible: Grid::new(forest.width, forest.height),
        }
    }
    fn count_visible(&amp;self) -&gt; usize {
        self.visible.grid.iter()
            .filter(|&amp;e| *e)
            .count()
    }
    fn scan_visibility(&amp;mut self, direction: ScanSequence) -&gt; &amp;mut Self {
        direction.into_iter()
            .for_each(|pos| {
                let mut tallest = -1;
                pos.into_iter().for_each(|e| {
                    let tree = self.visible.tree_mut(e).unwrap();
                    let t= self.forest.tree(e).unwrap();
                    if tallest.lt(t) {
                        tallest = *t;
                        *tree = true;
                    }
                });
            });
        self
    }
}
#[derive(Debug)]
struct Scenic&lt;'a&gt; {
    forest: &amp;'a Grid&lt;i32&gt;,
    // scenic: Grid&lt;usize&gt;
}
impl Scenic&lt;'_&gt; {
    fn new(forest: &amp;Grid&lt;i32&gt;) -&gt; Scenic {
        Scenic { forest }
    }
    fn scenic_score_dir(&amp;mut self, p:Coord, (dx,dy):(isize,isize)) -&gt; usize {
        let line = (1..).map_while(|i| {
            let coord = Coord {
                x: p.x.checked_add_signed(dx * i)?,
                y: p.y.checked_add_signed(dy * i)?,
            };
            self.forest.tree(coord)
        });

        let mut total = 0;
        let our_height = self.forest.tree(p).unwrap();
        for height in line {
            total += 1;
            if height &gt;= our_height {
                break;
            }
        }
        total

    }
    fn scenic_score(&amp;mut self, p: Coord) -&gt; usize {
        let dirs =  [(-1, 0), (1, 0), (0, -1), (0, 1)];
        dirs.into_iter()
            .map(|dir| self.scenic_score_dir(p,dir) )
            .product()
    }
}

fn main() {
    // let data = "30373\n25512\n65332\n33549\n35390".to_string();
    let data = std::fs::read_to_string("src/bin/day8_input.txt").expect("Ops!");

    let grid = parse_forest(data.as_str());

    let count = Visibility::new(&amp;grid)
        .scan_visibility(left_to_right(&amp;grid))
        .scan_visibility(top_to_bottom(&amp;grid))
        .scan_visibility(right_to_left(&amp;grid))
        .scan_visibility(bottom_to_up(&amp;grid))
        .count_visible();
    println!("Total Visible = {:?}", count);

    let mut scenic = Scenic::new(&amp;grid);
    let max = left_to_right(&amp;grid).into_iter()
        .flat_map(|x| x)
        .map(|p| scenic.scenic_score(p))
        .max().unwrap();
    println!("Max scenic = {:?}", max);
}

fn parse_forest(data: &amp;str) -&gt; Grid&lt;i32&gt;  {
    let width = data.lines().next().unwrap().len();
    let height = data.lines().count();
    let mut grid = Grid::new(width,height);

    for (y,line) in data.lines().enumerate() {
        for (x, val) in line.bytes().enumerate() {
            *grid.tree_mut((x,y).into()).unwrap() = (val - b'0') as i32;
        }
    }
    grid
}

fn left_to_right(f: &amp;Grid&lt;i32&gt;) -&gt; ScanSequence {
    (0..f.height)
        .map(|y| (0..f.width).map(move |x| (x, y).into()).collect::&lt;Vec&lt;Coord&gt;&gt;() )
        .collect::&lt;Vec&lt;_&gt;&gt;()
}
fn right_to_left(f: &amp;Grid&lt;i32&gt;) -&gt; ScanSequence {
    (0..f.height)
        .map(|y| (0..f.width).rev().map(move |x| (x, y).into()).collect::&lt;Vec&lt;Coord&gt;&gt;() )
        .collect::&lt;Vec&lt;_&gt;&gt;()
}
fn top_to_bottom(f: &amp;Grid&lt;i32&gt;) -&gt; ScanSequence {
    (0..f.width)
        .map(|x| (0..f.height).map(move |y| (x,y).into()).collect::&lt;Vec&lt;Coord&gt;&gt;() )
        .collect::&lt;Vec&lt;_&gt;&gt;()
}
fn bottom_to_up(f: &amp;Grid&lt;i32&gt;) -&gt; ScanSequence {
    (0..f.width)
        .map(|x| (0..f.height).rev().map(move |y| (x,y).into()).collect::&lt;Vec&lt;Coord&gt;&gt;() )
        .collect::&lt;Vec&lt;_&gt;&gt;()
}</code></pre>
<h2 id="code-walkthrough-7"><a class="header" href="#code-walkthrough-7">Code Walkthrough</a></h2>
<h3 id="core-data-structures-1"><a class="header" href="#core-data-structures-1">Core Data Structures</a></h3>
<h4 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate System</a></h4>
<pre><code class="language-rust no_run noplayground">#[derive(Debug,Copy, Clone)]
struct Coord {
    x: usize,
    y: usize
}
impl From&lt;(usize,usize)&gt; for Coord {
    fn from(p: (usize, usize)) -&gt; Self {
        Coord { x:p.0, y:p.1 }
    }
}</code></pre>
<p>The <code>Coord</code> struct represents a position in the grid with x and y coordinates. The <code>From&lt;(usize,usize)&gt;</code> implementation allows easy conversion from coordinate tuples.</p>
<h4 id="grid-implementation"><a class="header" href="#grid-implementation">Grid Implementation</a></h4>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
struct Grid&lt;T&gt; {
    width: usize,
    height: usize,
    grid: Vec&lt;T&gt;,
}
impl&lt;T&gt; Grid&lt;T&gt; where T : Default + Copy {
    fn new(height: usize, width: usize) -&gt; Grid&lt;T&gt; {
        Grid {
            height,
            width,
            grid: vec![T::default(); width * height]
        }
    }
    fn in_bounds(&amp;self, p:Coord) -&gt; bool {
        p.x &lt; self.width &amp;&amp; p.y &lt; self.height
    }
    fn tree(&amp;self, p: Coord) -&gt; Option&lt;&amp;T&gt; {
        if !self.in_bounds(p) {
            return None
        }
        Some(&amp;self.grid[p.y * self.width + p.x])
    }
    fn tree_mut(&amp;mut self, p: Coord) -&gt; Option&lt;&amp;mut T&gt; {
        if !self.in_bounds(p) {
            return None
        }
        Some(&amp;mut self.grid[p.y * self.width + p.x])
    }
}</code></pre>
<p>The <code>Grid&lt;T&gt;</code> struct is a generic container that stores a 2D grid as a flat vector. It provides methods for:</p>
<ul>
<li>Creating a new grid with default values</li>
<li>Checking if coordinates are within bounds</li>
<li>Accessing grid elements by coordinates (both immutably and mutably)</li>
</ul>
<h3 id="visibility-analysis-1"><a class="header" href="#visibility-analysis-1">Visibility Analysis</a></h3>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
struct Visibility&lt;'a&gt; {
    forest: &amp;'a Grid&lt;i32&gt;,
    visible: Grid&lt;bool&gt;,
}
impl Visibility&lt;'_&gt; {
    fn new(forest: &amp;Grid&lt;i32&gt;) -&gt; Visibility {
        Visibility {
            forest,
            visible: Grid::new(forest.width, forest.height),
        }
    }
    fn count_visible(&amp;self) -&gt; usize {
        self.visible.grid.iter()
            .filter(|&amp;e| *e)
            .count()
    }
    fn scan_visibility(&amp;mut self, direction: ScanSequence) -&gt; &amp;mut Self {
        direction.into_iter()
            .for_each(|pos| {
                let mut tallest = -1;
                pos.into_iter().for_each(|e| {
                    let tree = self.visible.tree_mut(e).unwrap();
                    let t= self.forest.tree(e).unwrap();
                    if tallest.lt(t) {
                        tallest = *t;
                        *tree = true;
                    }
                });
            });
        self
    }
}</code></pre>
<p>The <code>Visibility</code> struct manages determining which trees are visible:</p>
<ul>
<li>It keeps a reference to the forest grid and a boolean grid to track visibility</li>
<li><code>count_visible()</code> counts the number of visible trees</li>
<li><code>scan_visibility()</code> scans along provided coordinate sequences, marking trees as visible if they're taller than all previous trees in the scan</li>
</ul>
<h3 id="scenic-score-calculation-1"><a class="header" href="#scenic-score-calculation-1">Scenic Score Calculation</a></h3>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
struct Scenic&lt;'a&gt; {
    forest: &amp;'a Grid&lt;i32&gt;,
    // scenic: Grid&lt;usize&gt;
}
impl Scenic&lt;'_&gt; {
    fn new(forest: &amp;Grid&lt;i32&gt;) -&gt; Scenic {
        Scenic { forest }
    }
    fn scenic_score_dir(&amp;mut self, p:Coord, (dx,dy):(isize,isize)) -&gt; usize {
        let line = (1..).map_while(|i| {
            let coord = Coord {
                x: p.x.checked_add_signed(dx * i)?,
                y: p.y.checked_add_signed(dy * i)?,
            };
            self.forest.tree(coord)
        });

        let mut total = 0;
        let our_height = self.forest.tree(p).unwrap();
        for height in line {
            total += 1;
            if height &gt;= our_height {
                break;
            }
        }
        total

    }
    fn scenic_score(&amp;mut self, p: Coord) -&gt; usize {
        let dirs =  [(-1, 0), (1, 0), (0, -1), (0, 1)];
        dirs.into_iter()
            .map(|dir| self.scenic_score_dir(p,dir) )
            .product()
    }
}</code></pre>
<p>The <code>Scenic</code> struct handles calculating scenic scores:</p>
<ul>
<li><code>scenic_score_dir()</code> calculates the viewing distance in a specific direction using an iterator that continues until it reaches the edge or a blocking tree</li>
<li><code>scenic_score()</code> combines the viewing distances in all four directions by multiplying them together</li>
</ul>
<h3 id="direction-scanning-utilities"><a class="header" href="#direction-scanning-utilities">Direction Scanning Utilities</a></h3>
<pre><code class="language-rust no_run noplayground">fn parse_forest(data: &amp;str) -&gt; Grid&lt;i32&gt;  {
    let width = data.lines().next().unwrap().len();
    let height = data.lines().count();
    let mut grid = Grid::new(width,height);

    for (y,line) in data.lines().enumerate() {
        for (x, val) in line.bytes().enumerate() {
            *grid.tree_mut((x,y).into()).unwrap() = (val - b'0') as i32;
        }
    }
    grid
}

fn left_to_right(f: &amp;Grid&lt;i32&gt;) -&gt; ScanSequence {
    (0..f.height)
        .map(|y| (0..f.width).map(move |x| (x, y).into()).collect::&lt;Vec&lt;Coord&gt;&gt;() )
        .collect::&lt;Vec&lt;_&gt;&gt;()
}
fn right_to_left(f: &amp;Grid&lt;i32&gt;) -&gt; ScanSequence {
    (0..f.height)
        .map(|y| (0..f.width).rev().map(move |x| (x, y).into()).collect::&lt;Vec&lt;Coord&gt;&gt;() )
        .collect::&lt;Vec&lt;_&gt;&gt;()
}
fn top_to_bottom(f: &amp;Grid&lt;i32&gt;) -&gt; ScanSequence {
    (0..f.width)
        .map(|x| (0..f.height).map(move |y| (x,y).into()).collect::&lt;Vec&lt;Coord&gt;&gt;() )
        .collect::&lt;Vec&lt;_&gt;&gt;()
}
fn bottom_to_up(f: &amp;Grid&lt;i32&gt;) -&gt; ScanSequence {
    (0..f.width)
        .map(|x| (0..f.height).rev().map(move |y| (x,y).into()).collect::&lt;Vec&lt;Coord&gt;&gt;() )
        .collect::&lt;Vec&lt;_&gt;&gt;()
}</code></pre>
<p>These utility functions generate coordinate sequences for scanning the grid in different directions:</p>
<ul>
<li><code>left_to_right</code>: Scans each row from left to right</li>
<li><code>right_to_left</code>: Scans each row from right to left</li>
<li><code>top_to_bottom</code>: Scans each column from top to bottom</li>
<li><code>bottom_to_up</code>: Scans each column from bottom to top</li>
</ul>
<h3 id="main-function-and-input-parsing"><a class="header" href="#main-function-and-input-parsing">Main Function and Input Parsing</a></h3>
<pre><code class="language-rust no_run noplayground">fn main() {
    // let data = "30373\n25512\n65332\n33549\n35390".to_string();
    let data = std::fs::read_to_string("src/bin/day8_input.txt").expect("Ops!");

    let grid = parse_forest(data.as_str());

    let count = Visibility::new(&amp;grid)
        .scan_visibility(left_to_right(&amp;grid))
        .scan_visibility(top_to_bottom(&amp;grid))
        .scan_visibility(right_to_left(&amp;grid))
        .scan_visibility(bottom_to_up(&amp;grid))
        .count_visible();
    println!("Total Visible = {:?}", count);

    let mut scenic = Scenic::new(&amp;grid);
    let max = left_to_right(&amp;grid).into_iter()
        .flat_map(|x| x)
        .map(|p| scenic.scenic_score(p))
        .max().unwrap();
    println!("Max scenic = {:?}", max);
}
</code></pre>
<p>The main function:</p>
<ol>
<li>Reads the input file</li>
<li>Parses it into a grid</li>
<li>For Part 1: Scans the grid from all four directions and counts the visible trees</li>
<li>For Part 2: Calculates the scenic score for every tree and finds the maximum</li>
</ol>
<p>The <code>parse_forest</code> function converts the input string into a grid of tree heights.</p>
<h2 id="implementation-notes-6"><a class="header" href="#implementation-notes-6">Implementation Notes</a></h2>
<ul>
<li><strong>Generic Grid</strong>: The solution uses a generic grid implementation that can store any type of data, making it flexible for different use cases</li>
<li><strong>Fluent Interface</strong>: The visibility scanning uses a fluent interface with method chaining for concise code</li>
<li><strong>Iterator Usage</strong>: The solution makes extensive use of iterators, including infinite iterators with <code>map_while</code> for clean, efficient code</li>
<li><strong>Coordinate Handling</strong>: The custom <code>Coord</code> type with <code>From</code> trait implementation makes coordinate handling safer and more expressive</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-9-rope-bridge"><a class="header" href="#day-9-rope-bridge">Day 9: Rope Bridge</a></h1>
<p>Day 9 involves simulating the motion of a rope with multiple knots based on a series of movement commands.</p>
<h2 id="problem-overview-8"><a class="header" href="#problem-overview-8">Problem Overview</a></h2>
<p>You're crossing a rope bridge but need to model the rope's movement. The rope consists of a series of knots connected in a line. When the head knot moves, the other knots follow according to specific rules. Your task is to:</p>
<ol>
<li>Track the motion of a rope with 2 knots (Part 1)</li>
<li>Track the motion of a rope with 10 knots (Part 2)</li>
<li>Count the number of unique positions the tail knot visits</li>
</ol>
<p>This problem tests your ability to simulate physical constraints and track positional state across a sequence of moves.</p>
<h2 id="navigation-8"><a class="header" href="#navigation-8">Navigation</a></h2>
<ul>
<li><a href="day9/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day9/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day9/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-9-problem-description"><a class="header" href="#day-9-problem-description">Day 9: Problem Description</a></h1>
<h2 id="rope-bridge"><a class="header" href="#rope-bridge">Rope Bridge</a></h2>
<p>This rope bridge creaks as you walk along it. You aren't sure how old it is, or whether it can even support your weight. It seems to support the Elves just fine, though.</p>
<p>The bridge is a series of planks connected by rope. It doesn't have any guardrails, which is a bit concerning given how many Elves have already fallen into the river. You decide to distract yourself by modeling how the ropes move as you cross the bridge.</p>
<p>The bridge is made entirely of rope, with the poses connected end-to-end. The first pose is secured to a large tree, and the last pose is holding a big bag of supplies. A single rope connects each pose in the bridge. The ropes form a physical constraint: every rope segment wants to stay straight, and if a rope is pulled taught then the next rope segment in the chain will also be pulled in that direction (unless it's constrained in some other way).</p>
<p>The Elves want to know where the bag of supplies might end up. To simulate the ropes, you will need to keep track of the <strong>head</strong> (the first pose) and the <strong>tail</strong> (the last pose). If the head is ever two steps directly up, down, left, or right from the tail, the tail must move one step in that direction so it remains close enough. Otherwise, if the head and tail aren't touching and aren't in the same row or column, the tail always moves one step diagonally to keep up.</p>
<p>You'll need to keep track of positions the tail visited at least once. For now, you should model the positions of the knots after each step. Then, you can count the positions the <strong>tail</strong> visited at least once.</p>
<p>For example:</p>
<pre><code>R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2
</code></pre>
<p>This series of motions moves the head <strong>right</strong> four steps, then <strong>up</strong> four steps, then <strong>left</strong> three steps, then <strong>down</strong> one step, and so on. After each step, you'll need to update the position of the tail if the head and tail aren't touching. Visually, these motions occur as follows (s marks the starting position as a reference point):</p>
<pre><code>== Initial State ==

......
......
......
......
..H...  (H covers T, s)

== R 4 ==

......
......
......
......
..TH..  (T covers s)

......
......
......
......
..TH..  (T covers s)

......
......
......
......
...TH.  (T covers s)

......
......
......
......
....TH  (T covers s)

== U 4 ==

......
......
......
....H.
....T.  (T covers s)

......
......
....H.
....T.
......  (T covers s)

......
....H.
....T.
......
......  (T covers s)

....H.
....T.
......
......
......  (T covers s)

== L 3 ==

...H..
....T.
......
......
......  (T covers s)

..H...
...T..
......
......
......  (T covers s)

.H....
..T...
......
......
......  (T covers s)

== D 1 ==

..H...
..T...
......
......
......  (T covers s)

== R 4 ==

...H..
..T...
......
......
......  (T covers s)

....H.
...T..
......
......
......  (T covers s)

.....H
....T.
......
......
......  (T covers s)

......
.....H
....T.
......
......  (T covers s)

== D 1 ==

......
......
.....H
....T.
......  (T covers s)

== L 5 ==

......
......
....H.
....T.
......  (T covers s)

......
......
...H..
....T.
......  (T covers s)

......
......
..H...
...T..
......  (T covers s)

......
......
.H....
..T...
......  (T covers s)

......
......
H.....
.T....
......  (T covers s)

== R 2 ==

......
......
.H....
.T....
......  (T covers s)

......
......
..H...
.T....
......  (T covers s)
</code></pre>
<p>After simulating the rope, you can count up all of the positions the <strong>tail</strong> visited at least once. In this diagram, s again marks the starting position (which the tail also visited) and # marks other positions the tail visited:</p>
<pre><code>..##..
...##.
.####.
....#.
...s#.
</code></pre>
<p>So, there are <strong>13</strong> positions the tail visited at least once.</p>
<h2 id="part-1-8"><a class="header" href="#part-1-8">Part 1</a></h2>
<p>Simulate your complete hypothetical series of motions. <strong>How many positions does the tail of the rope visit at least once?</strong></p>
<h2 id="part-2-8"><a class="header" href="#part-2-8">Part 2</a></h2>
<p>A rope snaps! Suddenly, the river is getting a lot closer than you remember. The bridge is still there, but some of the ropes that broke are now whipping toward you as you fall through the air!</p>
<p>The ropes are moving too quickly to grab; you only have a few seconds to choose how to arch your body to avoid being hit. Fortunately, your simulation can be extended to support longer ropes.</p>
<p>Rather than two knots, you now must simulate a rope consisting of <strong>ten</strong> knots. One knot is still the head of the rope and moves according to the series of motions. Each knot further down the rope follows the knot in front of it using the same rules as before.</p>
<p>Using the same series of motions as the above example, but with the knots marked H, 1, 2, ..., 9, the motions now occur as follows:</p>
<pre><code>== Initial State ==

......
......
......
......
H.....  (H covers 1, 2, 3, 4, 5, 6, 7, 8, 9, s)

== R 4 ==

......
......
......
......
H123..  (9 covers s)

......
......
......
......
.H123.  (9 covers s)

......
......
......
......
..H123  (9 covers s)

......
......
......
......
...H123  (9 covers s)

== U 4 ==

......
......
......
....H..
....1..
....2..
....3..
....4..
....5..
....6..
....7..
....8..
....9..  (9 covers s)

== L 3 ==

// ... continued visualization omitted for brevity ...
</code></pre>
<p>Now, you need to keep track of the positions the new tail (knot 9) visits. In this example, the tail never moves far enough to leave a # in the visualized grid, but if you count the positions the tail visits at least once, you still get <strong>1</strong>. (You may want to try a different initial configuration to be sure.)</p>
<p>Let's try a larger example:</p>
<pre><code>R 5
U 8
L 8
D 3
R 17
D 10
L 25
U 20
</code></pre>
<p>These motions cause the head of the rope to move around quite a bit. Here is an illustration of the positions of the head (H) and the tail (9) after each of the first few steps:</p>
<pre><code>== Initial State ==
................
................
................
................
................
................
................
................
................
................
................
................
................
................
................
...............H  (H covers 1, 2, 3, 4, 5, 6, 7, 8, 9, s)

== R 5 ==
................
................
................
................
................
................
................
................
................
................
................
................
................
................
................
...............H  (H covers 1, 2, 3, 4, 5, 6, 7, 8, 9, s)

// ... continued visualization omitted for brevity ...
</code></pre>
<p>After simulating the rope, you can count up all of the positions the tail (knot 9) visited at least once. In this larger example, the tail visits <strong>36</strong> positions (including the position where it starts).</p>
<p><strong>Simulate your complete series of motions on a rope with ten knots. How many positions does the tail of the rope visit at least once?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-9-solution-explanation"><a class="header" href="#day-9-solution-explanation">Day 9: Solution Explanation</a></h1>
<h2 id="approach-8"><a class="header" href="#approach-8">Approach</a></h2>
<p>Day 9 involves simulating the motion of a rope with multiple knots. The solution breaks down into several key components:</p>
<ol>
<li><strong>Representing coordinates</strong>: We need a way to represent positions in 2D space</li>
<li><strong>Modeling the rope</strong>: We need to model a chain of connected knots</li>
<li><strong>Implementing movement rules</strong>: We need to implement how knots move in relation to each other</li>
<li><strong>Tracking unique positions</strong>: We need to track unique positions visited by the tail knot</li>
</ol>
<p>The solution uses a combination of custom data structures and simulation logic to model the rope's behavior.</p>
<h2 id="implementation-details-8"><a class="header" href="#implementation-details-8">Implementation Details</a></h2>
<h3 id="coordinate-system-1"><a class="header" href="#coordinate-system-1">Coordinate System</a></h3>
<p>First, we define a <code>Coord</code> struct to represent positions in 2D space:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
struct Coord {
    x: isize,
    y: isize
}
<span class="boring">}</span></code></pre></pre>
<p>This struct includes several derived traits:</p>
<ul>
<li><code>Debug</code>, <code>Copy</code>, and <code>Clone</code> for convenience</li>
<li><code>PartialEq</code> and <code>Eq</code> for equality comparisons</li>
<li><code>Hash</code> to allow using coordinates as keys in a HashSet</li>
</ul>
<p>We also implement the <code>Sub</code> trait to make it easy to calculate the distance between two coordinates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Sub for Coord {
    type Output = Coord;

    fn sub(self, rhs: Self) -&gt; Self::Output {
        Coord {
            x: self.x - rhs.x,
            y: self.y - rhs.y,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And a conversion from tuples for convenience:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;(isize,isize)&gt; for Coord {
    fn from(pos: (isize, isize)) -&gt; Self {
        Coord{x:pos.0, y:pos.1}
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="movement-commands"><a class="header" href="#movement-commands">Movement Commands</a></h3>
<p>We define an enum to represent the four possible movement directions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone)]
enum Command {
    Left,
    Right,
    Up,
    Down
}
<span class="boring">}</span></code></pre></pre>
<p>And a struct to represent a movement step with a direction and distance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone)]
struct Step {
    cmd: Command,
    units: isize
}
<span class="boring">}</span></code></pre></pre>
<h3 id="modeling-rope-links"><a class="header" href="#modeling-rope-links">Modeling Rope Links</a></h3>
<p>Each knot in the rope is modeled as a <code>Link</code> that knows its position and how to move:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone)]
struct Link {
    pos: Coord
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Link</code> struct has methods for different types of movement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Link {
    fn new(pos:Coord) -&gt; Link {
        Link { pos }
    }
    
    // Move directly in a cardinal direction
    fn move_to(&amp;mut self, cmd: Command) -&gt; Coord {
        match cmd {
            Command::Left =&gt; self.pos.x -= 1,
            Command::Right =&gt; self.pos.x += 1,
            Command::Up =&gt; self.pos.y += 1,
            Command::Down =&gt; self.pos.y -= 1
        }
        self.position()
    }
    
    // Move relative to another link based on physical constraints
    fn move_relative(&amp;mut self, front: &amp;Link) -&gt; Coord {
        let dist = front.position() - self.position();
        let (dx,dy) = match (dist.x, dist.y) {
            // overlapping
            (0, 0) =&gt; (0, 0),
            // touching up/left/down/right
            (0, 1) | (1, 0) | (0, -1) | (-1, 0) =&gt; (0, 0),
            // touching diagonally
            (1, 1) | (1, -1) | (-1, 1) | (-1, -1) =&gt; (0, 0),
            // need to move up/left/down/right
            (0, 2) =&gt; (0, 1),
            (0, -2) =&gt; (0, -1),
            (2, 0) =&gt; (1, 0),
            (-2, 0) =&gt; (-1, 0),
            // need to move to the right diagonally
            (2, 1) =&gt; (1, 1),
            (2, -1) =&gt; (1, -1),
            // need to move to the left diagonally
            (-2, 1) =&gt; (-1, 1),
            (-2, -1) =&gt; (-1, -1),
            // need to move up/down diagonally
            (1, 2) =&gt; (1, 1),
            (-1, 2) =&gt; (-1, 1),
            (1, -2) =&gt; (1, -1),
            (-1, -2) =&gt; (-1, -1),
            // need to move diagonally
            (-2, -2) =&gt; (-1, -1),
            (-2, 2) =&gt; (-1, 1),
            (2, -2) =&gt; (1, -1),
            (2, 2) =&gt; (1, 1),
            _ =&gt; panic!("unhandled case: tail - head = {dist:?}"),
        };
        self.pos.x += dx;
        self.pos.y += dy;
        self.position()
    }
    
    fn position(&amp;self) -&gt; Coord {
        self.pos
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>move_relative</code> method is the heart of the solution. It implements the physical constraint that if a knot is too far from the knot in front of it, it must move to maintain proximity. The method calculates the relative position and then determines the appropriate movement using pattern matching.</p>
<h3 id="modeling-the-rope-chain"><a class="header" href="#modeling-the-rope-chain">Modeling the Rope Chain</a></h3>
<p>The entire rope is modeled as a chain of links:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Chain {
    links: Vec&lt;Link&gt;
}

impl Chain {
    fn new(pos:Coord, size:usize) -&gt; Chain {
        Chain {
            links: vec![Link::new(pos); size]
        }
    }
    
    fn move_to(&amp;mut self, cmd: Command) -&gt; Coord {
        self.links[0].move_to(cmd);
        self.links
            .iter_mut()
            .reduce(|front,tail|{
                tail.move_relative(front);
                tail
            })
            .unwrap()
            .position()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>move_to</code> method moves the head knot directly and then propagates the movement through the chain using <code>reduce</code>. This elegantly handles the chain of dependencies where each knot's movement depends on the knot in front of it.</p>
<h3 id="game-simulation"><a class="header" href="#game-simulation">Game Simulation</a></h3>
<p>The overall simulation is handled by the <code>Game</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    rope: Chain,
    unique: HashSet&lt;Coord&gt;
}

impl Game {
    fn new(rope: Chain) -&gt; Game {
        Game { rope, unique: HashSet::new() }
    }
    
    fn unique_positions(&amp;self) -&gt; usize {
        self.unique.len()
    }
    
    fn run(&amp;mut self, input: &amp;Vec&lt;Step&gt;) -&gt; &amp;Self{
        for step in input {
            (0..step.units).all(|_| {
                self.unique.insert(
                    self.rope.move_to(step.cmd)
                );
                true
            });
        }
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Game</code> struct:</p>
<ul>
<li>Manages the rope chain</li>
<li>Tracks unique positions visited by the tail knot using a <code>HashSet</code></li>
<li>Provides a <code>run</code> method to simulate all the movement steps</li>
</ul>
<h3 id="parsing-input-2"><a class="header" href="#parsing-input-2">Parsing Input</a></h3>
<p>The input is parsed into a sequence of <code>Step</code> values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_commands(input: &amp;str) -&gt; Vec&lt;Step&gt; {
    input.lines()
        .map(|line| line.split(' '))
        .map(|mut s| {
            let cmd = match s.next() {
                Some("R") =&gt; Command::Right,
                Some("U") =&gt; Command::Up,
                Some("D") =&gt; Command::Down,
                Some("L") =&gt; Command::Left,
                _ =&gt; panic!("Woohaaaa!")
            };
            (cmd, isize::from_str(s.next().unwrap()).unwrap())
        })
        .fold(vec![], |mut out, (cmd, units)| {
            out.push(Step{ cmd, units });
            out
        })
}
<span class="boring">}</span></code></pre></pre>
<h3 id="main-solution-2"><a class="header" href="#main-solution-2">Main Solution</a></h3>
<p>The main solution creates two games - one with a 2-knot rope for Part 1 and one with a 10-knot rope for Part 2:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let data = std::fs::read_to_string("src/bin/day9_input.txt").expect("");
    let cmds = parse_commands(data.as_str());

    println!("2 Link Chain - Unique points: {}",
             Game::new(Chain::new((0, 0).into(), 2))
                 .run(&amp;cmds)
                 .unique_positions()
    );
    println!("10 Links Chain - Unique points: {}",
             Game::new(Chain::new((0, 0).into(), 10))
                 .run(&amp;cmds)
                 .unique_positions()
    );
}</code></pre></pre>
<h2 id="algorithm-analysis-2"><a class="header" href="#algorithm-analysis-2">Algorithm Analysis</a></h2>
<h3 id="time-complexity-4"><a class="header" href="#time-complexity-4">Time Complexity</a></h3>
<ul>
<li>Parsing the input: O(n) where n is the number of lines in the input</li>
<li>Simulating the rope: O(n * m * k) where:
<ul>
<li>n is the number of steps</li>
<li>m is the maximum number of units in any step</li>
<li>k is the number of knots in the rope</li>
</ul>
</li>
</ul>
<h3 id="space-complexity-4"><a class="header" href="#space-complexity-4">Space Complexity</a></h3>
<ul>
<li>Storing the rope: O(k) where k is the number of knots</li>
<li>Storing unique positions: O(p) where p is the number of unique positions visited</li>
</ul>
<h2 id="alternative-approaches-7"><a class="header" href="#alternative-approaches-7">Alternative Approaches</a></h2>
<h3 id="simplified-movement-logic"><a class="header" href="#simplified-movement-logic">Simplified Movement Logic</a></h3>
<p>The <code>move_relative</code> method uses a detailed pattern match to handle all possible relative positions. An alternative approach could use a more general formula:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn move_relative_simplified(&amp;mut self, front: &amp;Link) -&gt; Coord {
    let dist = front.position() - self.position();
    
    // If Manhattan distance &lt;= 1 or diagonal distance = 1, don't move
    if (dist.x.abs() &lt;= 1 &amp;&amp; dist.y.abs() &lt;= 1) {
        return self.position();
    }
    
    // Otherwise, move in the direction of the front knot
    self.pos.x += dist.x.signum();
    self.pos.y += dist.y.signum();
    self.position()
}
<span class="boring">}</span></code></pre></pre>
<p>This approach is more concise but less explicit about the movement rules.</p>
<h3 id="alternative-coordinate-representation"><a class="header" href="#alternative-coordinate-representation">Alternative Coordinate Representation</a></h3>
<p>Instead of a custom <code>Coord</code> struct, we could use tuples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Coord = (isize, isize);

// Calculate distance
fn distance(a: Coord, b: Coord) -&gt; Coord {
    (a.0 - b.0, a.1 - b.1)
}
<span class="boring">}</span></code></pre></pre>
<p>This would be simpler but less expressive and type-safe.</p>
<h2 id="conclusion-6"><a class="header" href="#conclusion-6">Conclusion</a></h2>
<p>This solution demonstrates a clean approach to simulating physical constraints in a chain of connected objects. The use of custom types for coordinates and links, along with the implementation of movement rules, creates a readable and maintainable solution. The approach generalizes well from the 2-knot rope in Part 1 to the 10-knot rope in Part 2 without requiring significant changes to the code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-9-code"><a class="header" href="#day-9-code">Day 9: Code</a></h1>
<p>Below is the complete code for Day 9's solution, which simulates the motion of a rope with multiple knots.</p>
<h2 id="full-solution-8"><a class="header" href="#full-solution-8">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">use std::collections::HashSet;
use std::hash::Hash;
use std::ops::Sub;
use std::str::FromStr;
use std::vec;

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
struct Coord {
    x: isize,
    y: isize
}
impl Sub for Coord {
    type Output = Coord;

    fn sub(self, rhs: Self) -&gt; Self::Output {
        Coord {
            x: self.x - rhs.x,
            y: self.y - rhs.y,
        }
    }
}
impl From&lt;(isize,isize)&gt; for Coord {
    fn from(pos: (isize, isize)) -&gt; Self {
        Coord{x:pos.0, y:pos.1}
    }
}
#[derive(Debug, Copy, Clone)]
enum Command {
    Left,
    Right,
    Up,
    Down
}
#[derive(Debug, Copy, Clone)]
struct Step {
    cmd: Command,
    units: isize
}

#[derive(Debug, Copy, Clone)]
struct Link {
    pos: Coord
}
impl Link {
    fn new(pos:Coord) -&gt; Link {
        Link { pos }
    }
    fn move_to(&amp;mut self, cmd: Command) -&gt; Coord {
        match cmd {
            Command::Left =&gt; self.pos.x -= 1,
            Command::Right =&gt; self.pos.x += 1,
            Command::Up =&gt; self.pos.y += 1,
            Command::Down =&gt; self.pos.y -= 1
        }
        self.position()
    }
    fn move_relative(&amp;mut self, front: &amp;Link) -&gt; Coord {
        let dist = front.position() - self.position();
        let (dx,dy) = match (dist.x, dist.y) {
            // overlapping
            (0, 0) =&gt; (0, 0),
            // touching up/left/down/right
            (0, 1) | (1, 0) | (0, -1) | (-1, 0) =&gt; (0, 0),
            // touching diagonally
            (1, 1) | (1, -1) | (-1, 1) | (-1, -1) =&gt; (0, 0),
            // need to move up/left/down/right
            (0, 2) =&gt; (0, 1),
            (0, -2) =&gt; (0, -1),
            (2, 0) =&gt; (1, 0),
            (-2, 0) =&gt; (-1, 0),
            // need to move to the right diagonally
            (2, 1) =&gt; (1, 1),
            (2, -1) =&gt; (1, -1),
            // need to move to the left diagonally
            (-2, 1) =&gt; (-1, 1),
            (-2, -1) =&gt; (-1, -1),
            // need to move up/down diagonally
            (1, 2) =&gt; (1, 1),
            (-1, 2) =&gt; (-1, 1),
            (1, -2) =&gt; (1, -1),
            (-1, -2) =&gt; (-1, -1),
            // need to move diagonally
            (-2, -2) =&gt; (-1, -1),
            (-2, 2) =&gt; (-1, 1),
            (2, -2) =&gt; (1, -1),
            (2, 2) =&gt; (1, 1),
            _ =&gt; panic!("unhandled case: tail - head = {dist:?}"),
        };
        self.pos.x += dx;
        self.pos.y += dy;
        self.position()
    }
    fn position(&amp;self) -&gt; Coord {
        self.pos
    }
}

struct Chain {
    links: Vec&lt;Link&gt;
}
impl Chain {
    fn new(pos:Coord, size:usize) -&gt; Chain {
        Chain {
            links: vec![Link::new(pos); size]
        }
    }
    fn move_to(&amp;mut self, cmd: Command) -&gt; Coord {

        self.links[0].move_to(cmd);
        self.links
            .iter_mut()
            .reduce(|front,tail|{
                tail.move_relative(front);
                tail
            })
            .unwrap()
            .position()
    }
}

struct Game {
    rope: Chain,
    unique: HashSet&lt;Coord&gt;
}
impl Game {
    fn new(rope: Chain) -&gt; Game {
        Game { rope, unique: HashSet::new() }
    }
    fn unique_positions(&amp;self) -&gt; usize {
        self.unique.len()
    }
    fn run(&amp;mut self, input: &amp;Vec&lt;Step&gt;) -&gt; &amp;Self{
        for step in input {
            (0..step.units).all(|_| {
                self.unique.insert(
                    self.rope.move_to( step.cmd )
                );
                true
            });
        }
        self
    }
}

fn parse_commands(input: &amp;str) -&gt; Vec&lt;Step&gt; {
    input.lines()
        .map(|line| line.split(' '))
        .map(|mut s| {
            let cmd = match s.next() {
                Some("R") =&gt; Command::Right,
                Some("U") =&gt; Command::Up,
                Some("D") =&gt; Command::Down,
                Some("L") =&gt; Command::Left,
                _ =&gt; panic!("Woohaaaa!")
            };
            (cmd, isize::from_str(s.next().unwrap()).unwrap())
        })
        .fold(vec![], |mut out, (cmd, units)| {
            out.push( Step{ cmd, units });
            out
        })

}

fn main() {
//     let data = "R 4\nU 4\nL 3\nD 1\nR 4\nD 1\nL 5\nR 2".to_string();
//     let data = "R 5\nU 8\nL 8\nD 3\nR 17\nD 10\nL 25\nU 20\n".to_string();

    let data = std::fs::read_to_string("src/bin/day9_input.txt").expect("");

    let cmds = parse_commands(data.as_str());

    println!("2 Link Chain - Unique points: {}",
             Game::new( Chain::new((0, 0).into(), 2))
                 .run( &amp;cmds )
                 .unique_positions()
    );
    println!("10 Links Chain - Unique points: {}",
             Game::new( Chain::new((0, 0).into(), 10))
                 .run( &amp;cmds )
                 .unique_positions()
    );
}</code></pre>
<h2 id="code-walkthrough-8"><a class="header" href="#code-walkthrough-8">Code Walkthrough</a></h2>
<h3 id="coordinate-system-2"><a class="header" href="#coordinate-system-2">Coordinate System</a></h3>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
struct Coord {
    x: isize,
    y: isize
}
impl Sub for Coord {
    type Output = Coord;

    fn sub(self, rhs: Self) -&gt; Self::Output {
        Coord {
            x: self.x - rhs.x,
            y: self.y - rhs.y,
        }
    }
}
impl From&lt;(isize,isize)&gt; for Coord {
    fn from(pos: (isize, isize)) -&gt; Self {
        Coord{x:pos.0, y:pos.1}
    }
}</code></pre>
<p>The <code>Coord</code> struct represents positions in 2D space. It includes:</p>
<ul>
<li><code>x</code> and <code>y</code> coordinates as signed integers</li>
<li>Implementation of <code>Sub</code> to calculate the distance between two coordinates</li>
<li>A conversion from tuples for convenience</li>
<li>Several derived traits, including <code>Hash</code> to allow using coordinates in a <code>HashSet</code></li>
</ul>
<h3 id="movement-commands-1"><a class="header" href="#movement-commands-1">Movement Commands</a></h3>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Copy, Clone)]
enum Command {
    Left,
    Right,
    Up,
    Down
}
#[derive(Debug, Copy, Clone)]
struct Step {
    cmd: Command,
    units: isize
}
</code></pre>
<p>These types represent movement commands:</p>
<ul>
<li><code>Command</code> is an enum for the four possible directions</li>
<li><code>Step</code> combines a command with a distance</li>
</ul>
<h3 id="rope-link-implementation"><a class="header" href="#rope-link-implementation">Rope Link Implementation</a></h3>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Copy, Clone)]
struct Link {
    pos: Coord
}
impl Link {
    fn new(pos:Coord) -&gt; Link {
        Link { pos }
    }
    fn move_to(&amp;mut self, cmd: Command) -&gt; Coord {
        match cmd {
            Command::Left =&gt; self.pos.x -= 1,
            Command::Right =&gt; self.pos.x += 1,
            Command::Up =&gt; self.pos.y += 1,
            Command::Down =&gt; self.pos.y -= 1
        }
        self.position()
    }
    fn move_relative(&amp;mut self, front: &amp;Link) -&gt; Coord {
        let dist = front.position() - self.position();
        let (dx,dy) = match (dist.x, dist.y) {
            // overlapping
            (0, 0) =&gt; (0, 0),
            // touching up/left/down/right
            (0, 1) | (1, 0) | (0, -1) | (-1, 0) =&gt; (0, 0),
            // touching diagonally
            (1, 1) | (1, -1) | (-1, 1) | (-1, -1) =&gt; (0, 0),
            // need to move up/left/down/right
            (0, 2) =&gt; (0, 1),
            (0, -2) =&gt; (0, -1),
            (2, 0) =&gt; (1, 0),
            (-2, 0) =&gt; (-1, 0),
            // need to move to the right diagonally
            (2, 1) =&gt; (1, 1),
            (2, -1) =&gt; (1, -1),
            // need to move to the left diagonally
            (-2, 1) =&gt; (-1, 1),
            (-2, -1) =&gt; (-1, -1),
            // need to move up/down diagonally
            (1, 2) =&gt; (1, 1),
            (-1, 2) =&gt; (-1, 1),
            (1, -2) =&gt; (1, -1),
            (-1, -2) =&gt; (-1, -1),
            // need to move diagonally
            (-2, -2) =&gt; (-1, -1),
            (-2, 2) =&gt; (-1, 1),
            (2, -2) =&gt; (1, -1),
            (2, 2) =&gt; (1, 1),
            _ =&gt; panic!("unhandled case: tail - head = {dist:?}"),
        };
        self.pos.x += dx;
        self.pos.y += dy;
        self.position()
    }
    fn position(&amp;self) -&gt; Coord {
        self.pos
    }
}
</code></pre>
<p>The <code>Link</code> struct represents a single knot in the rope:</p>
<ul>
<li><code>pos</code> is the current position of the knot</li>
<li><code>move_to</code> moves the knot directly in a cardinal direction</li>
<li><code>move_relative</code> implements the physical constraints of the rope, moving the knot based on its relation to the knot in front of it</li>
<li><code>position</code> returns the current position</li>
</ul>
<p>The <code>move_relative</code> method is particularly detailed, handling all possible relative positions through pattern matching.</p>
<h3 id="rope-chain-implementation"><a class="header" href="#rope-chain-implementation">Rope Chain Implementation</a></h3>
<pre><code class="language-rust no_run noplayground">struct Chain {
    links: Vec&lt;Link&gt;
}
impl Chain {
    fn new(pos:Coord, size:usize) -&gt; Chain {
        Chain {
            links: vec![Link::new(pos); size]
        }
    }
    fn move_to(&amp;mut self, cmd: Command) -&gt; Coord {

        self.links[0].move_to(cmd);
        self.links
            .iter_mut()
            .reduce(|front,tail|{
                tail.move_relative(front);
                tail
            })
            .unwrap()
            .position()
    }
}</code></pre>
<p>The <code>Chain</code> struct represents the entire rope:</p>
<ul>
<li><code>links</code> is a vector of <code>Link</code> objects</li>
<li><code>new</code> creates a chain of a specified size, with all links starting at the same position</li>
<li><code>move_to</code> moves the head link directly and then propagates the movement through the chain</li>
</ul>
<p>The <code>reduce</code> operation in <code>move_to</code> elegantly handles the chain of movement dependencies.</p>
<h3 id="game-simulation-1"><a class="header" href="#game-simulation-1">Game Simulation</a></h3>
<pre><code class="language-rust no_run noplayground">struct Game {
    rope: Chain,
    unique: HashSet&lt;Coord&gt;
}
impl Game {
    fn new(rope: Chain) -&gt; Game {
        Game { rope, unique: HashSet::new() }
    }
    fn unique_positions(&amp;self) -&gt; usize {
        self.unique.len()
    }
    fn run(&amp;mut self, input: &amp;Vec&lt;Step&gt;) -&gt; &amp;Self{
        for step in input {
            (0..step.units).all(|_| {
                self.unique.insert(
                    self.rope.move_to( step.cmd )
                );
                true
            });
        }
        self
    }
}
</code></pre>
<p>The <code>Game</code> struct manages the simulation:</p>
<ul>
<li><code>rope</code> is the rope chain being simulated</li>
<li><code>unique</code> is a HashSet of coordinates visited by the tail</li>
<li><code>unique_positions</code> returns the number of unique positions visited</li>
<li><code>run</code> simulates all the movement steps and tracks unique tail positions</li>
</ul>
<h3 id="parsing-input-3"><a class="header" href="#parsing-input-3">Parsing Input</a></h3>
<pre><code class="language-rust no_run noplayground">fn parse_commands(input: &amp;str) -&gt; Vec&lt;Step&gt; {
    input.lines()
        .map(|line| line.split(' '))
        .map(|mut s| {
            let cmd = match s.next() {
                Some("R") =&gt; Command::Right,
                Some("U") =&gt; Command::Up,
                Some("D") =&gt; Command::Down,
                Some("L") =&gt; Command::Left,
                _ =&gt; panic!("Woohaaaa!")
            };
            (cmd, isize::from_str(s.next().unwrap()).unwrap())
        })
        .fold(vec![], |mut out, (cmd, units)| {
            out.push( Step{ cmd, units });
            out
        })

}</code></pre>
<p>The <code>parse_commands</code> function converts the input text into a vector of <code>Step</code> objects by:</p>
<ol>
<li>Splitting each line into parts</li>
<li>Converting the first part to a <code>Command</code></li>
<li>Converting the second part to a distance</li>
<li>Creating a <code>Step</code> with the command and distance</li>
</ol>
<h3 id="main-function-3"><a class="header" href="#main-function-3">Main Function</a></h3>
<pre><code class="language-rust no_run noplayground">fn main() {
//     let data = "R 4\nU 4\nL 3\nD 1\nR 4\nD 1\nL 5\nR 2".to_string();
//     let data = "R 5\nU 8\nL 8\nD 3\nR 17\nD 10\nL 25\nU 20\n".to_string();

    let data = std::fs::read_to_string("src/bin/day9_input.txt").expect("");

    let cmds = parse_commands(data.as_str());

    println!("2 Link Chain - Unique points: {}",
             Game::new( Chain::new((0, 0).into(), 2))
                 .run( &amp;cmds )
                 .unique_positions()
    );
    println!("10 Links Chain - Unique points: {}",
             Game::new( Chain::new((0, 0).into(), 10))
                 .run( &amp;cmds )
                 .unique_positions()
    );
}</code></pre>
<p>The main function:</p>
<ol>
<li>Reads the input file</li>
<li>Parses it into commands</li>
<li>For Part 1: Creates a game with a 2-link chain and runs the simulation</li>
<li>For Part 2: Creates a game with a 10-link chain and runs the simulation</li>
<li>Prints the number of unique positions visited by the tail in each case</li>
</ol>
<h2 id="implementation-notes-7"><a class="header" href="#implementation-notes-7">Implementation Notes</a></h2>
<ul>
<li><strong>Pattern Matching</strong>: The solution makes extensive use of pattern matching, especially in the <code>move_relative</code> method</li>
<li><strong>Functional Approach</strong>: The solution uses functional programming techniques like <code>map</code>, <code>reduce</code>, and method chaining</li>
<li><strong>Trait Implementations</strong>: Custom traits like <code>Sub</code> and trait derivations make the code more expressive and type-safe</li>
<li><strong>Type Safety</strong>: Custom types like <code>Coord</code>, <code>Command</code>, and <code>Step</code> provide type safety and clarity</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-10-cathode-ray-tube"><a class="header" href="#day-10-cathode-ray-tube">Day 10: Cathode-Ray Tube</a></h1>
<p>Day 10 involves simulating a CPU with a simple instruction set and a CRT display.</p>
<h2 id="problem-overview-9"><a class="header" href="#problem-overview-9">Problem Overview</a></h2>
<p>You need to fix a small handheld device with a CPU and CRT screen. The task involves:</p>
<ol>
<li>Simulating a CPU that executes instructions with different timing</li>
<li>Monitoring the X register at specific cycles</li>
<li>Drawing pixels on a CRT screen based on the X register's value</li>
</ol>
<p>This problem tests your ability to implement a simple processor simulation and track the state over time, as well as generating visual output based on that state.</p>
<h2 id="navigation-9"><a class="header" href="#navigation-9">Navigation</a></h2>
<ul>
<li><a href="day10/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day10/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day10/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-10-problem-description"><a class="header" href="#day-10-problem-description">Day 10: Problem Description</a></h1>
<h2 id="cathode-ray-tube"><a class="header" href="#cathode-ray-tube">Cathode-Ray Tube</a></h2>
<p>You avoid the ropes, plunge into the river, and swim to shore.</p>
<p>The Elves yell something about meeting back up with them upriver, but the river is too loud to tell exactly what they're saying. They finish crossing the bridge and disappear from view.</p>
<p>Situations like this must be why the Elves prioritized getting the communication system on your handheld device working. You pull it out of your pack, but the amount of water slowly draining from a big crack in its screen tells you it probably won't be of much immediate use.</p>
<p><strong>Unless</strong>, that is, you can design a replacement for the device's video system! It seems to be some kind of <strong>cathode-ray tube</strong> screen and simple CPU that are both driven by a precise <strong>clock circuit</strong>. The clock circuit ticks at a constant rate; each tick is called a <strong>cycle</strong>.</p>
<p>Start by figuring out the signal being sent by the CPU. The CPU has a single register, <code>X</code>, which starts with the value <code>1</code>. It supports only two instructions:</p>
<ul>
<li><code>addx V</code> takes <strong>two cycles</strong> to complete. <strong>After</strong> two cycles, the <code>X</code> register is increased by the value <code>V</code>. (<code>V</code> can be negative.)</li>
<li><code>noop</code> takes <strong>one cycle</strong> to complete. It has no other effect.</li>
</ul>
<p>The CPU uses these instructions in a program (your puzzle input) to, somehow, tell the screen what to draw.</p>
<p>Consider the following small program:</p>
<pre><code>noop
addx 3
addx -5
</code></pre>
<p>Execution of this program proceeds as follows:</p>
<ul>
<li>At the start of the first cycle, the <code>noop</code> instruction begins execution. During the first cycle, <code>X</code> is <code>1</code>. After the first cycle, the <code>noop</code> instruction finishes execution, doing nothing.</li>
<li>At the start of the second cycle, the <code>addx 3</code> instruction begins execution. During the second cycle, <code>X</code> is still <code>1</code>.</li>
<li>During the third cycle, <code>X</code> is still <code>1</code>. After the third cycle, the <code>addx 3</code> instruction finishes execution, setting <code>X</code> to <code>4</code>.</li>
<li>At the start of the fourth cycle, the <code>addx -5</code> instruction begins execution. During the fourth cycle, <code>X</code> is still <code>4</code>.</li>
<li>During the fifth cycle, <code>X</code> is still <code>4</code>. After the fifth cycle, the <code>addx -5</code> instruction finishes execution, setting <code>X</code> to <code>-1</code>.</li>
</ul>
<p>Maybe you can learn something by looking at the value of the <code>X</code> register throughout execution. For now, consider the <strong>signal strength</strong> (the cycle number multiplied by the value of the <code>X</code> register) <strong>during</strong> the 20th cycle and every 40 cycles after that (that is, during the 20th, 60th, 100th, 140th, 180th, and 220th cycles).</p>
<p>For example, consider this larger program:</p>
<pre><code>addx 15
addx -11
addx 6
addx -3
addx 5
addx -1
addx -8
addx 13
addx 4
noop
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx -35
addx 1
addx 24
addx -19
addx 1
addx 16
addx -11
noop
noop
addx 21
addx -15
noop
noop
addx -3
addx 9
addx 1
addx -3
addx 8
addx 1
addx 5
noop
noop
noop
noop
noop
addx -36
noop
addx 1
addx 7
noop
noop
noop
addx 2
addx 6
noop
noop
noop
noop
noop
addx 1
noop
noop
addx 7
addx 1
noop
addx -13
addx 13
addx 7
noop
addx 1
addx -33
noop
noop
noop
addx 2
noop
noop
noop
addx 8
noop
addx -1
addx 2
addx 1
noop
addx 17
addx -9
addx 1
addx 1
addx -3
addx 11
noop
noop
addx 1
noop
addx 1
noop
noop
addx -13
addx -19
addx 1
addx 3
addx 26
addx -30
addx 12
addx -1
addx 3
addx 1
noop
noop
noop
addx -9
addx 18
addx 1
addx 2
noop
noop
addx 9
noop
noop
noop
addx -1
addx 2
addx -37
addx 1
addx 3
noop
addx 15
addx -21
addx 22
addx -6
addx 1
noop
addx 2
addx 1
noop
addx -10
noop
noop
addx 20
addx 1
addx 2
addx 2
addx -6
addx -11
noop
noop
noop
</code></pre>
<p>The interesting signal strengths can be determined as follows:</p>
<ul>
<li>During the 20th cycle, register <code>X</code> has the value <code>21</code>, so the signal strength is 20 * 21 = <strong>420</strong>. (The 20th cycle occurs in the middle of the second <code>addx -1</code>, so the value of register <code>X</code> is the starting value, <code>1</code>, plus all of the other <code>addx</code> values up to that point: 1 + 15 - 11 + 6 - 3 + 5 - 1 - 8 + 13 + 4 = 21.)</li>
<li>During the 60th cycle, register <code>X</code> has the value <code>19</code>, so the signal strength is 60 * 19 = <strong>1140</strong>.</li>
<li>During the 100th cycle, register <code>X</code> has the value <code>18</code>, so the signal strength is 100 * 18 = <strong>1800</strong>.</li>
<li>During the 140th cycle, register <code>X</code> has the value <code>21</code>, so the signal strength is 140 * 21 = <strong>2940</strong>.</li>
<li>During the 180th cycle, register <code>X</code> has the value <code>16</code>, so the signal strength is 180 * 16 = <strong>2880</strong>.</li>
<li>During the 220th cycle, register <code>X</code> has the value <code>18</code>, so the signal strength is 220 * 18 = <strong>3960</strong>.</li>
</ul>
<p>The sum of these signal strengths is <strong>13140</strong>.</p>
<h2 id="part-1-9"><a class="header" href="#part-1-9">Part 1</a></h2>
<p>Find the signal strength during the 20th, 60th, 100th, 140th, 180th, and 220th cycles. <strong>What is the sum of these six signal strengths?</strong></p>
<h2 id="part-2-9"><a class="header" href="#part-2-9">Part 2</a></h2>
<p>It seems like the <code>X</code> register controls the horizontal position of a sprite. Specifically, the sprite is 3 pixels wide, and the <code>X</code> register sets the horizontal position of the <strong>middle</strong> of that sprite. (In this system, there is no such thing as "vertical position": if the sprite's horizontal position puts its pixels where the CRT is currently drawing, then those pixels will be drawn.)</p>
<p>You count the pixels on the CRT: 40 wide and 6 high. This CRT screen draws the top row of pixels left-to-right, then the row below that, and so on. The left-most pixel in each row is in position <code>0</code>, and the right-most pixel in each row is in position <code>39</code>.</p>
<p>Like the CPU, the CRT is tied closely to the clock circuit: the CRT draws <strong>a single pixel during each cycle</strong>. Representing each pixel of the screen as a <code>#</code>, here are the cycles during which the first and last pixel in each row are drawn:</p>
<pre><code>Cycle   1 -&gt; ######################################## &lt;- Cycle  40
Cycle  41 -&gt; ######################################## &lt;- Cycle  80
Cycle  81 -&gt; ######################################## &lt;- Cycle 120
Cycle 121 -&gt; ######################################## &lt;- Cycle 160
Cycle 161 -&gt; ######################################## &lt;- Cycle 200
Cycle 201 -&gt; ######################################## &lt;- Cycle 240
</code></pre>
<p>So, by carefully timing the CPU instructions and the CRT drawing operations, you should be able to determine whether the sprite is visible the instant each pixel is drawn. If the sprite is positioned such that one of its three pixels is the pixel currently being drawn, the screen produces a <strong>lit</strong> pixel (<code>#</code>); otherwise, the screen leaves the pixel <strong>dark</strong> (<code>.</code>).</p>
<p>The first few pixels from the larger example above are drawn as follows:</p>
<pre><code>Sprite position: ###.....................................

Start cycle   1: begin executing addx 15
During cycle  1: CRT draws pixel in position 0
Current CRT row: #.......................................

During cycle  2: CRT draws pixel in position 1
Current CRT row: ##......................................
End of cycle  2: finish executing addx 15 (Register X is now 16)
Sprite position: ...............###......................

Start cycle   3: begin executing addx -11
During cycle  3: CRT draws pixel in position 2
Current CRT row: ##......................................

During cycle  4: CRT draws pixel in position 3
Current CRT row: ##......................................
End of cycle  4: finish executing addx -11 (Register X is now 5)
Sprite position: ....###.................................

Start cycle   5: begin executing addx 6
During cycle  5: CRT draws pixel in position 4
Current CRT row: ##..#...................................

During cycle  6: CRT draws pixel in position 5
Current CRT row: ##..##..................................
End of cycle  6: finish executing addx 6 (Register X is now 11)
Sprite position: ..........###...........................

Start cycle   7: begin executing addx -3
During cycle  7: CRT draws pixel in position 6
Current CRT row: ##..##..................................

During cycle  8: CRT draws pixel in position 7
Current CRT row: ##..##...................................
End of cycle  8: finish executing addx -3 (Register X is now 8)
Sprite position: .......###..............................

Start cycle   9: begin executing addx 5
During cycle  9: CRT draws pixel in position 8
Current CRT row: ##..##...#..............................

During cycle 10: CRT draws pixel in position 9
Current CRT row: ##..##...##.............................
End of cycle 10: finish executing addx 5 (Register X is now 13)
Sprite position: ............###.........................

Start cycle  11: begin executing addx -1
During cycle 11: CRT draws pixel in position 10
Current CRT row: ##..##...##.............................

During cycle 12: CRT draws pixel in position 11
Current CRT row: ##..##...##.............................
End of cycle 12: finish executing addx -1 (Register X is now 12)
Sprite position: ...........###..........................

Start cycle  13: begin executing addx -8
During cycle 13: CRT draws pixel in position 12
Current CRT row: ##..##...##..#.........................

During cycle 14: CRT draws pixel in position 13
Current CRT row: ##..##...##..##........................
End of cycle 14: finish executing addx -8 (Register X is now 4)
Sprite position: ...###..................................

Start cycle  15: begin executing addx 13
During cycle 15: CRT draws pixel in position 14
Current CRT row: ##..##...##..##........................

During cycle 16: CRT draws pixel in position 15
Current CRT row: ##..##...##..##........................
End of cycle 16: finish executing addx 13 (Register X is now 17)
Sprite position: ................###.....................

Start cycle  17: begin executing addx 4
During cycle 17: CRT draws pixel in position 16
Current CRT row: ##..##...##..##..#.....................

During cycle 18: CRT draws pixel in position 17
Current CRT row: ##..##...##..##..##....................
End of cycle 18: finish executing addx 4 (Register X is now 21)
Sprite position: ....................###.................

Start cycle  19: begin executing noop
During cycle 19: CRT draws pixel in position 18
Current CRT row: ##..##...##..##..##....................
End of cycle 19: finish executing noop

Start cycle  20: begin executing addx -1
During cycle 20: CRT draws pixel in position 19
Current CRT row: ##..##...##..##..##..#.................

During cycle 21: CRT draws pixel in position 20
Current CRT row: ##..##...##..##..##..##................
End of cycle 21: finish executing addx -1 (Register X is now 20)
Sprite position: ...................###..................
</code></pre>
<p>Render the image given by your program. <strong>What eight capital letters appear on your CRT?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-10-solution-explanation"><a class="header" href="#day-10-solution-explanation">Day 10: Solution Explanation</a></h1>
<h2 id="approach-9"><a class="header" href="#approach-9">Approach</a></h2>
<p>Day 10 involves simulating a simple CPU with a basic instruction set and a CRT display. The solution requires us to:</p>
<ol>
<li><strong>Parse the instructions</strong>: Read the input and convert it to a series of CPU instructions</li>
<li><strong>Simulate the CPU</strong>: Execute instructions while tracking the X register value</li>
<li><strong>Monitor signal strength</strong>: Calculate signal strength at specific cycles</li>
<li><strong>Render the CRT</strong>: Draw pixels based on the X register value</li>
</ol>
<p>The solution models the CPU, its execution cycle, and the CRT display as separate components that interact with each other.</p>
<h2 id="implementation-details-9"><a class="header" href="#implementation-details-9">Implementation Details</a></h2>
<h3 id="instruction-set"><a class="header" href="#instruction-set">Instruction Set</a></h3>
<p>We start by defining the instruction set and what each instruction does:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Cycles = usize;

#[derive(Debug,Copy, Clone)]
enum InstructionSet { Noop, AddX(isize) }

#[derive(Debug,Copy, Clone)]
struct Instruction {
    op: InstructionSet,
    ticks: Cycles
}
impl Instruction {
    fn result(&amp;self) -&gt; isize {
        match self.op {
            InstructionSet::Noop =&gt; 0,
            InstructionSet::AddX(val) =&gt; val
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>InstructionSet</code> enum represents the two possible instructions:</p>
<ul>
<li><code>Noop</code>: Does nothing</li>
<li><code>AddX(isize)</code>: Adds the specified value to the X register</li>
</ul>
<p>The <code>Instruction</code> struct combines an operation with the number of cycles it takes to execute. The <code>result</code> method returns the value that should be added to the X register after execution.</p>
<h3 id="cpu-simulation"><a class="header" href="#cpu-simulation">CPU Simulation</a></h3>
<p>The CPU is modeled as a state machine with several components:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Register(isize);

struct CPU {
    x: Register,             // X register
    buffer: Option&lt;Instruction&gt;, // Currently executing instruction
    exec_cycles: Cycles,      // Remaining cycles for current instruction
    ip: Option&lt;IntoIter&lt;Instruction&gt;&gt; // Instruction pointer
}
<span class="boring">}</span></code></pre></pre>
<p>The CPU implementation includes methods for loading instructions, fetching the next instruction, executing instructions, and advancing the clock:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl CPU {
    fn new() -&gt; CPU {
        CPU { x: Register(1), buffer: None, exec_cycles: 0, ip: None }
    }
    
    fn load(&amp;mut self, ops: Vec&lt;Instruction&gt;) {
        self.ip = Some(ops.into_iter());
    }
    
    fn fetch(&amp;mut self, op: Instruction) {
        self.exec_cycles = op.ticks;
        self.buffer = Some(op);
    }
    
    fn execute(&amp;mut self) -&gt; bool {
        match self.buffer {                         // Check instruction buffer
            None =&gt; false,                          // empty, not exec, go and load
            Some(op) =&gt; {                 // Instruction loaded
                self.exec_cycles -= 1;               // execution cycle #
                if self.exec_cycles == 0 {           // exec cycles reached?
                    self.x.0 += op.result();            // move Val to Reg X
                    self.buffer = None;                 // flush instruction buffer
                    false                           // not exec, go and load
                } else { true }                     // Busy executing
            }
        }
    }
    
    fn tick(&amp;mut self) {
        if !self.execute() {
            let mut ip = self.ip.take().unwrap();
            self.fetch(ip.next().unwrap());
            self.ip.replace(ip);
        }
    }
    
    fn reg_x(&amp;self) -&gt; isize {
        self.x.0
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This implementation models the CPU's behavior:</p>
<ul>
<li><code>execute</code> processes one cycle of the current instruction and returns whether execution is ongoing</li>
<li><code>tick</code> advances the CPU by one cycle, either continuing execution of the current instruction or fetching a new one</li>
<li><code>reg_x</code> provides access to the current value of the X register</li>
</ul>
<h3 id="crt-display"><a class="header" href="#crt-display">CRT Display</a></h3>
<p>The CRT display is modeled as a separate component:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CRT {
    width: usize,
    clock: Cycles
}

impl CRT {
    fn new(width: usize) -&gt; CRT {
        CRT{ width, clock: 0 }
    }
    
    fn draw(&amp;mut self, pos: isize) {
        let col = self.clock % self.width;
        print!("{}",
            if (pos-1..=pos+1).contains(&amp;(col as isize)) { '#' } else { '.' }
        );
        if col == self.width-1 { println!() }
    }
    
    fn tick(&amp;mut self, pos:isize) {
        self.draw(pos);
        self.clock += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The CRT:</p>
<ul>
<li>Tracks its own clock cycle</li>
<li>Draws a pixel based on the current cycle and the X register value</li>
<li>Automatically handles line breaks when reaching the end of a row</li>
</ul>
<h3 id="parsing-instructions"><a class="header" href="#parsing-instructions">Parsing Instructions</a></h3>
<p>The input is parsed into a sequence of instructions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_instructions(inp: &amp;str) -&gt; (Vec&lt;Instruction&gt;, usize) {
    inp.lines()
        .map(|line| {
            let mut iter = line.split(' ');
            match iter.next() {
                Some("noop") =&gt; Instruction { op: InstructionSet::Noop, ticks: 1 },
                Some("addx") =&gt; {
                    let val = isize::from_str(
                        iter.next().expect("parse_instructions: addx is missing its value!")
                    ).expect("parse_instructions: addx not followed by numeric value!");
                    Instruction { op: InstructionSet::AddX(val), ticks: 2 }
                },
                _ =&gt; panic!("parse_instructions: unknown instruction caught!")
            }
        })
        .fold((vec![],0), |(mut out,mut total), op| {
            total += op.ticks;
            out.push(op);
            (out,total)
        })
}
<span class="boring">}</span></code></pre></pre>
<p>This function:</p>
<ol>
<li>Converts each line into an <code>Instruction</code></li>
<li>Sets the appropriate number of cycles for each instruction type (1 for <code>noop</code>, 2 for <code>addx</code>)</li>
<li>Returns both the instructions and the total number of cycles they'll take to execute</li>
</ol>
<h3 id="main-simulation"><a class="header" href="#main-simulation">Main Simulation</a></h3>
<p>The main simulation brings everything together:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let input = std::fs::read_to_string("src/bin/day10_input.txt").expect("Ops!");

    let sample_intervals = vec![20usize, 60, 100, 140, 180, 220];
    let mut sampling_interval = sample_intervals.iter().peekable();

    let mut crt = CRT::new(40);
    let mut cpu = CPU::new();

    let (opcode, clock) = parse_instructions(input.as_str() );
    cpu.load(opcode);

    let sum = (1..=clock)
        .map(|cycle| {
            cpu.tick();
            crt.tick(cpu.reg_x());
            ( cycle, cpu.reg_x() )
        })
        .filter(|(cycle,_)|
            match sampling_interval.peek() {
                Some(&amp;to_sample) if to_sample.eq(cycle) =&gt; { sampling_interval.next(); true }
                _ =&gt; false
            }
        )
        .map(|(clock, x)| x * clock as isize)
        .sum::&lt;isize&gt;();

    println!("{sum} is the sum of signal strengths at {:?}", sample_intervals);
}</code></pre></pre>
<p>The main function:</p>
<ol>
<li>Sets up the sample intervals for signal strength measurement</li>
<li>Creates the CPU and CRT</li>
<li>Parses the instructions and loads them into the CPU</li>
<li>Runs the simulation for the specified number of cycles, ticking both CPU and CRT each cycle</li>
<li>Filters for the specific cycles we need to sample</li>
<li>Calculates the signal strength at those cycles</li>
<li>Sums the signal strengths for Part 1</li>
</ol>
<p>Part 2's output is handled automatically by the CRT's <code>draw</code> method, which prints the characters directly to the console.</p>
<h2 id="algorithm-analysis-3"><a class="header" href="#algorithm-analysis-3">Algorithm Analysis</a></h2>
<h3 id="time-complexity-5"><a class="header" href="#time-complexity-5">Time Complexity</a></h3>
<ul>
<li>Parsing the input: O(n) where n is the number of instructions</li>
<li>Simulating the CPU: O(c) where c is the total number of cycles</li>
<li>Overall: O(n + c), which is effectively O(c) since the number of cycles is proportional to the number of instructions</li>
</ul>
<h3 id="space-complexity-5"><a class="header" href="#space-complexity-5">Space Complexity</a></h3>
<ul>
<li>Storing instructions: O(n) where n is the number of instructions</li>
<li>CPU state: O(1)</li>
<li>CRT state: O(1)</li>
<li>Overall: O(n)</li>
</ul>
<h2 id="alternative-approaches-8"><a class="header" href="#alternative-approaches-8">Alternative Approaches</a></h2>
<h3 id="simplified-cpu-model"><a class="header" href="#simplified-cpu-model">Simplified CPU Model</a></h3>
<p>Instead of modeling the CPU with an instruction buffer and execution cycles, we could use a simpler approach that just keeps track of the current instruction and cycles:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SimplifiedCPU {
    x: isize,
    cycle: usize,
    instructions: Vec&lt;(String, isize)&gt;
}

impl SimplifiedCPU {
    fn run(&amp;mut self) -&gt; Vec&lt;(usize, isize)&gt; {
        let mut history = Vec::new();
        let mut pc = 0;
        
        while pc &lt; self.instructions.len() {
            let (instr, val) = &amp;self.instructions[pc];
            
            match instr.as_str() {
                "noop" =&gt; {
                    self.cycle += 1;
                    history.push((self.cycle, self.x));
                }
                "addx" =&gt; {
                    self.cycle += 1;
                    history.push((self.cycle, self.x));
                    self.cycle += 1;
                    history.push((self.cycle, self.x));
                    self.x += val;
                }
                _ =&gt; panic!("Unknown instruction")
            }
            
            pc += 1;
        }
        
        history
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This approach is more straightforward but less flexible if we wanted to add more instructions or change the behavior.</p>
<h3 id="crt-as-a-string-buffer"><a class="header" href="#crt-as-a-string-buffer">CRT as a String Buffer</a></h3>
<p>Instead of printing directly, the CRT could build a string buffer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BufferedCRT {
    width: usize,
    height: usize,
    buffer: Vec&lt;char&gt;,
    position: usize
}

impl BufferedCRT {
    fn new(width: usize, height: usize) -&gt; Self {
        Self {
            width,
            height,
            buffer: vec!['.'; width * height],
            position: 0
        }
    }
    
    fn draw(&amp;mut self, sprite_pos: isize) {
        let col = self.position % self.width;
        if (sprite_pos-1..=sprite_pos+1).contains(&amp;(col as isize)) {
            self.buffer[self.position] = '#';
        }
        self.position += 1;
    }
    
    fn display(&amp;self) -&gt; String {
        self.buffer.chunks(self.width)
            .map(|row| row.iter().collect::&lt;String&gt;())
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .join("\n")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This would allow us to build up the entire display and then render it all at once, which might be preferable for some applications.</p>
<h2 id="conclusion-7"><a class="header" href="#conclusion-7">Conclusion</a></h2>
<p>This solution demonstrates how to simulate a simple CPU and CRT display. The modular approach with separate CPU and CRT components makes the code clean and maintainable. The use of Rust's pattern matching and option handling helps elegantly manage the CPU's state and instruction execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-10-code"><a class="header" href="#day-10-code">Day 10: Code</a></h1>
<p>Below is the complete code for Day 10's solution, which simulates a CPU and CRT display.</p>
<h2 id="full-solution-9"><a class="header" href="#full-solution-9">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">use std::str::FromStr;
use std::vec::IntoIter;

type Cycles = usize;

#[derive(Debug,Copy, Clone)]
enum InstructionSet { Noop, AddX(isize) }

#[derive(Debug,Copy, Clone)]
struct Instruction {
    op: InstructionSet,
    ticks: Cycles
}
impl Instruction {
    fn result(&amp;self) -&gt; isize {
        match self.op {
            InstructionSet::Noop =&gt; 0,
            InstructionSet::AddX(val) =&gt; val
        }
    }
}

#[derive(Debug)]
struct Register(isize);


struct CPU {
    x: Register,
    buffer: Option&lt;Instruction&gt;,
    exec_cycles: Cycles,
    ip: Option&lt;IntoIter&lt;Instruction&gt;&gt;
}
impl CPU {
    fn new() -&gt; CPU {
        CPU { x: Register(1), buffer: None, exec_cycles: 0, ip: None }
    }
    fn load(&amp;mut self, ops: Vec&lt;Instruction&gt;) {
        self.ip = Some(ops.into_iter());
    }
    fn fetch(&amp;mut self, op: Instruction) {
        self.exec_cycles = op.ticks;
        self.buffer = Some(op);
    }
    fn execute(&amp;mut self) -&gt; bool {
        match self.buffer {                         // Check instruction buffer
            None =&gt; false,                          // empty, not exec, go and load
            Some(op) =&gt; {                 // Instruction loaded
                self.exec_cycles -= 1;               // execution cycle #
                if self.exec_cycles == 0 {           // exec cycles reached ?
                    self.x.0 += op.result();            // move Val to Reg X
                    self.buffer = None;                 // flush instruction buffer
                    false                           // not exec, go and load
                } else { true }                     // Busy executing
            }
        }
    }
    fn tick(&amp;mut self) {
        if !self.execute() {
            let mut ip = self.ip.take().unwrap();
            self.fetch(ip.next().unwrap());
            self.ip.replace(ip);
        }
    }
    fn reg_x(&amp;self) -&gt; isize {
        self.x.0
    }
}

struct CRT {
    width: usize,
    clock: Cycles
}
impl CRT {
    fn new(width: usize) -&gt; CRT {
        CRT{ width, clock: 0 }
    }
    fn draw(&amp;mut self, pos: isize) {
        let col = self.clock % self.width;
        print!("{}",
            if (pos-1..=pos+1).contains(&amp;(col as isize)) { '#' } else { '.' }
        );
        if col == self.width-1 { println!() }
    }
    fn tick(&amp;mut self, pos:isize) {
        self.draw(pos);
        self.clock += 1;
    }
}

fn parse_instructions(inp: &amp;str) -&gt; (Vec&lt;Instruction&gt;, usize) {
    inp.lines()
        .map(|line| {
            let mut iter = line.split(' ');
            match iter.next() {
                Some("noop") =&gt; Instruction { op: InstructionSet::Noop, ticks: 1 },
                Some("addx") =&gt; {
                    let val = isize::from_str(
                        iter.next().expect("parse_instructions: addx is missing its value!")
                    ).expect("parse_instructions: addx not followed by numeric value!");
                    Instruction { op: InstructionSet::AddX(val), ticks: 2 }
                },
                _ =&gt; panic!("parse_instructions: unknown instruction caught!")
            }
        })
        .fold((vec![],0), |(mut out,mut total), op| {
            total += op.ticks;
            out.push(op);
            (out,total)
        })
}

fn main() {
    let input = std::fs::read_to_string("src/bin/day10_input.txt").expect("Ops!");

    let sample_intervals = vec![20usize, 60, 100, 140, 180, 220];
    let mut sampling_interval = sample_intervals.iter().peekable();

    let mut crt = CRT::new(40);
    let mut cpu = CPU::new();

    let (opcode, clock) = parse_instructions(input.as_str() );
    cpu.load(opcode);

    let sum = (1..=clock)
        .map(|cycle| {
            cpu.tick();
            crt.tick(cpu.reg_x());
            ( cycle, cpu.reg_x() )
        })
        .filter(|(cycle,_)|
            match sampling_interval.peek() {
                Some(&amp;to_sample) if to_sample.eq(cycle) =&gt; { sampling_interval.next(); true }
                _ =&gt; false
            }
        )
        .map(|(clock, x)| x * clock as isize)
        .sum::&lt;isize&gt;();

    println!("{sum} is the sum of  signal strengths at {:?}", sample_intervals);
}</code></pre>
<h2 id="code-walkthrough-9"><a class="header" href="#code-walkthrough-9">Code Walkthrough</a></h2>
<h3 id="data-types-and-instruction-set"><a class="header" href="#data-types-and-instruction-set">Data Types and Instruction Set</a></h3>
<pre><code class="language-rust no_run noplayground">type Cycles = usize;

#[derive(Debug,Copy, Clone)]
enum InstructionSet { Noop, AddX(isize) }

#[derive(Debug,Copy, Clone)]
struct Instruction {
    op: InstructionSet,
    ticks: Cycles
}
impl Instruction {
    fn result(&amp;self) -&gt; isize {
        match self.op {
            InstructionSet::Noop =&gt; 0,
            InstructionSet::AddX(val) =&gt; val
        }
    }
}

#[derive(Debug)]
struct Register(isize);</code></pre>
<p>The code defines the core types for the CPU simulation:</p>
<ul>
<li><code>Cycles</code> is a type alias for <code>usize</code> to represent clock cycles</li>
<li><code>InstructionSet</code> is an enum of the possible instructions (<code>Noop</code> and <code>AddX</code>)</li>
<li><code>Instruction</code> combines an operation with the number of cycles it takes</li>
<li><code>Register</code> is a simple wrapper around an <code>isize</code> value</li>
</ul>
<p>The <code>result</code> method on <code>Instruction</code> returns the value that should be added to the X register after execution.</p>
<h3 id="cpu-implementation"><a class="header" href="#cpu-implementation">CPU Implementation</a></h3>
<pre><code class="language-rust no_run noplayground">struct CPU {
    x: Register,
    buffer: Option&lt;Instruction&gt;,
    exec_cycles: Cycles,
    ip: Option&lt;IntoIter&lt;Instruction&gt;&gt;
}
impl CPU {
    fn new() -&gt; CPU {
        CPU { x: Register(1), buffer: None, exec_cycles: 0, ip: None }
    }
    fn load(&amp;mut self, ops: Vec&lt;Instruction&gt;) {
        self.ip = Some(ops.into_iter());
    }
    fn fetch(&amp;mut self, op: Instruction) {
        self.exec_cycles = op.ticks;
        self.buffer = Some(op);
    }
    fn execute(&amp;mut self) -&gt; bool {
        match self.buffer {                         // Check instruction buffer
            None =&gt; false,                          // empty, not exec, go and load
            Some(op) =&gt; {                 // Instruction loaded
                self.exec_cycles -= 1;               // execution cycle #
                if self.exec_cycles == 0 {           // exec cycles reached ?
                    self.x.0 += op.result();            // move Val to Reg X
                    self.buffer = None;                 // flush instruction buffer
                    false                           // not exec, go and load
                } else { true }                     // Busy executing
            }
        }
    }
    fn tick(&amp;mut self) {
        if !self.execute() {
            let mut ip = self.ip.take().unwrap();
            self.fetch(ip.next().unwrap());
            self.ip.replace(ip);
        }
    }
    fn reg_x(&amp;self) -&gt; isize {
        self.x.0
    }
}</code></pre>
<p>The <code>CPU</code> struct models a simple processor with:</p>
<ul>
<li>An X register storing a single value</li>
<li>An instruction buffer for the currently executing instruction</li>
<li>A counter for the remaining execution cycles</li>
<li>An instruction pointer to iterate through the program</li>
</ul>
<p>The key methods are:</p>
<ul>
<li><code>execute()</code> - Processes one cycle of the current instruction, decrements the cycle counter, and returns whether execution is still in progress</li>
<li><code>tick()</code> - Advances the CPU by one cycle, either continuing execution or fetching a new instruction</li>
<li><code>reg_x()</code> - Returns the current value of the X register</li>
</ul>
<h3 id="crt-implementation"><a class="header" href="#crt-implementation">CRT Implementation</a></h3>
<pre><code class="language-rust no_run noplayground">struct CRT {
    width: usize,
    clock: Cycles
}
impl CRT {
    fn new(width: usize) -&gt; CRT {
        CRT{ width, clock: 0 }
    }
    fn draw(&amp;mut self, pos: isize) {
        let col = self.clock % self.width;
        print!("{}",
            if (pos-1..=pos+1).contains(&amp;(col as isize)) { '#' } else { '.' }
        );
        if col == self.width-1 { println!() }
    }
    fn tick(&amp;mut self, pos:isize) {
        self.draw(pos);
        self.clock += 1;
    }
}</code></pre>
<p>The <code>CRT</code> struct implements a simple display:</p>
<ul>
<li><code>width</code> defines how many pixels are in each row</li>
<li><code>clock</code> tracks the current pixel position</li>
<li><code>draw()</code> prints a pixel based on whether the sprite (positioned at <code>pos</code>) overlaps with the current pixel</li>
<li><code>tick()</code> advances the CRT clock after drawing a pixel</li>
</ul>
<h3 id="instruction-parsing"><a class="header" href="#instruction-parsing">Instruction Parsing</a></h3>
<pre><code class="language-rust no_run noplayground">fn parse_instructions(inp: &amp;str) -&gt; (Vec&lt;Instruction&gt;, usize) {
    inp.lines()
        .map(|line| {
            let mut iter = line.split(' ');
            match iter.next() {
                Some("noop") =&gt; Instruction { op: InstructionSet::Noop, ticks: 1 },
                Some("addx") =&gt; {
                    let val = isize::from_str(
                        iter.next().expect("parse_instructions: addx is missing its value!")
                    ).expect("parse_instructions: addx not followed by numeric value!");
                    Instruction { op: InstructionSet::AddX(val), ticks: 2 }
                },
                _ =&gt; panic!("parse_instructions: unknown instruction caught!")
            }
        })
        .fold((vec![],0), |(mut out,mut total), op| {
            total += op.ticks;
            out.push(op);
            (out,total)
        })
}</code></pre>
<p>The <code>parse_instructions</code> function converts the input text to a list of instructions:</p>
<ol>
<li>It splits each line and matches the instruction type</li>
<li>For <code>noop</code>, it creates an instruction with 1 execution cycle</li>
<li>For <code>addx</code>, it parses the value and creates an instruction with 2 execution cycles</li>
<li>It uses <code>fold</code> to build a vector of instructions while also calculating the total number of cycles</li>
</ol>
<h3 id="main-function-4"><a class="header" href="#main-function-4">Main Function</a></h3>
<pre><code class="language-rust no_run noplayground">fn main() {
    let input = std::fs::read_to_string("src/bin/day10_input.txt").expect("Ops!");

    let sample_intervals = vec![20usize, 60, 100, 140, 180, 220];
    let mut sampling_interval = sample_intervals.iter().peekable();

    let mut crt = CRT::new(40);
    let mut cpu = CPU::new();

    let (opcode, clock) = parse_instructions(input.as_str() );
    cpu.load(opcode);

    let sum = (1..=clock)
        .map(|cycle| {
            cpu.tick();
            crt.tick(cpu.reg_x());
            ( cycle, cpu.reg_x() )
        })
        .filter(|(cycle,_)|
            match sampling_interval.peek() {
                Some(&amp;to_sample) if to_sample.eq(cycle) =&gt; { sampling_interval.next(); true }
                _ =&gt; false
            }
        )
        .map(|(clock, x)| x * clock as isize)
        .sum::&lt;isize&gt;();

    println!("{sum} is the sum of  signal strengths at {:?}", sample_intervals);
}</code></pre>
<p>The main function ties everything together:</p>
<ol>
<li>It defines the specific cycles at which to sample the signal (20, 60, 100, etc.)</li>
<li>It initializes the CRT and CPU</li>
<li>It parses the instructions and loads them into the CPU</li>
<li>It creates a range for all cycles and maps each cycle to:
<ul>
<li>Advance the CPU</li>
<li>Update the CRT</li>
<li>Return the cycle number and register value</li>
</ul>
</li>
<li>It filters for the specific cycles we want to sample</li>
<li>It calculates the signal strength (cycle number Ã— register value) for each sampled cycle</li>
<li>It sums all signal strengths and prints the result</li>
</ol>
<p>The Part 2 output (the eight capital letters) is printed directly by the CRT during simulation.</p>
<h2 id="implementation-notes-8"><a class="header" href="#implementation-notes-8">Implementation Notes</a></h2>
<ul>
<li><strong>State Machine Design</strong>: The CPU is implemented as a state machine that processes instructions cycle-by-cycle</li>
<li><strong>Separation of Concerns</strong>: The CPU and CRT are separate components with their own state and behavior</li>
<li><strong>Pipeline Simulation</strong>: The instruction execution follows a simple pipeline pattern with fetch and execute stages</li>
<li><strong>Functional Programming</strong>: The code uses functional programming patterns like <code>map</code>, <code>filter</code>, and <code>fold</code> for concise data processing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-11-monkey-in-the-middle"><a class="header" href="#day-11-monkey-in-the-middle">Day 11: Monkey in the Middle</a></h1>
<p>Day 11 involves simulating monkeys playing a game of keep-away with items of various worry levels.</p>
<h2 id="problem-overview-10"><a class="header" href="#problem-overview-10">Problem Overview</a></h2>
<p>You need to model a group of monkeys passing items between them according to specific rules. Each monkey:</p>
<ol>
<li>Has a list of items with worry levels</li>
<li>Inspects each item, applying an operation to update its worry level</li>
<li>Tests the worry level to decide which monkey to throw the item to</li>
<li>Keeps track of how many items it inspects</li>
</ol>
<p>The challenge is to determine the level of "monkey business" (product of inspection counts of the most active monkeys) after a number of rounds.</p>
<h2 id="navigation-10"><a class="header" href="#navigation-10">Navigation</a></h2>
<ul>
<li><a href="day11/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day11/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day11/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-11-problem-description"><a class="header" href="#day-11-problem-description">Day 11: Problem Description</a></h1>
<h2 id="monkey-in-the-middle"><a class="header" href="#monkey-in-the-middle">Monkey in the Middle</a></h2>
<p>As you finally start making your way upriver, you realize your pack is much lighter than you remember. Just then, one of the items from your pack goes flying overhead. Monkeys are playing Keep Away with your missing things!</p>
<p>To get your stuff back, you need to be able to predict where the monkeys will throw your items. After some careful observation, you realize the monkeys operate based on <strong>how worried you are about each item</strong>.</p>
<p>You take some notes (your puzzle input) on the items each monkey currently has, how worried you are about those items, and how the monkey makes decisions based on your worry level. For example:</p>
<pre><code>Monkey 0:
  Starting items: 79, 98
  Operation: new = old * 19
  Test: divisible by 23
    If true: throw to monkey 2
    If false: throw to monkey 3

Monkey 1:
  Starting items: 54, 65, 75, 74
  Operation: new = old + 6
  Test: divisible by 19
    If true: throw to monkey 2
    If false: throw to monkey 0

Monkey 2:
  Starting items: 79, 60, 97
  Operation: new = old * old
  Test: divisible by 13
    If true: throw to monkey 1
    If false: throw to monkey 3

Monkey 3:
  Starting items: 74
  Operation: new = old + 3
  Test: divisible by 17
    If true: throw to monkey 0
    If false: throw to monkey 1
</code></pre>
<p>Each monkey has several attributes:</p>
<ul>
<li><code>Starting items</code> lists your <strong>worry level</strong> for each item the monkey is currently holding in the order they will be inspected.</li>
<li><code>Operation</code> shows how your worry level changes as that monkey inspects an item. (An operation like <code>new = old * 5</code> means that your worry level after the monkey inspected the item is five times whatever your worry level was before inspection.)</li>
<li><code>Test</code> shows how the monkey uses your worry level to decide where to throw an item next.
<ul>
<li><code>If true</code> shows what happens with an item if the <code>Test</code> was true.</li>
<li><code>If false</code> shows what happens with an item if the <code>Test</code> was false.</li>
</ul>
</li>
</ul>
<p>After each monkey inspects an item but before it tests your worry level, your relief that the monkey's inspection didn't damage the item causes your worry level to be <strong>divided by three</strong> and rounded down to the nearest integer.</p>
<p>The monkeys take turns inspecting and throwing items. On a single monkey's <strong>turn</strong>, it inspects and throws all of the items it is holding one at a time and in the order listed. Monkey 0 goes first, then monkey 1, and so on until each monkey has had one turn. The process of each monkey taking a single turn is called a <strong>round</strong>.</p>
<p>When a monkey throws an item to another monkey, the item goes on the <strong>end</strong> of the recipient monkey's list. A monkey that starts a round with no items could end up inspecting and throwing many items by the time its turn comes around. If a monkey is holding no items at the start of its turn, its turn ends.</p>
<p>In the above example, the first round proceeds as follows:</p>
<pre><code>Monkey 0:
  Monkey inspects an item with a worry level of 79.
    Worry level is multiplied by 19 to 1501.
    Monkey gets bored with item. Worry level is divided by 3 to 500.
    Current worry level is not divisible by 23.
    Item with worry level 500 is thrown to monkey 3.
  Monkey inspects an item with a worry level of 98.
    Worry level is multiplied by 19 to 1862.
    Monkey gets bored with item. Worry level is divided by 3 to 620.
    Current worry level is not divisible by 23.
    Item with worry level 620 is thrown to monkey 3.
Monkey 1:
  Monkey inspects an item with a worry level of 54.
    Worry level increases by 6 to 60.
    Monkey gets bored with item. Worry level is divided by 3 to 20.
    Current worry level is not divisible by 19.
    Item with worry level 20 is thrown to monkey 0.
  Monkey inspects an item with a worry level of 65.
    Worry level increases by 6 to 71.
    Monkey gets bored with item. Worry level is divided by 3 to 23.
    Current worry level is not divisible by 19.
    Item with worry level 23 is thrown to monkey 0.
  Monkey inspects an item with a worry level of 75.
    Worry level increases by 6 to 81.
    Monkey gets bored with item. Worry level is divided by 3 to 27.
    Current worry level is not divisible by 19.
    Item with worry level 27 is thrown to monkey 0.
  Monkey inspects an item with a worry level of 74.
    Worry level increases by 6 to 80.
    Monkey gets bored with item. Worry level is divided by 3 to 26.
    Current worry level is not divisible by 19.
    Item with worry level 26 is thrown to monkey 0.
Monkey 2:
  Monkey inspects an item with a worry level of 79.
    Worry level is multiplied by itself to 6241.
    Monkey gets bored with item. Worry level is divided by 3 to 2080.
    Current worry level is divisible by 13.
    Item with worry level 2080 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 60.
    Worry level is multiplied by itself to 3600.
    Monkey gets bored with item. Worry level is divided by 3 to 1200.
    Current worry level is not divisible by 13.
    Item with worry level 1200 is thrown to monkey 3.
  Monkey inspects an item with a worry level of 97.
    Worry level is multiplied by itself to 9409.
    Monkey gets bored with item. Worry level is divided by 3 to 3136.
    Current worry level is not divisible by 13.
    Item with worry level 3136 is thrown to monkey 3.
Monkey 3:
  Monkey inspects an item with a worry level of 74.
    Worry level increases by 3 to 77.
    Monkey gets bored with item. Worry level is divided by 3 to 25.
    Current worry level is not divisible by 17.
    Item with worry level 25 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 500.
    Worry level increases by 3 to 503.
    Monkey gets bored with item. Worry level is divided by 3 to 167.
    Current worry level is not divisible by 17.
    Item with worry level 167 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 620.
    Worry level increases by 3 to 623.
    Monkey gets bored with item. Worry level is divided by 3 to 207.
    Current worry level is not divisible by 17.
    Item with worry level 207 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 1200.
    Worry level increases by 3 to 1203.
    Monkey gets bored with item. Worry level is divided by 3 to 401.
    Current worry level is not divisible by 17.
    Item with worry level 401 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 3136.
    Worry level increases by 3 to 3139.
    Monkey gets bored with item. Worry level is divided by 3 to 1046.
    Current worry level is not divisible by 17.
    Item with worry level 1046 is thrown to monkey 1.
</code></pre>
<p>After round 1, the monkeys are holding items with these worry levels:</p>
<pre><code>Monkey 0: 20, 23, 27, 26
Monkey 1: 2080, 25, 167, 207, 401, 1046
Monkey 2: 
Monkey 3: 
</code></pre>
<p>Monkeys 2 and 3 aren't holding any items at the end of the round; they both inspected items during the round and threw them all before the round ended.</p>
<p>This process continues for a few more rounds:</p>
<pre><code>After round 2, the monkeys are holding items with these worry levels:
Monkey 0: 695, 10, 71, 135, 350
Monkey 1: 43, 49, 58, 55, 362
Monkey 2: 
Monkey 3: 

After round 3, the monkeys are holding items with these worry levels:
Monkey 0: 16, 18, 21, 20, 122
Monkey 1: 1468, 22, 150, 286, 739
Monkey 2: 
Monkey 3: 

After round 4, the monkeys are holding items with these worry levels:
Monkey 0: 491, 9, 52, 97, 248, 34
Monkey 1: 39, 45, 43, 258
Monkey 2: 
Monkey 3: 

After round 5, the monkeys are holding items with these worry levels:
Monkey 0: 15, 17, 16, 88, 1037
Monkey 1: 20, 110, 205, 524, 72
Monkey 2: 
Monkey 3: 

After round 6, the monkeys are holding items with these worry levels:
Monkey 0: 8, 70, 176, 26, 34
Monkey 1: 481, 32, 36, 186, 2190
Monkey 2: 
Monkey 3: 

After round 7, the monkeys are holding items with these worry levels:
Monkey 0: 162, 12, 14, 64, 732, 17
Monkey 1: 148, 372, 55, 72
Monkey 2: 
Monkey 3: 

After round 8, the monkeys are holding items with these worry levels:
Monkey 0: 51, 126, 20, 26, 136
Monkey 1: 343, 26, 30, 1546, 36
Monkey 2: 
Monkey 3: 

After round 9, the monkeys are holding items with these worry levels:
Monkey 0: 116, 10, 12, 517, 14
Monkey 1: 108, 267, 43, 55, 288
Monkey 2: 
Monkey 3: 

After round 10, the monkeys are holding items with these worry levels:
Monkey 0: 91, 16, 20, 98
Monkey 1: 481, 245, 22, 26, 1092, 30
Monkey 2: 
Monkey 3: 

...

After round 15, the monkeys are holding items with these worry levels:
Monkey 0: 83, 44, 8, 184, 9, 20, 26, 102
Monkey 1: 110, 36
Monkey 2: 
Monkey 3: 

...

After round 20, the monkeys are holding items with these worry levels:
Monkey 0: 10, 12, 14, 26, 34
Monkey 1: 245, 93, 53, 199, 115
Monkey 2: 
Monkey 3: 
</code></pre>
<p>Chasing all of the monkeys at once is impossible; you're going to have to focus on the <strong>two most active</strong> monkeys if you want any hope of getting your stuff back. Count the <strong>total number of times each monkey inspects items</strong> over 20 rounds:</p>
<pre><code>Monkey 0 inspected items 101 times.
Monkey 1 inspected items 95 times.
Monkey 2 inspected items 7 times.
Monkey 3 inspected items 105 times.
</code></pre>
<p>In this example, the two most active monkeys inspected items 101 and 105 times. The level of <strong>monkey business</strong> in this situation can be found by multiplying these together: <strong>10605</strong>.</p>
<h2 id="part-1-10"><a class="header" href="#part-1-10">Part 1</a></h2>
<p>Figure out which monkeys to chase by counting how many items they inspect over 20 rounds. <strong>What is the level of monkey business after 20 rounds of stuff-slinging simian shenanigans?</strong></p>
<h2 id="part-2-10"><a class="header" href="#part-2-10">Part 2</a></h2>
<p>You're worried you might not ever get your items back. So worried, in fact, that your relief that a monkey's inspection didn't damage an item <strong>no longer causes your worry level to be divided by three</strong>.</p>
<p>Unfortunately, that relief was all that was keeping your worry levels from reaching ridiculous levels. You'll need to <strong>find another way to keep your worry levels manageable</strong>.</p>
<p>At this rate, you might be putting up with these monkeys for a <strong>very long time</strong> - possibly <strong>10000 rounds</strong>!</p>
<p>With these new rules, you can still figure out the monkey business after 10000 rounds. Using the same example above:</p>
<pre><code>== After round 1 ==
Monkey 0 inspected items 2 times.
Monkey 1 inspected items 4 times.
Monkey 2 inspected items 3 times.
Monkey 3 inspected items 6 times.

== After round 20 ==
Monkey 0 inspected items 99 times.
Monkey 1 inspected items 97 times.
Monkey 2 inspected items 8 times.
Monkey 3 inspected items 103 times.

== After round 1000 ==
Monkey 0 inspected items 5204 times.
Monkey 1 inspected items 4792 times.
Monkey 2 inspected items 199 times.
Monkey 3 inspected items 5192 times.

== After round 2000 ==
Monkey 0 inspected items 10419 times.
Monkey 1 inspected items 9577 times.
Monkey 2 inspected items 392 times.
Monkey 3 inspected items 10391 times.

== After round 3000 ==
Monkey 0 inspected items 15638 times.
Monkey 1 inspected items 14358 times.
Monkey 2 inspected items 587 times.
Monkey 3 inspected items 15593 times.

== After round 4000 ==
Monkey 0 inspected items 20858 times.
Monkey 1 inspected items 19138 times.
Monkey 2 inspected items 780 times.
Monkey 3 inspected items 20797 times.

== After round 5000 ==
Monkey 0 inspected items 26075 times.
Monkey 1 inspected items 23921 times.
Monkey 2 inspected items 974 times.
Monkey 3 inspected items 26000 times.

== After round 6000 ==
Monkey 0 inspected items 31294 times.
Monkey 1 inspected items 28702 times.
Monkey 2 inspected items 1165 times.
Monkey 3 inspected items 31204 times.

== After round 7000 ==
Monkey 0 inspected items 36508 times.
Monkey 1 inspected items 33488 times.
Monkey 2 inspected items 1360 times.
Monkey 3 inspected items 36400 times.

== After round 8000 ==
Monkey 0 inspected items 41728 times.
Monkey 1 inspected items 38268 times.
Monkey 2 inspected items 1553 times.
Monkey 3 inspected items 41606 times.

== After round 9000 ==
Monkey 0 inspected items 46945 times.
Monkey 1 inspected items 43051 times.
Monkey 2 inspected items 1746 times.
Monkey 3 inspected items 46807 times.

== After round 10000 ==
Monkey 0 inspected items 52166 times.
Monkey 1 inspected items 47830 times.
Monkey 2 inspected items 1938 times.
Monkey 3 inspected items 52013 times.
</code></pre>
<p>After 10000 rounds, the two most active monkeys inspected items 52166 and 52013 times. Multiplying these together, the level of monkey business in this situation is now <strong>2713310158</strong>.</p>
<p><strong>Worry levels are no longer divided by three after each item is inspected; you'll need to find another way to keep your worry levels manageable. Starting again from the initial state in your puzzle input, what is the level of monkey business after 10000 rounds?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-11-solution-explanation"><a class="header" href="#day-11-solution-explanation">Day 11: Solution Explanation</a></h1>
<h2 id="approach-10"><a class="header" href="#approach-10">Approach</a></h2>
<p>Day 11 involves simulating monkeys playing keep-away with items, applying operations to worry levels, and passing items between monkeys based on tests. The key challenges are:</p>
<ol>
<li><strong>Parsing the monkey specifications</strong> from the input text</li>
<li><strong>Modeling monkeys and their behavior</strong> with appropriate data structures</li>
<li><strong>Simulating the rounds</strong> of monkey inspections and item throwing</li>
<li><strong>Managing worry levels</strong> efficiently, especially for Part 2</li>
</ol>
<p>The solution uses a combination of custom data types and simulation logic to model the monkey behavior accurately.</p>
<h2 id="implementation-details-10"><a class="header" href="#implementation-details-10">Implementation Details</a></h2>
<h3 id="data-structures-3"><a class="header" href="#data-structures-3">Data Structures</a></h3>
<p>First, we define a type for representing worry levels and the operation that monkeys can perform:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type WorryType = u64;
const WORRY_DEF: WorryType = 0;

#[derive(Debug)]
enum Operation {
    Add(WorryType),
    Mul(WorryType),
}
<span class="boring">}</span></code></pre></pre>
<p><code>WorryType</code> is set to <code>u64</code> to handle the large numbers that can occur during the simulation. The <code>Operation</code> enum represents the two possible operations a monkey can perform: addition or multiplication.</p>
<p>The <code>Monkey</code> struct represents all the properties of a monkey:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Monkey {
    name: usize,
    items: VecDeque&lt;WorryType&gt;,
    op: Operation,
    test: WorryType,
    send: (usize,usize),
    inspect: usize
}
<span class="boring">}</span></code></pre></pre>
<p>Each monkey has:</p>
<ul>
<li>A name (index)</li>
<li>A queue of items (worry levels)</li>
<li>An operation to apply when inspecting items</li>
<li>A divisibility test value</li>
<li>Two target monkeys to throw to based on the test result</li>
<li>A counter for the number of inspections performed</li>
</ul>
<h3 id="parsing-input-4"><a class="header" href="#parsing-input-4">Parsing Input</a></h3>
<p>The solution uses Rust's <code>FromStr</code> trait to parse monkey specifications from the input text:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FromStr for Monkey {
    type Err = ();

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let mut monkey = Cell::new(Monkey::default());
        s.lines()
            .map(|line| line.trim().split(':').collect::&lt;Vec&lt;_&gt;&gt;())
            .map(|parts|{
                let m = monkey.get_mut();
                match parts[0] {
                    "Starting items" =&gt; {
                        parts[1].split(',')
                            .map(|n| WorryType::from_str(n.trim()).unwrap() )
                            .all(|a| { m.items.push_back(a); true });
                    }
                    "Operation" =&gt; {
                        let [op,act] = parts[1]
                            .split("new = old ")
                            .last()
                            .unwrap()
                            .split(' ')
                            .collect::&lt;Vec&lt;_&gt;&gt;()[..] else { panic!("Operation: cannot be extracted") };
                        let a = WorryType::from_str(act);
                        match (op,a) {
                            ("*",Ok(n)) =&gt; m.op = Operation::Mul(n),
                            ("+",Ok(n)) =&gt; m.op = Operation::Add(n),
                            ("*",_) =&gt; m.op = Operation::Mul(WORRY_DEF),
                            ("+",_) =&gt; m.op = Operation::Add(WORRY_DEF),
                            _ =&gt; {}
                        }
                    }
                    "Test" =&gt; {
                        let s = parts[1].trim().split("divisible by").last().unwrap().trim();
                        m.test = WorryType::from_str(s).unwrap();
                    }
                    "If true" =&gt; {
                        let s = parts[1].trim().split("throw to monkey").last().unwrap().trim();
                        m.send.0 = usize::from_str(s).unwrap();
                    }
                    "If false" =&gt; {
                        let s = parts[1].trim().split("throw to monkey").last().unwrap().trim();
                        m.send.1 = usize::from_str(s).unwrap();
                    }
                    name =&gt; {
                        m.name = usize::from_str(name.split(' ').last().unwrap().trim()).unwrap();
                    }
                }
                true
            })
            .all(|run| run);

        Ok(monkey.take())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This implementation parses each line of the monkey specification and sets the corresponding fields in the <code>Monkey</code> struct.</p>
<h3 id="monkey-behavior"><a class="header" href="#monkey-behavior">Monkey Behavior</a></h3>
<p>The <code>Monkey</code> struct implements several methods to model its behavior:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Monkey {
    fn parse_text(input: &amp;str) -&gt; Vec&lt;Monkey&gt; {
        input.split("\n\n")
            .map(|monkey| Monkey::from_str(monkey).unwrap() )
            .fold(Vec::new(), |mut out, monkey|{
                out.push(monkey);
                out
            })
    }
    
    fn catch(&amp;mut self, item: WorryType) {
        self.items.push_back(item)
    }
    
    fn throw(&amp;self, worry: WorryType) -&gt; (usize, WorryType) {
        if (worry % self.test) == 0 as WorryType {
            // Current worry level is divisible by the test value
            (self.send.0, worry)
        } else {
            // Current worry level is not divisible by the test value
            (self.send.1, worry)
        }
    }
    
    fn observe(&amp;mut self, div: WorryType) -&gt; Option&lt;(usize, WorryType)&gt; {
        self.inspect += 1;
        // Monkey inspects an item with a worry level
        match self.items.pop_front() {
            Some(mut worry) =&gt; {
                // Apply the modulo to keep worry levels manageable
                worry %= div;
                Some( self.throw(
                    match self.op {
                        Operation::Add(WORRY_DEF) =&gt; worry.add(worry),
                        Operation::Mul(WORRY_DEF) =&gt; worry.mul(worry),
                        Operation::Add(n) =&gt; worry + n,
                        Operation::Mul(n) =&gt; worry * n,
                    }
                ))
            }
            None =&gt; None
        }
    }
    
    fn observe_all(&amp;mut self, div: WorryType) -&gt; Vec&lt;Option&lt;(usize, WorryType)&gt;&gt; {
        (0..self.items.len())
            .fold(vec![], |mut out, _|{
                out.push( self.observe(div));
                out
            })
    }
    
    fn inspections(&amp;self) -&gt; usize {
        self.inspect
    }
}
<span class="boring">}</span></code></pre></pre>
<p>These methods handle:</p>
<ul>
<li>Parsing all monkeys from the input text</li>
<li>Catching items thrown by other monkeys</li>
<li>Throwing items to other monkeys based on the test result</li>
<li>Observing (inspecting) an item and updating its worry level</li>
<li>Observing all items in a monkey's possession</li>
<li>Tracking the number of inspections</li>
</ul>
<h3 id="managing-worry-levels"><a class="header" href="#managing-worry-levels">Managing Worry Levels</a></h3>
<p>In Part 2, the challenge is managing the worry levels since they're no longer divided by 3 and can grow extremely large. The key insight is that we don't need the exact worry levels, only whether they're divisible by the monkeys' test values.</p>
<p>Using the Chinese Remainder Theorem, we can apply modular arithmetic with the product of all monkeys' test values as the modulus. This keeps the worry levels manageable while preserving divisibility properties:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let div_product: WorryType = monkeys.iter().map(|m| m.test).product();
<span class="boring">}</span></code></pre></pre>
<p>This technique is applied in the <code>observe</code> method where we calculate <code>worry %= div</code>.</p>
<h3 id="simulation-logic"><a class="header" href="#simulation-logic">Simulation Logic</a></h3>
<p>The main simulation logic runs for the specified number of rounds and tracks the items as they're thrown between monkeys:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Queue for passing items around the monkeys
let mut queue = vec![VecDeque::&lt;WorryType&gt;::new(); monkeys.len()];

(0..10000).all(|_| {
    monkeys.iter_mut()
        .map(|monkey| {
            // pull from queue anything thrown at him
            while let Some(item) = queue[monkey.name].pop_front() {
                monkey.catch(item)
            };

            // observe and throw back at
            monkey.observe_all(div_product)
                .into_iter()
                .all(|throw|
                    throw.map(
                        |(monkey,item)| queue[monkey].push_back(item)
                    ).is_some()
                )
        })
        .all(|run| run)
});
<span class="boring">}</span></code></pre></pre>
<p>The simulation:</p>
<ol>
<li>Iterates through each round</li>
<li>For each monkey, processes all items in its possession</li>
<li>Calculates new worry levels and determines target monkeys</li>
<li>Uses queues to handle the items being thrown between monkeys</li>
</ol>
<h3 id="calculating-monkey-business"><a class="header" href="#calculating-monkey-business">Calculating Monkey Business</a></h3>
<p>Finally, the solution calculates the level of monkey business by multiplying the inspection counts of the two most active monkeys:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>monkeys.sort_by(|a,b| b.inspect.cmp(&amp;a.inspect));
println!("level of monkey business after 10000 rounds : {:?}",
         monkeys[0].inspections() * monkeys[1].inspections()
);
<span class="boring">}</span></code></pre></pre>
<h2 id="algorithmic-analysis-1"><a class="header" href="#algorithmic-analysis-1">Algorithmic Analysis</a></h2>
<h3 id="time-complexity-6"><a class="header" href="#time-complexity-6">Time Complexity</a></h3>
<ul>
<li>Parsing input: O(n) where n is the length of the input text</li>
<li>Simulation: O(r * m * i) where:
<ul>
<li>r is the number of rounds (10,000 for Part 2)</li>
<li>m is the number of monkeys</li>
<li>i is the average number of items per monkey</li>
</ul>
</li>
</ul>
<h3 id="space-complexity-6"><a class="header" href="#space-complexity-6">Space Complexity</a></h3>
<ul>
<li>O(m * i) for storing the monkeys and their items</li>
<li>O(m) for the queues used to pass items between monkeys</li>
</ul>
<h2 id="key-insights"><a class="header" href="#key-insights">Key Insights</a></h2>
<h3 id="chinese-remainder-theorem-application"><a class="header" href="#chinese-remainder-theorem-application">Chinese Remainder Theorem Application</a></h3>
<p>The key insight for Part 2 is using modular arithmetic to manage worry levels. Since we only care about divisibility by each monkey's test value, we can use the product of all test values as a modulus.</p>
<p>This works because if we have:</p>
<ul>
<li>Original worry level: W</li>
<li>Modulus: M = product of all test divisors</li>
<li>Remainder: R = W mod M</li>
</ul>
<p>Then for any test divisor D that is a factor of M:</p>
<ul>
<li>W is divisible by D if and only if R is divisible by D</li>
</ul>
<p>This allows us to keep the worry levels manageable while preserving the divisibility properties needed for the monkey's tests.</p>
<h2 id="alternative-approaches-9"><a class="header" href="#alternative-approaches-9">Alternative Approaches</a></h2>
<h3 id="direct-divisibility-tracking"><a class="header" href="#direct-divisibility-tracking">Direct Divisibility Tracking</a></h3>
<p>Instead of tracking the actual worry levels, we could track just the remainders when divided by each monkey's test value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Item {
    remainders: HashMap&lt;WorryType, WorryType&gt;, // Map from test value to remainder
}
<span class="boring">}</span></code></pre></pre>
<p>This would allow us to update the remainders directly without ever dealing with the full worry values. However, this is more complex to implement and likely not necessary given the effectiveness of the modulo approach.</p>
<h3 id="simulation-optimization"><a class="header" href="#simulation-optimization">Simulation Optimization</a></h3>
<p>For a large number of rounds, we could look for patterns in the monkey's behavior and potentially skip ahead in the simulation. However, this would add complexity and might not be necessary for the given constraints.</p>
<h2 id="conclusion-8"><a class="header" href="#conclusion-8">Conclusion</a></h2>
<p>This solution demonstrates how to model a complex system with multiple interacting entities. The key insights are:</p>
<ol>
<li>Using appropriate data structures to model the monkeys and their behavior</li>
<li>Applying modular arithmetic to manage worry levels efficiently</li>
<li>Using queues to handle the passing of items between monkeys</li>
</ol>
<p>These techniques allow us to simulate the monkey's behavior for a large number of rounds without running into numerical overflow issues.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-11-code"><a class="header" href="#day-11-code">Day 11: Code</a></h1>
<p>Below is the complete code for Day 11's solution, which simulates monkeys passing items with worry levels.</p>
<h2 id="full-solution-10"><a class="header" href="#full-solution-10">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">use std::cell::Cell;
use std::collections::VecDeque;
use std::ops::{Add, Mul};
use std::str::FromStr;

fn main() {

    let input = std::fs::read_to_string("src/bin/day11_input.txt").expect("Ops!");

    let mut monkeys = Monkey::parse_text(input.as_str());
    let div_product: WorryType = monkeys.iter().map(|m| m.test).product();

    // Queue for passing items around the monkeys
    let mut queue = vec![VecDeque::&lt;WorryType&gt;::new(); monkeys.len()];

    (0..10000).all(|_| {
        monkeys.iter_mut()
            .map(|monkey| {

                // pull from queue anything thrown at him
                while let Some(item) = queue[monkey.name].pop_front() {
                    monkey.catch(item)
                };

                // observe and throw back at
                monkey.observe_all(div_product)
                    .into_iter()
                    // .filter_map(|throw| throw)
                    .all(|throw|
                        throw.map(
                            |(monkey,item)| queue[monkey].push_back(item)
                        ).is_some()
                    )
            })
            .all(|run| run)
    });

    monkeys.sort_by(|a,b| b.inspect.cmp(&amp;a.inspect));
    println!("level of monkey business after 10000 rounds : {:?}",
             monkeys[0].inspections() * monkeys[1].inspections()
    );
}


type WorryType = u64;
const WORRY_DEF: WorryType = 0;

#[derive(Debug)]
enum Operation {
    Add(WorryType),
    Mul(WorryType),
}
#[derive(Debug)]
struct Monkey {
    name: usize,
    items: VecDeque&lt;WorryType&gt;,
    op: Operation,
    test: WorryType,
    send: (usize,usize),
    inspect: usize
}
impl Monkey {
    fn parse_text(input: &amp;str) -&gt; Vec&lt;Monkey&gt; {
        input.split("\n\n")
            .map(|monkey| Monkey::from_str(monkey).unwrap() )
            .fold(Vec::new(), |mut out, monkey|{
                out.push(monkey);
                out
            })
    }
    fn catch(&amp;mut self, item: WorryType) {
        self.items.push_back(item)
    }
    fn throw(&amp;self, worry: WorryType) -&gt; (usize, WorryType) {
        if (worry % self.test) == 0 as WorryType {
            // Current worry level is divisible by 23.
            // Sent to Monkey
            (self.send.0, worry)
        } else {
            // Current worry level is not divisible by 23.
            // Sent to Monkey
            (self.send.1, worry)
        }
    }
    fn observe(&amp;mut self, div: WorryType) -&gt; Option&lt;(usize, WorryType)&gt; {
        self.inspect += 1;
        //   Monkey inspects an item with a worry level of 79.
        match self.items.pop_front() {
            Some(mut worry) =&gt; {
                //     Worry level is multiplied by 19 to 1501.
                //     Monkey gets bored with item. Worry level is divided by 3 to 500.
                worry %= div;
                Some( self.throw(
                    match self.op {
                        Operation::Add(WORRY_DEF) =&gt; worry.add(worry),
                        Operation::Mul(WORRY_DEF) =&gt; worry.mul(worry),
                        Operation::Add(n) =&gt; worry + n,
                        Operation::Mul(n) =&gt; worry * n,
                    }
                ))
            }
            None =&gt; None
        }
    }
    fn observe_all(&amp;mut self, div: WorryType) -&gt; Vec&lt;Option&lt;(usize, WorryType)&gt;&gt; {
        (0..self.items.len())
            .fold(vec![], |mut out, _|{
                out.push( self.observe(div));
                out
            })
    }
    fn inspections(&amp;self) -&gt; usize {
        self.inspect
    }
}
impl Default for Monkey {
    fn default() -&gt; Self {
        Monkey {
            name: 0,
            items: VecDeque::new(),
            op: Operation::Add(WORRY_DEF),
            test: WORRY_DEF,
            send: (0,0),
            inspect: 0
        }
    }
}
impl FromStr for Monkey {
    type Err = ();

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let mut monkey = Cell::new(Monkey::default());
        s.lines()
            .map(|line| line.trim().split(':').collect::&lt;Vec&lt;_&gt;&gt;())
            .map(|parts|{
                let m = monkey.get_mut();
                match parts[0] {
                    "Starting items" =&gt; {
                        parts[1].split(',')
                            .map(|n| WorryType::from_str(n.trim()).unwrap() )
                            .all(|a| { m.items.push_back(a); true });
                    }
                    "Operation" =&gt; {
                        let [op,act] = parts[1]
                            .split("new = old ")
                            .last()
                            .unwrap()
                            .split(' ')
                            .collect::&lt;Vec&lt;_&gt;&gt;()[..] else { panic!("Operation: cannot be extracted") };
                        let a = WorryType::from_str(act);
                        match (op,a) {
                            ("*",Ok(n)) =&gt; m.op = Operation::Mul(n),
                            ("+",Ok(n)) =&gt; m.op = Operation::Add(n),
                            ("*",_) =&gt; m.op = Operation::Mul(WORRY_DEF),
                            ("+",_) =&gt; m.op = Operation::Add(WORRY_DEF),
                            _ =&gt; {}
                        }
                    }
                    "Test" =&gt; {
                        let s = parts[1].trim().split("divisible by").last().unwrap().trim();
                        m.test = WorryType::from_str(s).unwrap();
                    }
                    "If true" =&gt; {
                        let s = parts[1].trim().split("throw to monkey").last().unwrap().trim();
                        m.send.0 = usize::from_str(s).unwrap();
                    }
                    "If false" =&gt; {
                        let s = parts[1].trim().split("throw to monkey").last().unwrap().trim();
                        m.send.1 = usize::from_str(s).unwrap();
                    }
                    name =&gt; {
                        m.name = usize::from_str(name.split(' ').last().unwrap().trim()).unwrap();
                    }
                }
                true
            })
            .all(|run| run);

        Ok(monkey.take())
    }
}</code></pre>
<h2 id="code-walkthrough-10"><a class="header" href="#code-walkthrough-10">Code Walkthrough</a></h2>
<h3 id="data-types-and-structures"><a class="header" href="#data-types-and-structures">Data Types and Structures</a></h3>
<pre><code class="language-rust no_run noplayground">type WorryType = u64;
const WORRY_DEF: WorryType = 0;

#[derive(Debug)]
enum Operation {
    Add(WorryType),
    Mul(WorryType),
}
#[derive(Debug)]
struct Monkey {
    name: usize,
    items: VecDeque&lt;WorryType&gt;,
    op: Operation,
    test: WorryType,
    send: (usize,usize),
    inspect: usize
}</code></pre>
<p>The solution defines:</p>
<ul>
<li><code>WorryType</code> as <code>u64</code> to handle large worry levels</li>
<li>An <code>Operation</code> enum to represent addition or multiplication operations</li>
<li>A <code>Monkey</code> struct with properties for:
<ul>
<li><code>name</code>: The monkey's index</li>
<li><code>items</code>: A queue of worry levels for items the monkey is holding</li>
<li><code>op</code>: The operation the monkey performs on items</li>
<li><code>test</code>: The divisibility test value</li>
<li><code>send</code>: A tuple with indices of monkeys to throw to (true case, false case)</li>
<li><code>inspect</code>: A counter for the number of inspections</li>
</ul>
</li>
</ul>
<h3 id="monkey-behavior-1"><a class="header" href="#monkey-behavior-1">Monkey Behavior</a></h3>
<pre><code class="language-rust no_run noplayground">impl Monkey {
    fn parse_text(input: &amp;str) -&gt; Vec&lt;Monkey&gt; {
        input.split("\n\n")
            .map(|monkey| Monkey::from_str(monkey).unwrap() )
            .fold(Vec::new(), |mut out, monkey|{
                out.push(monkey);
                out
            })
    }
    fn catch(&amp;mut self, item: WorryType) {
        self.items.push_back(item)
    }
    fn throw(&amp;self, worry: WorryType) -&gt; (usize, WorryType) {
        if (worry % self.test) == 0 as WorryType {
            // Current worry level is divisible by 23.
            // Sent to Monkey
            (self.send.0, worry)
        } else {
            // Current worry level is not divisible by 23.
            // Sent to Monkey
            (self.send.1, worry)
        }
    }
    fn observe(&amp;mut self, div: WorryType) -&gt; Option&lt;(usize, WorryType)&gt; {
        self.inspect += 1;
        //   Monkey inspects an item with a worry level of 79.
        match self.items.pop_front() {
            Some(mut worry) =&gt; {
                //     Worry level is multiplied by 19 to 1501.
                //     Monkey gets bored with item. Worry level is divided by 3 to 500.
                worry %= div;
                Some( self.throw(
                    match self.op {
                        Operation::Add(WORRY_DEF) =&gt; worry.add(worry),
                        Operation::Mul(WORRY_DEF) =&gt; worry.mul(worry),
                        Operation::Add(n) =&gt; worry + n,
                        Operation::Mul(n) =&gt; worry * n,
                    }
                ))
            }
            None =&gt; None
        }
    }
    fn observe_all(&amp;mut self, div: WorryType) -&gt; Vec&lt;Option&lt;(usize, WorryType)&gt;&gt; {
        (0..self.items.len())
            .fold(vec![], |mut out, _|{
                out.push( self.observe(div));
                out
            })
    }
    fn inspections(&amp;self) -&gt; usize {
        self.inspect
    }
}</code></pre>
<p>The <code>Monkey</code> implementation includes methods for:</p>
<ul>
<li><code>parse_text</code>: Parsing all monkeys from the input</li>
<li><code>catch</code>: Adding an item to the monkey's queue</li>
<li><code>throw</code>: Determining which monkey to throw to based on the test</li>
<li><code>observe</code>: Processing a single item:
<ul>
<li>Incrementing the inspection counter</li>
<li>Taking an item from the front of the queue</li>
<li>Applying modulo to manage worry levels</li>
<li>Applying the operation to update the worry level</li>
<li>Determining which monkey to throw to</li>
</ul>
</li>
<li><code>observe_all</code>: Processing all items a monkey is holding</li>
<li><code>inspections</code>: Returning the inspection count</li>
</ul>
<h3 id="parsing-logic"><a class="header" href="#parsing-logic">Parsing Logic</a></h3>
<pre><code class="language-rust no_run noplayground">impl Default for Monkey {
    fn default() -&gt; Self {
        Monkey {
            name: 0,
            items: VecDeque::new(),
            op: Operation::Add(WORRY_DEF),
            test: WORRY_DEF,
            send: (0,0),
            inspect: 0
        }
    }
}
impl FromStr for Monkey {
    type Err = ();

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let mut monkey = Cell::new(Monkey::default());
        s.lines()
            .map(|line| line.trim().split(':').collect::&lt;Vec&lt;_&gt;&gt;())
            .map(|parts|{
                let m = monkey.get_mut();
                match parts[0] {
                    "Starting items" =&gt; {
                        parts[1].split(',')
                            .map(|n| WorryType::from_str(n.trim()).unwrap() )
                            .all(|a| { m.items.push_back(a); true });
                    }
                    "Operation" =&gt; {
                        let [op,act] = parts[1]
                            .split("new = old ")
                            .last()
                            .unwrap()
                            .split(' ')
                            .collect::&lt;Vec&lt;_&gt;&gt;()[..] else { panic!("Operation: cannot be extracted") };
                        let a = WorryType::from_str(act);
                        match (op,a) {
                            ("*",Ok(n)) =&gt; m.op = Operation::Mul(n),
                            ("+",Ok(n)) =&gt; m.op = Operation::Add(n),
                            ("*",_) =&gt; m.op = Operation::Mul(WORRY_DEF),
                            ("+",_) =&gt; m.op = Operation::Add(WORRY_DEF),
                            _ =&gt; {}
                        }
                    }
                    "Test" =&gt; {
                        let s = parts[1].trim().split("divisible by").last().unwrap().trim();
                        m.test = WorryType::from_str(s).unwrap();
                    }
                    "If true" =&gt; {
                        let s = parts[1].trim().split("throw to monkey").last().unwrap().trim();
                        m.send.0 = usize::from_str(s).unwrap();
                    }
                    "If false" =&gt; {
                        let s = parts[1].trim().split("throw to monkey").last().unwrap().trim();
                        m.send.1 = usize::from_str(s).unwrap();
                    }
                    name =&gt; {
                        m.name = usize::from_str(name.split(' ').last().unwrap().trim()).unwrap();
                    }
                }
                true
            })
            .all(|run| run);

        Ok(monkey.take())
    }
}</code></pre>
<p>The parsing logic includes:</p>
<ul>
<li>A <code>Default</code> implementation for <code>Monkey</code> providing initial values</li>
<li>An implementation of <code>FromStr</code> for parsing monkey specifications</li>
<li>Logic for parsing each line of the monkey description based on field names</li>
<li>Special handling for operations that reference "old" (the current worry level)</li>
</ul>
<h3 id="main-simulation-1"><a class="header" href="#main-simulation-1">Main Simulation</a></h3>
<pre><code class="language-rust no_run noplayground">fn main() {

    let input = std::fs::read_to_string("src/bin/day11_input.txt").expect("Ops!");

    let mut monkeys = Monkey::parse_text(input.as_str());
    let div_product: WorryType = monkeys.iter().map(|m| m.test).product();

    // Queue for passing items around the monkeys
    let mut queue = vec![VecDeque::&lt;WorryType&gt;::new(); monkeys.len()];

    (0..10000).all(|_| {
        monkeys.iter_mut()
            .map(|monkey| {

                // pull from queue anything thrown at him
                while let Some(item) = queue[monkey.name].pop_front() {
                    monkey.catch(item)
                };

                // observe and throw back at
                monkey.observe_all(div_product)
                    .into_iter()
                    // .filter_map(|throw| throw)
                    .all(|throw|
                        throw.map(
                            |(monkey,item)| queue[monkey].push_back(item)
                        ).is_some()
                    )
            })
            .all(|run| run)
    });

    monkeys.sort_by(|a,b| b.inspect.cmp(&amp;a.inspect));
    println!("level of monkey business after 10000 rounds : {:?}",
             monkeys[0].inspections() * monkeys[1].inspections()
    );
}
</code></pre>
<p>The main simulation logic:</p>
<ol>
<li>Reads and parses the input</li>
<li>Calculates the product of all test divisors to manage worry levels</li>
<li>Creates queues for passing items between monkeys</li>
<li>Runs the simulation for 10,000 rounds:
<ul>
<li>For each monkey, processes all items it's holding</li>
<li>Updates worry levels and determines target monkeys</li>
<li>Uses queues to pass items between monkeys</li>
</ul>
</li>
<li>Sorts monkeys by inspection count and calculates the "monkey business" level</li>
</ol>
<h2 id="implementation-notes-9"><a class="header" href="#implementation-notes-9">Implementation Notes</a></h2>
<ul>
<li><strong>Chinese Remainder Theorem</strong>: The solution uses modular arithmetic with <code>div_product</code> to keep worry levels manageable while preserving divisibility properties</li>
<li><strong>Queue-based Communication</strong>: Items are passed between monkeys using queues, allowing each monkey to process all its items before moving to the next monkey</li>
<li><strong>Functional Programming Style</strong>: The code uses functional programming patterns like <code>map</code>, <code>fold</code>, and method chaining</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-12-hill-climbing-algorithm"><a class="header" href="#day-12-hill-climbing-algorithm">Day 12: Hill Climbing Algorithm</a></h1>
<p>Day 12 involves finding the shortest path through a grid of varying elevations.</p>
<h2 id="problem-overview-11"><a class="header" href="#problem-overview-11">Problem Overview</a></h2>
<p>You need to navigate a heightmap representing a hilly area, finding the shortest path from a starting position to an ending position. The key constraints are:</p>
<ol>
<li>You can only move to adjacent squares that are at most one unit higher than your current position</li>
<li>You can move to squares of any lower elevation</li>
<li>For Part 1, you need to find the shortest path from a specific starting point to a specific ending point</li>
<li>For Part 2, you need to find the shortest path from any lowest-elevation square to the ending point</li>
</ol>
<p>This problem tests your ability to implement pathfinding algorithms, specifically breadth-first search (BFS), on a 2D grid with special movement constraints.</p>
<h2 id="navigation-11"><a class="header" href="#navigation-11">Navigation</a></h2>
<ul>
<li><a href="day12/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day12/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day12/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-12-problem-description"><a class="header" href="#day-12-problem-description">Day 12: Problem Description</a></h1>
<h2 id="hill-climbing-algorithm"><a class="header" href="#hill-climbing-algorithm">Hill Climbing Algorithm</a></h2>
<p>You try contacting the Elves using your handheld device, but the river you're following must be too low to get a decent signal.</p>
<p>You ask the device for a heightmap of the surrounding area (your puzzle input). The heightmap shows the local area from above broken into a grid; the elevation of each square of the grid is given by a single lowercase letter, where <code>a</code> is the lowest elevation, <code>b</code> is the next-lowest, and so on up to the highest elevation, <code>z</code>.</p>
<p>Also included on the heightmap are marks for your current position (<code>S</code>) and the location that should get the best signal (<code>E</code>). Your current position (<code>S</code>) has elevation <code>a</code>, and the location that should get the best signal (<code>E</code>) has elevation <code>z</code>.</p>
<p>You'd like to reach <code>E</code>, but to save energy, you should do it in <strong>as few steps as possible</strong>. During each step, you can move exactly one square up, down, left, or right. To avoid needing to get out your climbing gear, the elevation of the destination square can be <strong>at most one higher</strong> than the elevation of your current square; that is, if your current elevation is <code>m</code>, you could step to elevation <code>n</code>, but not to elevation <code>o</code>. (This also means that the elevation of the destination square can be much lower than the elevation of your current square.)</p>
<p>For example:</p>
<pre><code>Sabqponm
abcryxxl
accszExk
acctuvwj
abdefghi
</code></pre>
<p>Here, you start in the top-left corner; your goal is near the middle. You could start by moving down or right, but eventually you'll need to head toward the <code>e</code> at the bottom. From there, you can spiral around to the goal:</p>
<pre><code>v..v&lt;&lt;&lt;&lt;
&gt;v.vv&lt;&lt;^
.&gt;vv&gt;E^^
..v&gt;&gt;&gt;^^
..&gt;&gt;&gt;&gt;&gt;^
</code></pre>
<p>In the above diagram, the symbols indicate whether the path exits each square moving up (<code>^</code>), down (<code>v</code>), left (<code>&lt;</code>), or right (<code>&gt;</code>). The location that should get the best signal is still <code>E</code>, and <code>.</code> marks unvisited squares.</p>
<p>This path reaches the goal in <strong>31</strong> steps, the fewest possible.</p>
<h2 id="part-1-11"><a class="header" href="#part-1-11">Part 1</a></h2>
<p><strong>What is the fewest steps required to move from your current position to the location that should get the best signal?</strong></p>
<h2 id="part-2-11"><a class="header" href="#part-2-11">Part 2</a></h2>
<p>As you walk up the hill, you suspect that the Elves will want to turn this into a hiking trail. The beginning isn't very scenic, though; perhaps you can find a better starting point.</p>
<p>To maximize exercise while hiking, the trail should start as low as possible: elevation <code>a</code>. The goal is still the square marked <code>E</code>. However, the trail should still be direct, taking the fewest steps to reach its goal. So, you'll need to find the shortest path from <strong>any square at elevation <code>a</code></strong> to the square marked <code>E</code>.</p>
<p>Again consider the example from above:</p>
<pre><code>Sabqponm
abcryxxl
accszExk
acctuvwj
abdefghi
</code></pre>
<p>Now, there are six choices for starting position (five marked <code>a</code>, plus the square marked <code>S</code> that counts as being at elevation <code>a</code>). If you start at the bottom-left square, you can reach the goal most quickly:</p>
<pre><code>...v&lt;&lt;&lt;&lt;
...vv&lt;&lt;^
...v&gt;E^^
.&gt;v&gt;&gt;&gt;^^
&gt;^&gt;&gt;&gt;&gt;&gt;^
</code></pre>
<p>This path reaches the goal in only <strong>29</strong> steps, the fewest possible.</p>
<p><strong>What is the fewest steps required to move starting from any square with elevation a to the location that should get the best signal?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-12-solution-explanation"><a class="header" href="#day-12-solution-explanation">Day 12: Solution Explanation</a></h1>
<h2 id="approach-11"><a class="header" href="#approach-11">Approach</a></h2>
<p>Day 12 involves finding the shortest path through a grid with elevation constraints. The key to solving this problem is to use a breadth-first search (BFS) algorithm, which is optimal for finding the shortest path in an unweighted graph.</p>
<p>The solution breaks down into several key components:</p>
<ol>
<li><strong>Representing the heightmap</strong>: We need to parse the input into a grid of elevation values</li>
<li><strong>Implementing BFS</strong>: We need to find the shortest path from start to end, respecting elevation constraints</li>
<li><strong>Reversing the problem for Part 2</strong>: We can efficiently solve Part 2 by starting from the end point and finding the closest square with elevation 'a'</li>
<li><strong>Visualizing the path</strong>: As a bonus, the solution includes visualization using the bracket-lib library</li>
</ol>
<h2 id="implementation-details-11"><a class="header" href="#implementation-details-11">Implementation Details</a></h2>
<h3 id="grid-representation"><a class="header" href="#grid-representation">Grid Representation</a></h3>
<p>The solution uses a custom <code>Grid</code> structure to represent the heightmap:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ElevationGrid(Grid&lt;u8&gt;);
<span class="boring">}</span></code></pre></pre>
<p>This wraps a generic <code>Grid&lt;u8&gt;</code> from a shared library, with elevation values represented as unsigned bytes. During parsing, letters 'a' to 'z' are converted to values 1 to 26, with 'S' (start) mapped to 0 and 'E' (end) mapped to 27.</p>
<h3 id="parsing-the-input-4"><a class="header" href="#parsing-the-input-4">Parsing the Input</a></h3>
<p>The input is parsed into an <code>ElevationGrid</code>, with special handling for the start ('S') and end ('E') positions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_elevation(data: &amp;str) -&gt; (ElevationGrid, Coord, Coord) {
    let width = data.lines().next().unwrap().len();
    let height = data.lines().count();
    let mut grid = Grid::new(width,height);
    let (mut start, mut finish) = ((0,0).into(),(0,0).into());

    for (y,line) in data.lines().enumerate() {
        for (x, val) in line.bytes().enumerate() {
            match val {
                b'S' =&gt; {
                    start = (x, y).into();
                    *grid.square_mut(start).unwrap() = 0;
                },
                b'E' =&gt; {
                    finish = (x, y).into();
                    *grid.square_mut(finish).unwrap() = b'z'-b'a'+2;
                }
                _ =&gt; *grid.square_mut((x, y).into()).unwrap() = val - b'a' + 1
            }
        }
    }
    (ElevationGrid(grid), start, finish)
}
<span class="boring">}</span></code></pre></pre>
<p>This function returns the grid, start coordinate, and end coordinate.</p>
<h3 id="path-finding-with-bfs"><a class="header" href="#path-finding-with-bfs">Path Finding with BFS</a></h3>
<p>The core of the solution is the <code>shortest_path</code> method on <code>ElevationGrid</code>, which implements BFS to find the shortest path satisfying a given goal condition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shortest_path&lt;F&gt;(&amp;self, start: Coord, goal:F ) -&gt; Vec&lt;Coord&gt; where F: Fn(Coord)-&gt;bool {
    let mut ps = PathSearch::init(self);
    // push start in the queue
    ps.queue.push_back(start);

    // pop from top &amp; while still nodes in the queue
    while let Some(cs) = ps.queue.pop_front() {
        // position matches target
        if goal(cs) {
            // extract parent position from target
            let mut cur = cs;
            while let Some(par) = ps.visited.square(cur).unwrap().1 {
                ps.path.push(par);
                cur = par;
            }
            // remove start position from path
            ps.path.pop();
            break
        }

        // mark square as visited
        ps.visited.square_mut(cs).unwrap().0 = true;

        let &amp;square = self.0.square(cs).unwrap();

        // evaluate neighbour squares and
        // push to the queue if the have elevation delta &lt;= 1
        self.0.neighbouring(cs)
            .for_each(|(ns, &amp;elevation)| {
                if let Some((false, None)) = ps.visited.square(ns) {
                    if elevation &lt;= square + 1 {
                        // capture the square we arrived from
                        ps.visited.square_mut(ns).unwrap().1 = Some(cs);
                        ps.queue.push_back(ns)
                    }
                }
            })
    }
    ps.path
}
<span class="boring">}</span></code></pre></pre>
<p>Key aspects of this implementation:</p>
<ol>
<li>It uses a queue for BFS traversal, starting from the specified position</li>
<li>It checks each position against a goal function passed as a parameter</li>
<li>It respects the elevation constraint (can only move to positions with elevation at most 1 higher)</li>
<li>It reconstructs the path from end to start using parent pointers</li>
</ol>
<h3 id="path-search-data-structure"><a class="header" href="#path-search-data-structure">Path Search Data Structure</a></h3>
<p>The BFS algorithm is supported by a <code>PathSearch</code> struct that manages the search state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PathSearch {
    queue: VecDeque&lt;Coord&gt;,
    visited: Grid&lt;(bool,Option&lt;Coord&gt;)&gt;,
    path: Vec&lt;Coord&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>This structure maintains:</p>
<ul>
<li>A queue of coordinates to explore</li>
<li>A grid tracking visited positions and their parent positions (for path reconstruction)</li>
<li>A vector to store the final path</li>
</ul>
<h3 id="solving-part-1-2"><a class="header" href="#solving-part-1-2">Solving Part 1</a></h3>
<p>For Part 1, we find the shortest path from the start position to the end position:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// find path with closure fn() goal set at reaching the target coordinate
let path = grid.shortest_path(start, |cs| cs.eq(&amp;target));
<span class="boring">}</span></code></pre></pre>
<p>We use a closure that checks if the current position matches the target position.</p>
<h3 id="solving-part-2-2"><a class="header" href="#solving-part-2-2">Solving Part 2</a></h3>
<p>For Part 2, we need to find the shortest path from any position with elevation 'a' to the end position. Instead of running BFS from each possible starting position, we reverse the problem:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// reverse the elevation so E(0) and S(27)
grid.reverse_elevation();

// find path with closure fn() goal set as reaching elevation(26) = a
let path = grid.shortest_path(target, |cs| 26.eq(grid.0.square(cs).unwrap()));
<span class="boring">}</span></code></pre></pre>
<p>This elegant approach:</p>
<ol>
<li>Reverses the elevation values (making 'a' the highest and 'z' the lowest)</li>
<li>Starts BFS from the end position</li>
<li>Looks for the first position with elevation value 26 (which corresponds to 'a' after reversal)</li>
</ol>
<p>The elevation reversal is implemented as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reverse_elevation(&amp;mut self) {
    let &amp;max = self.0.iter().max().unwrap();
    self.0.iter_mut()
        .map(|val|{
            *val = max - *val;
        })
        .all(|_| true);
}
<span class="boring">}</span></code></pre></pre>
<p>This effectively flips the elevation constraint, allowing us to find the shortest path from the end position to any 'a' position.</p>
<h3 id="visualization"><a class="header" href="#visualization">Visualization</a></h3>
<p>The solution includes visualization using the bracket-lib library, which renders the grid and path in a graphical window. This is not essential for solving the problem but provides a nice way to see the results.</p>
<h2 id="algorithmic-analysis-2"><a class="header" href="#algorithmic-analysis-2">Algorithmic Analysis</a></h2>
<h3 id="time-complexity-7"><a class="header" href="#time-complexity-7">Time Complexity</a></h3>
<ul>
<li><strong>BFS</strong>: O(V + E) where V is the number of vertices (grid cells) and E is the number of edges (adjacent cell pairs). In a grid, this simplifies to O(n) where n is the number of cells.</li>
<li><strong>Path Reconstruction</strong>: O(p) where p is the length of the path.</li>
<li><strong>Overall</strong>: O(n) for each part, where n is the number of grid cells.</li>
</ul>
<h3 id="space-complexity-7"><a class="header" href="#space-complexity-7">Space Complexity</a></h3>
<ul>
<li><strong>Grid Storage</strong>: O(n) to store the grid</li>
<li><strong>BFS Data Structures</strong>: O(n) for the queue and visited tracking</li>
<li><strong>Path Storage</strong>: O(p) where p is the path length</li>
<li><strong>Overall</strong>: O(n)</li>
</ul>
<h2 id="alternative-approaches-10"><a class="header" href="#alternative-approaches-10">Alternative Approaches</a></h2>
<h3 id="dijkstras-algorithm-or-a"><a class="header" href="#dijkstras-algorithm-or-a">Dijkstra's Algorithm or A*</a></h3>
<p>While BFS is optimal for unweighted graphs, we could also use Dijkstra's algorithm or A* if we wanted to add more complex cost calculations. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shortest_path_astar(&amp;self, start: Coord, end: Coord) -&gt; Vec&lt;Coord&gt; {
    let mut open_set = BinaryHeap::new();
    let mut came_from = HashMap::new();
    let mut g_score = HashMap::new();
    let mut f_score = HashMap::new();
    
    g_score.insert(start, 0);
    f_score.insert(start, manhattan_distance(start, end));
    open_set.push(Node { pos: start, f_score: *f_score.get(&amp;start).unwrap() });
    
    // A* algorithm implementation...
}

fn manhattan_distance(a: Coord, b: Coord) -&gt; u32 {
    ((a.x as i32 - b.x as i32).abs() + (a.y as i32 - b.y as i32).abs()) as u32
}
<span class="boring">}</span></code></pre></pre>
<p>However, for this problem, BFS is sufficient and more efficient.</p>
<h3 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic Programming</a></h3>
<p>Another approach could be to use dynamic programming to calculate the shortest distance to each cell from the starting point:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shortest_distance_dp(&amp;self, start: Coord) -&gt; Grid&lt;Option&lt;usize&gt;&gt; {
    let mut distances = Grid::new(self.width(), self.height());
    distances.square_mut(start).unwrap() = Some(0);
    
    let mut changed = true;
    while changed {
        changed = false;
        // For each cell, update distances based on neighbors
        // ...
    }
    
    distances
}
<span class="boring">}</span></code></pre></pre>
<p>This would be more complex and less efficient than BFS for this problem.</p>
<h2 id="conclusion-9"><a class="header" href="#conclusion-9">Conclusion</a></h2>
<p>This solution demonstrates an efficient approach to pathfinding in a grid with elevation constraints. By using BFS and cleverly reversing the problem for Part 2, we achieve a clean and performant solution. The visualization component adds an interesting way to see the results of the algorithm in action.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-12-code"><a class="header" href="#day-12-code">Day 12: Code</a></h1>
<p>Below is the complete code for Day 12's solution, which implements a path-finding algorithm to navigate a heightmap.</p>
<h2 id="full-solution-11"><a class="header" href="#full-solution-11">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">use std::collections::VecDeque;
use std::fmt::{Debug, Formatter};
use bracket_lib::prelude::*;
use advent2022::{
    Grid, Coord,
    app::{App, AppLevel, State}
};

fn main() -&gt; BResult&lt;()&gt; {

    let input = std::fs::read_to_string("src/bin/day12_input.txt").expect("ops!");

    // parse elevations onto a grid
    let (mut grid,start, target) = parse_elevation(input.as_str());

    // find path with closure fn() goal set at reaching the target coordinate
    let path = grid.shortest_path(start,|cs| cs.eq(&amp;target));

    // visualise path produced
    grid.visualise_path(path);

    // reverse the elevation so E(0) and S(27)
    grid.reverse_elevation();

    // find path with closure fn() goal set as reaching elevation(26) = a
    let path = grid.shortest_path(target, |cs| 26.eq(grid.0.square(cs).unwrap()));

    // visualise path produced
    grid.visualise_path(path);
    grid.reverse_elevation();

    let mut ctx = BTermBuilder::simple(160,120)?
        .with_simple_console(grid.width(),grid.height(), "terminal8x8.png")
        .with_simple_console_no_bg(grid.width(),grid.height(), "terminal8x8.png")
        .with_simple_console_no_bg(grid.width(),grid.height(), "terminal8x8.png")
        .with_fps_cap(640f32)
        .with_title("Day12: Path Search")
        .build()?;

    let ps = PathSearch::init(&amp;grid);
    let mut app = App::init(GStore { grid, target, start, ps } , Level::MENU);

    app.register_level(Level::MENU, Menu);
    app.register_level(Level::LEVEL1, ExerciseOne);
    app.register_level(Level::LEVEL2, ExerciseTwo);

    ctx.set_active_console(1);
    app.store().grid.draw(&amp;mut ctx);
    main_loop(ctx, app)
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash )]
pub enum Level { MENU, LEVEL1, LEVEL2 }

struct GStore {
    grid: ElevationGrid,
    target: Coord,
    start: Coord,
    ps: PathSearch,
}

struct Menu;
impl AppLevel for Menu {
    type GStore = GStore;
    type GLevel = Level;
    fn init(&amp;mut self, _: &amp;mut BTerm, _: &amp;mut Self::GStore) -&gt; (Self::GLevel, State) {
        (Level::MENU, State::RUN)
    }
    fn run(&amp;mut self, ctx: &amp;mut BTerm, _: &amp;mut Self::GStore) -&gt; (Self::GLevel, State) {
        ctx.set_active_console(3);
        match ctx.key {
            Some(VirtualKeyCode::Key1) =&gt; { ctx.cls(); (Level::LEVEL1, State::INIT) },
            Some(VirtualKeyCode::Key2) =&gt; { ctx.cls(); (Level::LEVEL2, State::INIT) },
            Some(VirtualKeyCode::Q) =&gt; (Level::MENU, State::FINISH),
            _ =&gt; {
                ctx.print_centered( 42, "Press '1' : Lowest to highest elevation");
                ctx.print_centered( 44, "Press '2' : Highest to lowest elevation ");
                ctx.print_centered( 46, "Press 'Q' to exit");
                (Level::MENU, State::RUN)
            }
        }
    }
    fn term(&amp;mut self, ctx: &amp;mut BTerm, _: &amp;mut Self::GStore) -&gt; (Self::GLevel, State) {
        ctx.quit();
        (Level::MENU, State::FINISH)
    }
}

struct ExerciseOne;
impl AppLevel for ExerciseOne {
    type GStore = GStore;
    type GLevel = Level;
    fn init(&amp;mut self, _: &amp;mut BTerm, store: &amp;mut Self::GStore) -&gt; (Self::GLevel, State) {
        store.ps.reset();
        store.ps.queue.push_back(store.start);
        (Level::LEVEL1, State::RUN)
    }
    fn run(&amp;mut self, ctx: &amp;mut BTerm, store: &amp;mut Self::GStore) -&gt; (Self::GLevel, State) {
        ctx.set_active_console(2);
        match store.ps.tick(&amp;store.grid, |cs| cs.eq(&amp;store.target)) {
            None =&gt; {
                ctx.cls();
                store.ps.draw(ctx);
                ctx.set(store.target.x,store.target.y, BLUE, BLACK, to_cp437('\u{2588}'));
                (Level::LEVEL1, State::RUN)
            }
            Some(target) =&gt; {
                store.ps.queue.clear();
                store.ps.queue.push_back(target);
                ctx.cls();
                store.ps.draw(ctx);
                (Level::LEVEL1, State::FINISH)
            }
        }
    }
    fn term(&amp;mut self, ctx: &amp;mut BTerm, _: &amp;mut Self::GStore) -&gt; (Self::GLevel, State) {
        ctx.set_active_console(3);
        ctx.print_centered(10, "Path Found !!");
        (Level::MENU, State::INIT)
    }
}

struct ExerciseTwo;
impl AppLevel for ExerciseTwo {
    type GStore = GStore;
    type GLevel = Level;
    fn init(&amp;mut self, _: &amp;mut BTerm, store: &amp;mut Self::GStore) -&gt; (Self::GLevel, State) {
        store.ps.reset();
        store.ps.queue.push_back(store.target);
        store.grid.reverse_elevation();
        (Level::LEVEL2, State::RUN)
    }
    fn run(&amp;mut self, ctx: &amp;mut BTerm, store: &amp;mut Self::GStore) -&gt; (Self::GLevel, State) {
        ctx.set_active_console(2);
        match store.ps.tick(&amp;store.grid, |cs| 26.eq(store.grid.0.square(cs).unwrap())) {
            None =&gt; {
                ctx.cls();
                store.ps.draw(ctx);
                (Level::LEVEL2, State::RUN)
            }
            Some(target) =&gt; {
                store.ps.queue.clear();
                store.ps.queue.push_back(target);
                ctx.cls();
                store.ps.draw(ctx);
                store.grid.reverse_elevation();
                (Level::LEVEL2, State::FINISH)
            }
        }
    }
    fn term(&amp;mut self, ctx: &amp;mut BTerm, _: &amp;mut Self::GStore) -&gt; (Self::GLevel, State) {
        ctx.set_active_console(3);
        ctx.print_centered(10, "Path Found !!");
        (Level::MENU, State::INIT)
    }
}

fn parse_elevation(data: &amp;str) -&gt; (ElevationGrid, Coord, Coord) {
    let width = data.lines().next().unwrap().len();
    let height = data.lines().count();
    let mut grid = Grid::new(width,height);
    let (mut start, mut finish) = ((0,0).into(),(0,0).into());

    for (y,line) in data.lines().enumerate() {
        for (x, val) in line.bytes().enumerate() {
            match val {
                b'S' =&gt; {
                    start = (x, y).into();
                    *grid.square_mut(start).unwrap() = 0;
                },
                b'E' =&gt; {
                    finish = (x, y).into();
                    *grid.square_mut(finish).unwrap() = b'z'-b'a'+2;
                }
                _ =&gt; *grid.square_mut((x, y).into()).unwrap() = val - b'a' + 1
            }
        }
    }
    (ElevationGrid(grid), start, finish)
}

struct PathSearch {
    queue: VecDeque&lt;Coord&gt;,
    visited: Grid&lt;(bool,Option&lt;Coord&gt;)&gt;,
    path: Vec&lt;Coord&gt;
}
impl PathSearch {
    fn init(grid: &amp;ElevationGrid) -&gt; PathSearch {
        PathSearch {
            queue: VecDeque::&lt;Coord&gt;::new(),
            visited: Grid::new(grid.width(), grid.height()),
            path: Vec::&lt;_&gt;::new()
        }
    }
    fn reset(&amp;mut self) {
        self.queue.clear();
        self.visited.grid.iter_mut().for_each(|val| *val = (false, None) );
        self.path.clear();
    }
    fn tick&lt;F&gt;(&amp;mut self, grid: &amp;ElevationGrid, goal: F) -&gt; Option&lt;Coord&gt; where F: Fn(Coord)-&gt;bool {
        let Some(cs) = self.queue.pop_front() else { return None };

        // position matches target
        if goal(cs) {
            return Some(cs);
        }
        // mark square as visited
        self.visited.square_mut(cs).unwrap().0 = true;

        let &amp;square = grid.0.square(cs).unwrap();

        // evaluate neighbour squares and
        // push to the queue if the have elevation delta &lt;= 1
        grid.0.neighbouring(cs)
            .for_each(|(ns, &amp;elevation)| {
                if let Some((false, None)) = self.visited.square(ns) {
                    if elevation &lt;= square + 1 {
                        // capture the square we arrived from
                        self.visited.square_mut(ns).unwrap().1 = Some(cs);
                        self.queue.push_back(ns)
                    }
                }
            });
        None
    }
    fn extract_path(&amp;self, start:Coord) -&gt; PathIter {
        PathIter { ps: self, cur: start }
    }
    fn draw(&amp;self,ctx: &amp;mut BTerm) {
        self.queue.iter()
            .for_each(|&amp;cs| {
                ctx.set(cs.x,cs.y,RED,BLACK,to_cp437('\u{2588}'));
                self.extract_path(cs)
                    .for_each(|Coord{x,y}|
                        ctx.set(x,y,ORANGE, BLACK,to_cp437('\u{2588}'))
                    )
            })
    }
}
struct PathIter&lt;'a&gt; {
    ps: &amp;'a PathSearch,
    cur: Coord
}
impl Iterator for PathIter&lt;'_&gt; {
    type Item = Coord;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.ps.visited.square(self.cur).unwrap().1 {
            Some(par) =&gt; {
                self.cur = par;
                Some(par)
            }
            _ =&gt; None
        }
    }
}

struct ElevationGrid(Grid&lt;u8&gt;);

impl ElevationGrid {
    fn width(&amp;self) -&gt; usize { self.0.width }
    fn height(&amp;self) -&gt; usize { self.0.height }
    fn reverse_elevation(&amp;mut self) {
        let &amp;max = self.0.iter().max().unwrap();
        self.0.iter_mut()
            .map(|val|{
                *val = max - *val;
            })
            .all(|_| true);
    }
    fn visualise_path(&amp;self, path:Vec&lt;Coord&gt;) {
        let mut gpath= ElevationGrid(Grid::new(self.width(), self.height()) );
        path.iter().for_each(|&amp;a| *gpath.0.square_mut(a).unwrap() = *self.0.square(a).unwrap() );
        println!("Path length: {}\n{:?}",path.len(),gpath);
    }
    fn shortest_path&lt;F&gt;(&amp;self, start: Coord, goal:F ) -&gt; Vec&lt;Coord&gt; where F: Fn(Coord)-&gt;bool {

        let mut ps = PathSearch::init(self);
        // push start in the queue
        ps.queue.push_back(start);

        // pop from top &amp; while still nodes in the queue
        while let Some(cs) = ps.queue.pop_front() {

            // position matches target
            if goal(cs) {
                // extract parent position from target
                let mut cur = cs;
                while let Some(par) = ps.visited.square(cur).unwrap().1 {
                    ps.path.push(par);
                    cur = par;
                }
                // remove start position from path
                ps.path.pop();
                break
            }

            // mark square as visited
            ps.visited.square_mut(cs).unwrap().0 = true;

            let &amp;square = self.0.square(cs).unwrap();

            // evaluate neighbour squares and
            // push to the queue if the have elevation delta &lt;= 1
            self.0.neighbouring(cs)
                .for_each(|(ns, &amp;elevation)| {
                    if let Some((false, None)) = ps.visited.square(ns) {
                        if elevation &lt;= square + 1 {
                            // capture the square we arrived from
                            ps.visited.square_mut(ns).unwrap().1 = Some(cs);
                            ps.queue.push_back(ns)
                        }
                    }
                })
        }
        ps.path
    }
    fn draw(&amp;self, ctx: &amp;mut BTerm) {
        let rgb: Vec&lt;_&gt; = RgbLerp::new(CADETBLUE.into(), WHITESMOKE.into(), 27).collect();
        (0..self.height()).for_each(|y|{
            (0..self.width()).for_each(|x|
                ctx.set_bg(x, y, self.0.square((x, y).into()).map(|&amp;cell| rgb[cell as usize]).unwrap_or(BLACK.into()))
            );
        });
    }
}

impl Debug for ElevationGrid {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        (0..self.height()).for_each(|y|{
            (0..self.width()).for_each(|x|
                write!(f, "{:^2}",
                       self.0.square((x, y).into())
                           .map(|&amp;cell| match cell { 0 =&gt; '.', _=&gt; 'x'})
                           .expect("TODO: panic message")
                ).expect("failed in x")
            );
            writeln!(f).expect("failed in y");
        });
        Ok(())
    }
}</code></pre>
<h2 id="code-walkthrough-11"><a class="header" href="#code-walkthrough-11">Code Walkthrough</a></h2>
<h3 id="core-data-structures-2"><a class="header" href="#core-data-structures-2">Core Data Structures</a></h3>
<pre><code class="language-rust no_run noplayground">struct ElevationGrid(Grid&lt;u8&gt;);</code></pre>
<p>The solution uses an <code>ElevationGrid</code> wrapper around a generic <code>Grid&lt;u8&gt;</code> to represent the heightmap. Elevation values are stored as bytes, with special values for the start and end positions.</p>
<pre><code class="language-rust no_run noplayground">struct PathSearch {
    queue: VecDeque&lt;Coord&gt;,
    visited: Grid&lt;(bool,Option&lt;Coord&gt;)&gt;,
    path: Vec&lt;Coord&gt;
}</code></pre>
<p>The <code>PathSearch</code> struct manages the breadth-first search algorithm, tracking:</p>
<ul>
<li>A queue of coordinates to explore</li>
<li>A grid marking visited positions and their parent positions</li>
<li>A vector to store the final path</li>
</ul>
<h3 id="input-parsing"><a class="header" href="#input-parsing">Input Parsing</a></h3>
<pre><code class="language-rust no_run noplayground">fn parse_elevation(data: &amp;str) -&gt; (ElevationGrid, Coord, Coord) {
    let width = data.lines().next().unwrap().len();
    let height = data.lines().count();
    let mut grid = Grid::new(width,height);
    let (mut start, mut finish) = ((0,0).into(),(0,0).into());

    for (y,line) in data.lines().enumerate() {
        for (x, val) in line.bytes().enumerate() {
            match val {
                b'S' =&gt; {
                    start = (x, y).into();
                    *grid.square_mut(start).unwrap() = 0;
                },
                b'E' =&gt; {
                    finish = (x, y).into();
                    *grid.square_mut(finish).unwrap() = b'z'-b'a'+2;
                }
                _ =&gt; *grid.square_mut((x, y).into()).unwrap() = val - b'a' + 1
            }
        }
    }
    (ElevationGrid(grid), start, finish)
}</code></pre>
<p>The parsing function:</p>
<ol>
<li>Creates a grid of the appropriate size</li>
<li>Processes each character in the input:
<ul>
<li>'S' (start) is mapped to elevation 0 and its position is stored</li>
<li>'E' (end) is mapped to elevation 27 and its position is stored</li>
<li>Letters 'a' to 'z' are mapped to values 1 to 26</li>
</ul>
</li>
<li>Returns the grid and the start and end positions</li>
</ol>
<h3 id="breadth-first-search-implementation"><a class="header" href="#breadth-first-search-implementation">Breadth-First Search Implementation</a></h3>
<pre><code class="language-rust no_run noplayground">    fn shortest_path&lt;F&gt;(&amp;self, start: Coord, goal:F ) -&gt; Vec&lt;Coord&gt; where F: Fn(Coord)-&gt;bool {

        let mut ps = PathSearch::init(self);
        // push start in the queue
        ps.queue.push_back(start);

        // pop from top &amp; while still nodes in the queue
        while let Some(cs) = ps.queue.pop_front() {

            // position matches target
            if goal(cs) {
                // extract parent position from target
                let mut cur = cs;
                while let Some(par) = ps.visited.square(cur).unwrap().1 {
                    ps.path.push(par);
                    cur = par;
                }
                // remove start position from path
                ps.path.pop();
                break
            }

            // mark square as visited
            ps.visited.square_mut(cs).unwrap().0 = true;

            let &amp;square = self.0.square(cs).unwrap();

            // evaluate neighbour squares and
            // push to the queue if the have elevation delta &lt;= 1
            self.0.neighbouring(cs)
                .for_each(|(ns, &amp;elevation)| {
                    if let Some((false, None)) = ps.visited.square(ns) {
                        if elevation &lt;= square + 1 {
                            // capture the square we arrived from
                            ps.visited.square_mut(ns).unwrap().1 = Some(cs);
                            ps.queue.push_back(ns)
                        }
                    }
                })
        }
        ps.path
    }</code></pre>
<p>The BFS algorithm:</p>
<ol>
<li>Initializes a <code>PathSearch</code> instance with the grid dimensions</li>
<li>Adds the start position to the queue</li>
<li>Processes positions from the queue until finding one that satisfies the goal condition</li>
<li>For each position, visits neighboring positions that satisfy the elevation constraint</li>
<li>When the goal is reached, reconstructs the path by following parent pointers</li>
</ol>
<h3 id="elevation-reversal-for-part-2"><a class="header" href="#elevation-reversal-for-part-2">Elevation Reversal for Part 2</a></h3>
<pre><code class="language-rust no_run noplayground">    fn reverse_elevation(&amp;mut self) {
        let &amp;max = self.0.iter().max().unwrap();
        self.0.iter_mut()
            .map(|val|{
                *val = max - *val;
            })
            .all(|_| true);
    }</code></pre>
<p>This method reverses the elevation values, which allows solving Part 2 by starting from the end position and searching for the closest square with elevation 'a'.</p>
<h3 id="path-visualization"><a class="header" href="#path-visualization">Path Visualization</a></h3>
<pre><code class="language-rust no_run noplayground">    fn visualise_path(&amp;self, path:Vec&lt;Coord&gt;) {
        let mut gpath= ElevationGrid(Grid::new(self.width(), self.height()) );
        path.iter().for_each(|&amp;a| *gpath.0.square_mut(a).unwrap() = *self.0.square(a).unwrap() );
        println!("Path length: {}\n{:?}",path.len(),gpath);
    }</code></pre>
<p>This method creates a new grid highlighting only the cells in the path, then prints it to the console.</p>
<h3 id="interactive-visualization"><a class="header" href="#interactive-visualization">Interactive Visualization</a></h3>
<p>The solution includes a sophisticated interactive visualization using the bracket-lib library. This allows exploring the map and watching the path-finding algorithm in action.</p>
<pre><code class="language-rust no_run noplayground">    let mut ctx = BTermBuilder::simple(160,120)?
        .with_simple_console(grid.width(),grid.height(), "terminal8x8.png")
        .with_simple_console_no_bg(grid.width(),grid.height(), "terminal8x8.png")
        .with_simple_console_no_bg(grid.width(),grid.height(), "terminal8x8.png")
        .with_fps_cap(640f32)
        .with_title("Day12: Path Search")
        .build()?;

    let ps = PathSearch::init(&amp;grid);
    let mut app = App::init(GStore { grid, target, start, ps } , Level::MENU);

    app.register_level(Level::MENU, Menu);
    app.register_level(Level::LEVEL1, ExerciseOne);
    app.register_level(Level::LEVEL2, ExerciseTwo);

    ctx.set_active_console(1);
    app.store().grid.draw(&amp;mut ctx);
    main_loop(ctx, app)</code></pre>
<p>This setup creates a visualization window with multiple layers and implements an interactive application with different levels.</p>
<h2 id="main-solution-flow"><a class="header" href="#main-solution-flow">Main Solution Flow</a></h2>
<pre><code class="language-rust no_run noplayground">    let input = std::fs::read_to_string("src/bin/day12_input.txt").expect("ops!");

    // parse elevations onto a grid
    let (mut grid,start, target) = parse_elevation(input.as_str());

    // find path with closure fn() goal set at reaching the target coordinate
    let path = grid.shortest_path(start,|cs| cs.eq(&amp;target));

    // visualise path produced
    grid.visualise_path(path);

    // reverse the elevation so E(0) and S(27)
    grid.reverse_elevation();

    // find path with closure fn() goal set as reaching elevation(26) = a
    let path = grid.shortest_path(target, |cs| 26.eq(grid.0.square(cs).unwrap()));

    // visualise path produced
    grid.visualise_path(path);</code></pre>
<p>The main solution:</p>
<ol>
<li>Parses the input into a grid and identifies start and end positions</li>
<li>For Part 1:
<ul>
<li>Finds the shortest path from start to end</li>
<li>Visualizes the path</li>
</ul>
</li>
<li>For Part 2:
<ul>
<li>Reverses elevation values</li>
<li>Finds the shortest path from end to any position with elevation 'a'</li>
<li>Visualizes the path</li>
</ul>
</li>
</ol>
<h2 id="implementation-notes-10"><a class="header" href="#implementation-notes-10">Implementation Notes</a></h2>
<ul>
<li><strong>Goal Function</strong>: The solution uses a closure as a goal function, making it flexible for both parts</li>
<li><strong>Path Reconstruction</strong>: The algorithm reconstructs the path by storing parent pointers in the <code>visited</code> grid</li>
<li><strong>Interactive Visualization</strong>: The solution includes a sophisticated visualization using bracket-lib</li>
<li><strong>Functional Programming Style</strong>: The code makes extensive use of iterators and functional programming patterns</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-13-distress-signal"><a class="header" href="#day-13-distress-signal">Day 13: Distress Signal</a></h1>
<p>Day 13 involves parsing and comparing nested lists according to specific rules.</p>
<h2 id="problem-overview-12"><a class="header" href="#problem-overview-12">Problem Overview</a></h2>
<p>You're trying to decode a distress signal consisting of pairs of packets, where each packet is a nested list structure. Your task is to:</p>
<ol>
<li>Determine which pairs of packets are in the right order according to specific comparison rules</li>
<li>Sort all packets, including two divider packets, and find the decoder key</li>
</ol>
<p>This problem tests your ability to parse and compare hierarchical data structures with complex comparison rules.</p>
<h2 id="navigation-12"><a class="header" href="#navigation-12">Navigation</a></h2>
<ul>
<li><a href="day13/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day13/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day13/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-13-problem-description"><a class="header" href="#day-13-problem-description">Day 13: Problem Description</a></h1>
<h2 id="distress-signal"><a class="header" href="#distress-signal">Distress Signal</a></h2>
<p>You climb the hill and again try contacting the Elves. However, you instead receive a signal you weren't expecting: a <strong>distress signal</strong>.</p>
<p>Your handheld device must still not be working properly; the packets from the distress signal got decoded <strong>out of order</strong>. You'll need to re-order the list of received packets (your puzzle input) to decode the message.</p>
<p>Your list consists of pairs of packets; pairs are separated by a blank line. You need to identify <strong>how many pairs of packets are in the right order</strong>.</p>
<p>For example:</p>
<pre><code>[1,1,3,1,1]
[1,1,5,1,1]

[[1],[2,3,4]]
[[1],4]

[9]
[[8,7,6]]

[[4,4],4,4]
[[4,4],4,4,4]

[7,7,7,7]
[7,7,7]

[]
[3]

[[[]]]
[[]]

[1,[2,[3,[4,[5,6,7]]]],8,9]
[1,[2,[3,[4,[5,6,0]]]],8,9]
</code></pre>
<p>Packet data consists of lists and integers. Each list starts with <code>[</code>, ends with <code>]</code>, and contains zero or more comma-separated values (either integers or other lists). Each packet is always a list and appears on its own line.</p>
<p>When comparing two values, the first value is called <strong>left</strong> and the second value is called <strong>right</strong>. Then:</p>
<ul>
<li>If <strong>both values are integers</strong>, the <strong>lower integer</strong> should come first. If the left integer is lower than the right integer, the inputs are in the right order. If the left integer is higher than the right integer, the inputs are not in the right order. Otherwise, the inputs are the same integer; continue checking the next part of the input.</li>
<li>If <strong>both values are lists</strong>, compare the first value of each list, then the second value, and so on. If the left list runs out of items first, the inputs are in the right order. If the right list runs out of items first, the inputs are not in the right order. If the lists are the same length and no comparison makes a decision about the order, continue checking the next part of the input.</li>
<li>If <strong>exactly one value is an integer</strong>, convert the integer to a list which contains that integer as its only value, then retry the comparison. For example, if comparing <code>[0,0,0]</code> and <code>2</code>, convert the right value to <code>[2]</code> (a list containing <code>2</code>); the result is then found by instead comparing <code>[0,0,0]</code> and <code>[2]</code>.</li>
</ul>
<p>Using these rules, you can determine which of the pairs in the example are in the right order:</p>
<pre><code>== Pair 1 ==
- Compare [1,1,3,1,1] vs [1,1,5,1,1]
  - Compare 1 vs 1
  - Compare 1 vs 1
  - Compare 3 vs 5
    - Left side is smaller, so inputs are in the right order

== Pair 2 ==
- Compare [[1],[2,3,4]] vs [[1],4]
  - Compare [1] vs [1]
    - Compare 1 vs 1
  - Compare [2,3,4] vs 4
    - Mixed types; convert right to [4] and retry comparison
    - Compare [2,3,4] vs [4]
      - Compare 2 vs 4
        - Left side is smaller, so inputs are in the right order

== Pair 3 ==
- Compare [9] vs [[8,7,6]]
  - Compare 9 vs [8,7,6]
    - Mixed types; convert left to [9] and retry comparison
    - Compare [9] vs [8,7,6]
      - Compare 9 vs 8
        - Right side is smaller, so inputs are not in the right order

== Pair 4 ==
- Compare [[4,4],4,4] vs [[4,4],4,4,4]
  - Compare [4,4] vs [4,4]
    - Compare 4 vs 4
    - Compare 4 vs 4
  - Compare 4 vs 4
  - Compare 4 vs 4
  - Left side ran out of items, so inputs are in the right order

== Pair 5 ==
- Compare [7,7,7,7] vs [7,7,7]
  - Compare 7 vs 7
  - Compare 7 vs 7
  - Compare 7 vs 7
  - Right side ran out of items, so inputs are not in the right order

== Pair 6 ==
- Compare [] vs [3]
  - Left side ran out of items, so inputs are in the right order

== Pair 7 ==
- Compare [[[]]] vs [[]]
  - Compare [[]] vs []
    - Right side ran out of items, so inputs are not in the right order

== Pair 8 ==
- Compare [1,[2,[3,[4,[5,6,7]]]],8,9] vs [1,[2,[3,[4,[5,6,0]]]],8,9]
  - Compare 1 vs 1
  - Compare [2,[3,[4,[5,6,7]]]] vs [2,[3,[4,[5,6,0]]]]
    - Compare 2 vs 2
    - Compare [3,[4,[5,6,7]]] vs [3,[4,[5,6,0]]]
      - Compare 3 vs 3
      - Compare [4,[5,6,7]] vs [4,[5,6,0]]
        - Compare 4 vs 4
        - Compare [5,6,7] vs [5,6,0]
          - Compare 5 vs 5
          - Compare 6 vs 6
          - Compare 7 vs 0
            - Right side is smaller, so inputs are not in the right order
</code></pre>
<p>In this example, the right order pairs are 1, 2, 4, and 6; the sum of their indices is <strong>13</strong>.</p>
<h2 id="part-1-12"><a class="header" href="#part-1-12">Part 1</a></h2>
<p>Determine which pairs of packets are in the right order. <strong>What is the sum of the indices of those pairs?</strong></p>
<h2 id="part-2-12"><a class="header" href="#part-2-12">Part 2</a></h2>
<p>Now, you just need to put <strong>all</strong> of the packets in the right order. Disregard the blank lines in your list of received packets.</p>
<p>The distress signal protocol also requires that you include two <strong>divider packets</strong>:</p>
<pre><code>[[2]]
[[6]]
</code></pre>
<p>Using the same rules as before, organize all packets - the ones in your list of received packets as well as the two divider packets - into the correct order.</p>
<p>For the example above, the result of putting the packets in the correct order is:</p>
<pre><code>[]
[[]]
[[[]]]
[1,1,3,1,1]
[1,1,5,1,1]
[[1],[2,3,4]]
[1,[2,[3,[4,[5,6,0]]]],8,9]
[1,[2,[3,[4,[5,6,7]]]],8,9]
[[1],4]
[[2]]
[3]
[[4,4],4,4]
[[4,4],4,4,4]
[[6]]
[7,7,7]
[7,7,7,7]
[[8,7,6]]
[9]
</code></pre>
<p>Afterward, locate the divider packets. To find the <strong>decoder key</strong> for this distress signal, you need to determine the indices of the two divider packets and multiply them together. (The first packet is at index 1, the second packet is at index 2, and so on.) In this example, the divider packets are <strong>10th</strong> and <strong>14th</strong>, and so the decoder key is <strong>140</strong>.</p>
<p>Organize all of the packets into the correct order. <strong>What is the decoder key for the distress signal?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-13-solution-explanation"><a class="header" href="#day-13-solution-explanation">Day 13: Solution Explanation</a></h1>
<h2 id="approach-12"><a class="header" href="#approach-12">Approach</a></h2>
<p>Day 13 involves parsing and comparing nested lists according to specific rules. The solution breaks down into three main components:</p>
<ol>
<li><strong>Parsing the nested list structure</strong>: We need to parse strings like <code>[1,[2,3],4]</code> into a structured representation</li>
<li><strong>Implementing the comparison logic</strong>: We need to define how to compare two list structures following the given rules</li>
<li><strong>Processing the input data</strong>: We need to handle the pairs of packets for Part 1 and sort all packets for Part 2</li>
</ol>
<p>The solution uses a recursive approach for parsing and a structured type system with trait implementations for comparison.</p>
<h2 id="implementation-details-12"><a class="header" href="#implementation-details-12">Implementation Details</a></h2>
<h3 id="data-structure"><a class="header" href="#data-structure">Data Structure</a></h3>
<p>First, we define a data structure to represent the packet data, which can be either a number or a list of items:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ListItem {
    N(u8),       // A number
    L(Vec&lt;ListItem&gt;)  // A list
}
<span class="boring">}</span></code></pre></pre>
<p>This recursive enum allows representing any nested list structure. We use <code>N</code> for numbers and <code>L</code> for lists.</p>
<h3 id="parsing-1"><a class="header" href="#parsing-1">Parsing</a></h3>
<p>The solution uses a custom parser implemented with the <code>FromStr</code> trait to convert string input into <code>ListItem</code> structures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FromStr for ListItem {
    type Err = ();

    fn from_str(inp: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        struct Scanner&lt;I: Iterator&lt;Item=char&gt;&gt; {
            i: Peekable&lt;I&gt;,
        }
        impl&lt;I: Iterator&lt;Item=char&gt;&gt; Scanner&lt;I&gt; {
            fn new(s: I) -&gt; Self {
                Scanner { i: s.peekable() }
            }
            fn parse_list(&amp;mut self) -&gt; ListItem {
                let mut s = String::new();
                let mut v = L(vec![]);
                loop {
                    match &amp;self.i.peek() {
                        Some('[') =&gt; {
                            self.i.next();
                            v.insert(self.parse_list());
                        },
                        Some(&amp;c@ '0'..='9') =&gt; s.push(c),
                        &amp;c@
                        (Some(',') | Some(']')) if !s.is_empty() =&gt; {
                            v.insert(N(u8::from_str(s.as_str()).expect(""))); 
                            s.clear();
                            if ']'.eq(c.unwrap()) {
                                break v
                            }
                        },
                        Some(',') =&gt; {},
                        Some(']') =&gt; break v,
                        None =&gt; break v,
                        _ =&gt; unreachable!()
                    }
                    self.i.next();
                }
            }
        }
        let mut i = inp.chars().peekable();
        i.next();
        Ok(Scanner::new(i).parse_list())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This parsing logic works by:</p>
<ol>
<li>Creating a <code>Scanner</code> that processes characters from a peekable iterator</li>
<li>Implementing a recursive <code>parse_list</code> method that handles nested lists</li>
<li>Processing each character based on whether it's an opening bracket, digit, comma, or closing bracket</li>
<li>Building up the nested <code>ListItem</code> structure as it parses</li>
</ol>
<p>The parser handles the specific format of the packets as described in the problem.</p>
<h3 id="comparison-logic"><a class="header" href="#comparison-logic">Comparison Logic</a></h3>
<p>The core of the solution is implementing the comparison logic between <code>ListItem</code> values. This is done by implementing the <code>Ord</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ord for ListItem {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        match (self,other) {
            (L(l), L(r)) =&gt; {
                let mut liter = l.iter();
                let mut riter = r.iter();

                loop {
                    match (liter.next(),riter.next()) {
                        (Some(l), Some(r)) =&gt;
                            match l.cmp(r) {
                                Ordering::Equal =&gt; {},
                                ord@
                                (Ordering::Less | Ordering::Greater) =&gt; break ord,
                            },
                        (Some(_), None) =&gt; break Ordering::Greater,
                        (None, Some(_)) =&gt; break Ordering::Less,
                        (None,None) =&gt; break Ordering::Equal,
                    };
                }
            }
            (L(_), N(r)) =&gt; {
                let right = L(vec![N(*r)]);
                self.cmp(&amp;right)
            }
            (N(l), L(_)) =&gt; {
                let left = L(vec![N(*l)]);
                left.cmp(other)
            }
            (N(l), N(r)) =&gt; l.cmp(r),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This implementation follows the rules specified in the problem:</p>
<ol>
<li><strong>For two lists</strong>: Compare items one by one until a difference is found or one list runs out of items</li>
<li><strong>For two integers</strong>: Compare them directly</li>
<li><strong>For a list and an integer</strong>: Convert the integer to a single-item list and compare</li>
</ol>
<p>The <code>PartialOrd</code> trait is also implemented to support comparison operators:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PartialOrd for ListItem {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And for completeness, the <code>PartialEq</code> and <code>Eq</code> traits are implemented using the comparison logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PartialEq&lt;Self&gt; for ListItem {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.partial_cmp(other) == Some(Ordering::Equal)
    }
}

impl Eq for ListItem {}
<span class="boring">}</span></code></pre></pre>
<h3 id="processing-pairs-part-1"><a class="header" href="#processing-pairs-part-1">Processing Pairs (Part 1)</a></h3>
<p>For Part 1, we need to find the pairs of packets that are in the right order (left &lt; right) and sum their indices:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn packets_in_right_order(input: &amp;str) -&gt; usize {
    input.split("\n\n")
        .map(|x| x.lines().collect::&lt;Vec&lt;_&gt;&gt;() )
        .map(|d|
            (ListItem::from_str(d[0]), ListItem::from_str(d[1]))
        )
        .enumerate()
        .filter_map(|(i,(l,r))|
            if l.lt(&amp;r) { Some(i+1) } else { None }
        )
        .sum()
}
<span class="boring">}</span></code></pre></pre>
<p>This function:</p>
<ol>
<li>Splits the input by double newlines to get pairs of packets</li>
<li>Parses each packet into a <code>ListItem</code></li>
<li>Compares each pair using the <code>lt</code> method (less than)</li>
<li>Keeps track of indices (1-based) for pairs in the right order</li>
<li>Sums the indices</li>
</ol>
<h3 id="sorting-packets-part-2"><a class="header" href="#sorting-packets-part-2">Sorting Packets (Part 2)</a></h3>
<p>For Part 2, we need to sort all packets, including two divider packets, and find the product of the indices of the divider packets:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_decoder_key(input: &amp;str) -&gt; usize {
    let dividers = vec![
        L(vec![L(vec![N(2)])]),
        L(vec![L(vec![N(6)])])
    ];

    let mut order = input.split("\n\n")
        .flat_map(|x| x.lines() )
        .filter_map(|d|
            ListItem::from_str(d).ok()
        )
        .chain(vec![ L(vec![L(vec![N(2)])]), L(vec![L(vec![N(6)])]) ] )
        .fold(vec![], |mut out, item|{
            out.push(item);
            out
        });

    order.sort();
    order.iter().for_each(|d| println!("{:?}",d));

    dividers.iter()
        .map(|d| order.binary_search(d).unwrap() + 1 )
        .product()
}
<span class="boring">}</span></code></pre></pre>
<p>This function:</p>
<ol>
<li>Creates the two divider packets (<code>[[2]]</code> and <code>[[6]]</code>)</li>
<li>Parses all packets from the input, ignoring blank lines</li>
<li>Adds the divider packets to the list</li>
<li>Sorts all packets using the implemented comparison logic</li>
<li>Finds the indices of the divider packets (1-based)</li>
<li>Multiplies the indices to get the decoder key</li>
</ol>
<h2 id="algorithmic-analysis-3"><a class="header" href="#algorithmic-analysis-3">Algorithmic Analysis</a></h2>
<h3 id="time-complexity-8"><a class="header" href="#time-complexity-8">Time Complexity</a></h3>
<ul>
<li><strong>Parsing</strong>: O(n) for each packet, where n is the length of the packet string</li>
<li><strong>Comparison</strong>: O(n) for two packets of total size n</li>
<li><strong>Part 1</strong>: O(p Ã— n) where p is the number of pairs and n is the average packet size</li>
<li><strong>Part 2</strong>: O(p Ã— n Ã— log(p)) due to the sorting operation</li>
</ul>
<h3 id="space-complexity-8"><a class="header" href="#space-complexity-8">Space Complexity</a></h3>
<ul>
<li>O(n) to store the parsed packet structures</li>
<li>O(p) for the list of all packets in Part 2</li>
</ul>
<h2 id="alternative-approaches-11"><a class="header" href="#alternative-approaches-11">Alternative Approaches</a></h2>
<h3 id="using-json-parsing"><a class="header" href="#using-json-parsing">Using JSON Parsing</a></h3>
<p>Since the packet format is essentially JSON, we could use a JSON parsing library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::Value;

fn compare_values(left: &amp;Value, right: &amp;Value) -&gt; Ordering {
    match (left, right) {
        (Value::Array(l), Value::Array(r)) =&gt; {
            // Compare arrays
            // ...
        },
        (Value::Number(l), Value::Number(r)) =&gt; {
            // Compare numbers
            // ...
        },
        (Value::Array(_), Value::Number(_)) =&gt; {
            // Convert number to array
            // ...
        },
        (Value::Number(_), Value::Array(_)) =&gt; {
            // Convert number to array
            // ...
        },
        _ =&gt; unreachable!()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This approach would rely on an external library but could be more robust for complex inputs.</p>
<h3 id="recursive-descent-parser"><a class="header" href="#recursive-descent-parser">Recursive Descent Parser</a></h3>
<p>Another approach would be to use a more structured recursive descent parser:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_packet(s: &amp;str) -&gt; ListItem {
    let mut chars = s.chars().peekable();
    parse_list(&amp;mut chars)
}

fn parse_list(chars: &amp;mut Peekable&lt;Chars&gt;) -&gt; ListItem {
    // Expect opening bracket
    assert_eq!(chars.next().unwrap(), '[');
    
    let mut list = vec![];
    
    // Parse items until closing bracket
    while chars.peek() != Some(&amp;']') {
        if chars.peek() == Some(&amp;'[') {
            list.push(parse_list(chars));
        } else {
            list.push(parse_number(chars));
        }
        
        // Skip comma if present
        if chars.peek() == Some(&amp;',') {
            chars.next();
        }
    }
    
    // Skip closing bracket
    chars.next();
    
    L(list)
}

fn parse_number(chars: &amp;mut Peekable&lt;Chars&gt;) -&gt; ListItem {
    // Parse digits into a number
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>This would be more structured but essentially accomplish the same thing as the current scanner approach.</p>
<h2 id="conclusion-10"><a class="header" href="#conclusion-10">Conclusion</a></h2>
<p>This solution demonstrates how to parse and compare nested data structures according to complex rules. The use of enums and trait implementations creates a clean, type-safe solution that directly models the problem domain. The comparison logic is implemented recursively to handle the nested nature of the data, and the solution efficiently processes both parts of the problem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-13-code"><a class="header" href="#day-13-code">Day 13: Code</a></h1>
<p>Below is the complete code for Day 13's solution, which parses and compares nested lists according to specific rules.</p>
<h2 id="full-solution-12"><a class="header" href="#full-solution-12">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">use std::cmp::Ordering;
use std::fmt::{Debug, Formatter};
use std::iter::Peekable;
use std::str::FromStr;
use crate::ListItem::{L, N};

fn packets_in_right_order(input: &amp;str) -&gt; usize {
    input.split("\n\n")
        .map(|x| x.lines().collect::&lt;Vec&lt;_&gt;&gt;() )
        .map(|d|
            (ListItem::from_str(d[0]), ListItem::from_str(d[1]))
        )
        .enumerate()
        .filter_map(|(i,(l,r))|
            if l.lt(&amp;r) { Some(i+1) } else { None }
        )
        .sum()
}

fn get_decoder_key(input: &amp;str) -&gt; usize {

    let dividers = vec![
        L(vec![L(vec![N(2)])]),
        L(vec![L(vec![N(6)])])
    ];

    let mut order = input.split("\n\n")
        .flat_map(|x| x.lines() )
        .filter_map(|d|
            ListItem::from_str(d).ok()
        )
        .chain(vec![ L(vec![L(vec![N(2)])]), L(vec![L(vec![N(6)])]) ] )
        .fold(vec![], |mut out, item|{
            out.push(item);
            out
        });

    order.sort();
    order.iter().for_each(|d| println!("{:?}",d));

    dividers.iter()
        .map(|d| order.binary_search(d).unwrap() + 1 )
        .product()
}

fn main() {
    // let mut input = "[1,1,3,1,1]\n[1,1,5,1,1]\n\n[[1],[2,3,4]]\n[[1],4]\n\n[9]\n[[8,7,6]]\n\n[[4,4],4,4]\n[[4,4],4,4,4]\n\n\
    // [7,7,7,7]\n[7,7,7]\n\n[]\n[3]\n\n[[[]]]\n[[]]\n\n[1,[2,[3,[4,[5,6,7]]]],8,9]\n[1,[2,[3,[4,[5,6,0]]]],8,9]".to_string();

    let input = std::fs::read_to_string("src/bin/day13_input.txt").expect("Ops!");

    let res = packets_in_right_order(input.as_str());
    println!("Correctly ordered packets = {:?}",res);
    let res = get_decoder_key(input.as_str());
    println!("Decoder Key = {:?}",res);

}

enum ListItem {
    N(u8),
    L(Vec&lt;ListItem&gt;)
}
impl ListItem {
    fn insert(&amp;mut self, item:ListItem) {
        match (self,item) {
            (L(list), item) =&gt; list.push(item),
            (N(old), N(new)) =&gt; *old = new,
            (_,_) =&gt; unreachable!()
        }
    }
}

impl FromStr for ListItem {
    type Err = ();

    fn from_str(inp: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {

        struct Scanner&lt;I: Iterator&lt;Item=char&gt;&gt; {
            i: Peekable&lt;I&gt;,
        }
        impl&lt;I: Iterator&lt;Item=char&gt;&gt; Scanner&lt;I&gt; {
            fn new(s: I) -&gt; Self {
                Scanner { i: s.peekable() }
            }
            fn parse_list(&amp;mut self) -&gt; ListItem {
                let mut s = String::new();
                let mut v = L(vec![]);
                loop {
                    match &amp;self.i.peek() {
                        Some('[') =&gt; {
                            self.i.next();
                            v.insert(self.parse_list());
                        },
                        Some(&amp;c@ '0'..='9') =&gt; s.push(c),
                        &amp;c@
                        (Some(',') | Some(']')) if !s.is_empty() =&gt; {
                            v.insert(N(u8::from_str(s.as_str()).expect("")));
                            s.clear();
                            if ']'.eq(c.unwrap()) {
                                break v
                            }
                        },
                        Some(',') =&gt; {}
                        Some(']') =&gt; break v,
                        None =&gt; break v,
                        _ =&gt; unreachable!()
                    }
                    self.i.next();
                }
            }
        }
        let mut i = inp.chars().peekable();
        i.next();
        Ok(Scanner::new(i).parse_list())
    }
}

impl PartialEq&lt;Self&gt; for ListItem {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.partial_cmp(other) == Some(Ordering::Equal)
    }
}

impl Eq for ListItem {}

impl Ord for ListItem {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        match (self,other) {
            (L(l), L(r)) =&gt; {
                let mut liter = l.iter();
                let mut riter = r.iter();

                loop {
                    match (liter.next(),riter.next()) {
                        (Some(l), Some(r)) =&gt;
                            match l.cmp(r) {
                                Ordering::Equal =&gt; {}
                                ord@
                                (Ordering::Less | Ordering::Greater) =&gt; break ord,
                            },
                        (Some(_), None) =&gt; break Ordering::Greater,
                        (None, Some(_)) =&gt; break Ordering::Less,
                        (None,None) =&gt; break Ordering::Equal,
                    };
                }
            }
            (L(_), N(r)) =&gt; {
                let right = L(vec![N(*r)]);
                self.cmp(&amp;right)
            }
            (N(l), L(_)) =&gt; {
                let left = L(vec![N(*l)]);
                left.cmp(other)
            }
            (N(l), N(r)) =&gt; l.cmp(r),
        }

    }
}

impl PartialOrd for ListItem {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}

impl Debug for ListItem {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            N(n) =&gt; write!(f,"{n}")?,
            L(v) =&gt; f.debug_list().entries(v.iter()).finish()?
        };
        Ok(())
    }
}</code></pre>
<h2 id="code-walkthrough-12"><a class="header" href="#code-walkthrough-12">Code Walkthrough</a></h2>
<h3 id="data-structure-for-packets"><a class="header" href="#data-structure-for-packets">Data Structure for Packets</a></h3>
<pre><code class="language-rust no_run noplayground">enum ListItem {
    N(u8),
    L(Vec&lt;ListItem&gt;)
}</code></pre>
<p>The solution uses an enum <code>ListItem</code> to represent the nested list structure of packets:</p>
<ul>
<li><code>N(u8)</code> represents a number (limited to u8 for this problem)</li>
<li><code>L(Vec&lt;ListItem&gt;)</code> represents a list containing other items (which can be numbers or lists)</li>
</ul>
<p>This recursive structure can represent any valid packet in the problem.</p>
<h3 id="parsing-packets"><a class="header" href="#parsing-packets">Parsing Packets</a></h3>
<pre><code class="language-rust no_run noplayground">impl FromStr for ListItem {
    type Err = ();

    fn from_str(inp: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {

        struct Scanner&lt;I: Iterator&lt;Item=char&gt;&gt; {
            i: Peekable&lt;I&gt;,
        }
        impl&lt;I: Iterator&lt;Item=char&gt;&gt; Scanner&lt;I&gt; {
            fn new(s: I) -&gt; Self {
                Scanner { i: s.peekable() }
            }
            fn parse_list(&amp;mut self) -&gt; ListItem {
                let mut s = String::new();
                let mut v = L(vec![]);
                loop {
                    match &amp;self.i.peek() {
                        Some('[') =&gt; {
                            self.i.next();
                            v.insert(self.parse_list());
                        },
                        Some(&amp;c@ '0'..='9') =&gt; s.push(c),
                        &amp;c@
                        (Some(',') | Some(']')) if !s.is_empty() =&gt; {
                            v.insert(N(u8::from_str(s.as_str()).expect("")));
                            s.clear();
                            if ']'.eq(c.unwrap()) {
                                break v
                            }
                        },
                        Some(',') =&gt; {}
                        Some(']') =&gt; break v,
                        None =&gt; break v,
                        _ =&gt; unreachable!()
                    }
                    self.i.next();
                }
            }
        }
        let mut i = inp.chars().peekable();
        i.next();
        Ok(Scanner::new(i).parse_list())
    }
}
</code></pre>
<p>The <code>FromStr</code> implementation uses a custom scanner to parse the input string into a <code>ListItem</code>:</p>
<ol>
<li>It creates a <code>Scanner</code> with a peekable iterator over the input characters</li>
<li>The <code>parse_list</code> method recursively builds the list structure by:
<ul>
<li>Creating a new list when encountering <code>[</code></li>
<li>Accumulating digits for numbers</li>
<li>Inserting numbers when reaching a comma or closing bracket</li>
<li>Breaking when reaching the end of the list</li>
</ul>
</li>
<li>The method returns the parsed <code>ListItem</code></li>
</ol>
<h3 id="item-insertion-helper"><a class="header" href="#item-insertion-helper">Item Insertion Helper</a></h3>
<pre><code class="language-rust no_run noplayground">impl ListItem {
    fn insert(&amp;mut self, item:ListItem) {
        match (self,item) {
            (L(list), item) =&gt; list.push(item),
            (N(old), N(new)) =&gt; *old = new,
            (_,_) =&gt; unreachable!()
        }
    }
}
</code></pre>
<p>This helper method adds an item to a list or updates a number.</p>
<h3 id="comparison-logic-1"><a class="header" href="#comparison-logic-1">Comparison Logic</a></h3>
<pre><code class="language-rust no_run noplayground">impl Ord for ListItem {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        match (self,other) {
            (L(l), L(r)) =&gt; {
                let mut liter = l.iter();
                let mut riter = r.iter();

                loop {
                    match (liter.next(),riter.next()) {
                        (Some(l), Some(r)) =&gt;
                            match l.cmp(r) {
                                Ordering::Equal =&gt; {}
                                ord@
                                (Ordering::Less | Ordering::Greater) =&gt; break ord,
                            },
                        (Some(_), None) =&gt; break Ordering::Greater,
                        (None, Some(_)) =&gt; break Ordering::Less,
                        (None,None) =&gt; break Ordering::Equal,
                    };
                }
            }
            (L(_), N(r)) =&gt; {
                let right = L(vec![N(*r)]);
                self.cmp(&amp;right)
            }
            (N(l), L(_)) =&gt; {
                let left = L(vec![N(*l)]);
                left.cmp(other)
            }
            (N(l), N(r)) =&gt; l.cmp(r),
        }

    }
}</code></pre>
<p>The <code>Ord</code> implementation defines how to compare two <code>ListItem</code> values:</p>
<ol>
<li><strong>List vs. List</strong>: Compare elements one by one until finding a difference or reaching the end of a list</li>
<li><strong>List vs. Number</strong>: Convert the number to a single-item list and retry comparison</li>
<li><strong>Number vs. List</strong>: Convert the number to a single-item list and retry comparison</li>
<li><strong>Number vs. Number</strong>: Use the built-in number comparison</li>
</ol>
<p>This implements the comparison rules specified in the problem.</p>
<h3 id="additional-trait-implementations"><a class="header" href="#additional-trait-implementations">Additional Trait Implementations</a></h3>
<pre><code class="language-rust no_run noplayground">impl PartialEq&lt;Self&gt; for ListItem {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.partial_cmp(other) == Some(Ordering::Equal)
    }
}

impl Eq for ListItem {}</code></pre>
<pre><code class="language-rust no_run noplayground">impl PartialOrd for ListItem {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}</code></pre>
<p>These implementations ensure that <code>ListItem</code> supports all the comparison operators and can be used in sorting operations.</p>
<h3 id="debug-display"><a class="header" href="#debug-display">Debug Display</a></h3>
<pre><code class="language-rust no_run noplayground">impl Debug for ListItem {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            N(n) =&gt; write!(f,"{n}")?,
            L(v) =&gt; f.debug_list().entries(v.iter()).finish()?
        };
        Ok(())
    }
}</code></pre>
<p>This implementation formats <code>ListItem</code> values for debugging, using Rust's <code>debug_list</code> for nice formatting of lists.</p>
<h3 id="part-1-finding-correctly-ordered-pairs"><a class="header" href="#part-1-finding-correctly-ordered-pairs">Part 1: Finding Correctly Ordered Pairs</a></h3>
<pre><code class="language-rust no_run noplayground">fn packets_in_right_order(input: &amp;str) -&gt; usize {
    input.split("\n\n")
        .map(|x| x.lines().collect::&lt;Vec&lt;_&gt;&gt;() )
        .map(|d|
            (ListItem::from_str(d[0]), ListItem::from_str(d[1]))
        )
        .enumerate()
        .filter_map(|(i,(l,r))|
            if l.lt(&amp;r) { Some(i+1) } else { None }
        )
        .sum()
}</code></pre>
<p>This function processes the input for Part 1:</p>
<ol>
<li>Splits the input by double newlines to get pairs of packets</li>
<li>Parses each packet into a <code>ListItem</code></li>
<li>Uses the <code>lt</code> comparison to check if pairs are in the right order</li>
<li>Keeps 1-based indices of correctly ordered pairs</li>
<li>Sums these indices</li>
</ol>
<h3 id="part-2-sorting-and-finding-divider-packets"><a class="header" href="#part-2-sorting-and-finding-divider-packets">Part 2: Sorting and Finding Divider Packets</a></h3>
<pre><code class="language-rust no_run noplayground">fn get_decoder_key(input: &amp;str) -&gt; usize {

    let dividers = vec![
        L(vec![L(vec![N(2)])]),
        L(vec![L(vec![N(6)])])
    ];

    let mut order = input.split("\n\n")
        .flat_map(|x| x.lines() )
        .filter_map(|d|
            ListItem::from_str(d).ok()
        )
        .chain(vec![ L(vec![L(vec![N(2)])]), L(vec![L(vec![N(6)])]) ] )
        .fold(vec![], |mut out, item|{
            out.push(item);
            out
        });

    order.sort();
    order.iter().for_each(|d| println!("{:?}",d));

    dividers.iter()
        .map(|d| order.binary_search(d).unwrap() + 1 )
        .product()
}</code></pre>
<p>This function processes the input for Part 2:</p>
<ol>
<li>Defines the two divider packets (<code>[[2]]</code> and <code>[[6]]</code>)</li>
<li>Parses all packets from the input and adds the divider packets</li>
<li>Sorts all packets using the comparison logic</li>
<li>Finds the 1-based indices of the divider packets</li>
<li>Multiplies these indices to get the decoder key</li>
</ol>
<h3 id="main-function-5"><a class="header" href="#main-function-5">Main Function</a></h3>
<pre><code class="language-rust no_run noplayground">fn main() {
    // let mut input = "[1,1,3,1,1]\n[1,1,5,1,1]\n\n[[1],[2,3,4]]\n[[1],4]\n\n[9]\n[[8,7,6]]\n\n[[4,4],4,4]\n[[4,4],4,4,4]\n\n\
    // [7,7,7,7]\n[7,7,7]\n\n[]\n[3]\n\n[[[]]]\n[[]]\n\n[1,[2,[3,[4,[5,6,7]]]],8,9]\n[1,[2,[3,[4,[5,6,0]]]],8,9]".to_string();

    let input = std::fs::read_to_string("src/bin/day13_input.txt").expect("Ops!");

    let res = packets_in_right_order(input.as_str());
    println!("Correctly ordered packets = {:?}",res);
    let res = get_decoder_key(input.as_str());
    println!("Decoder Key = {:?}",res);

}</code></pre>
<p>The main function reads the input file and runs both parts of the problem.</p>
<h2 id="implementation-notes-11"><a class="header" href="#implementation-notes-11">Implementation Notes</a></h2>
<ul>
<li><strong>Recursive Data Structure</strong>: The solution uses a recursive enum to represent the nested packet structure</li>
<li><strong>Custom Parser</strong>: The parser handles the specific format of the input without relying on external libraries</li>
<li><strong>Trait Implementations</strong>: The comparison logic is cleanly implemented using Rust's trait system</li>
<li><strong>Functional Style</strong>: The solution uses a functional programming style with iterators and method chaining</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-14-regolith-reservoir"><a class="header" href="#day-14-regolith-reservoir">Day 14: Regolith Reservoir</a></h1>
<p>Day 14 involves simulating falling sand in a cave system with rock formations.</p>
<h2 id="problem-overview-13"><a class="header" href="#problem-overview-13">Problem Overview</a></h2>
<p>You're mapping out a cave with rock structures and need to simulate how sand will fall and accumulate. The key elements are:</p>
<ol>
<li>Rock formations are represented as lines in the input</li>
<li>Sand falls from a specific source point (500, 0)</li>
<li>Each sand unit follows specific movement rules until it comes to rest or falls into the abyss</li>
<li>For Part 1, you need to count how many sand units come to rest before sand starts falling into the abyss</li>
<li>For Part 2, a floor is added, and you need to count how many sand units it takes to block the source</li>
</ol>
<p>This problem tests your ability to simulate physical processes and handle grid-based representations of a 2D space.</p>
<h2 id="navigation-13"><a class="header" href="#navigation-13">Navigation</a></h2>
<ul>
<li><a href="day14/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day14/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day14/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-14-problem-description"><a class="header" href="#day-14-problem-description">Day 14: Problem Description</a></h1>
<h2 id="regolith-reservoir"><a class="header" href="#regolith-reservoir">Regolith Reservoir</a></h2>
<p>The distress signal leads you to a giant waterfall! Actually, hang on - the signal seems like it's coming from the waterfall itself, and that doesn't make any sense. However, you do notice a little path that leads <strong>behind</strong> the waterfall.</p>
<p>Mineral formations of various kinds are dripping into small pools. The distress signal must be coming from somewhere in the cave behind the waterfall.</p>
<p>Your handheld device downloads a scan of the cave; this scan shows the shape of the cave walls. Your device reports that there's a kind of sand that slowly drops out of thin air and settles in the cave. When you see it in person, you confirm this - the source of the sand seems to be a point above the cave.</p>
<p>This scan is useful for detecting whether more sand will fall. Using your scan, simulate the falling sand. How many units of sand come to rest before sand starts flowing into the abyss below?</p>
<p>Sand is pouring into the cave from point <code>500,0</code>.</p>
<p>Drawing rock as <code>#</code>, air as <code>.</code>, and the source of the sand as <code>+</code>, this example looks like this:</p>
<pre><code>  4     5  5
  9     0  0
  4     0  3
0 ......+...
1 ..........
2 ..........
3 ..........
4 ....#...##
5 ....#...#.
6 ..###...#.
7 ........#.
8 ........#.
9 #########.
</code></pre>
<p>Sand is produced <strong>one unit at a time</strong>, and the next unit of sand is not produced until the previous unit of sand comes to rest. A unit of sand is large enough to fill one tile of air in your scan.</p>
<p>A unit of sand always falls <strong>down one step</strong> if possible. If the tile immediately below is blocked (by rock or sand), the unit of sand attempts to instead move diagonally <strong>one step down and to the left</strong>. If that tile is blocked, the unit of sand attempts to instead move diagonally <strong>one step down and to the right</strong>. Sand keeps moving as long as it is able to do so, at each step trying to move down, then down-left, then down-right. If all three possible destinations are blocked, the unit of sand <strong>comes to rest</strong> and no longer moves, at which point the next unit of sand is created back at the source.</p>
<p>Using your scan, simulate the falling sand. <strong>How many units of sand come to rest before sand starts flowing into the abyss below?</strong></p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>In this example, the first unit of sand falls downward until it lands on the rock path at the bottom:</p>
<pre><code>......+...
..........
..........
..........
....#...##
....#...#.
..###...#.
........#.
......o.#.
#########.
</code></pre>
<p>The second unit of sand follows a slightly different path, falling to the right and then coming to rest:</p>
<pre><code>......+...
..........
..........
..........
....#...##
....#...#.
..###...#.
........#.
.....oo.#.
#########.
</code></pre>
<p>After a total of 5 units of sand come to rest, they form this pattern:</p>
<pre><code>......+...
..........
..........
..........
....#...##
....#...#.
..###...#.
......o.#.
....oooo#.
#########.
</code></pre>
<p>After a total of 22 units of sand fall:</p>
<pre><code>......+...
..........
......o...
.....ooo..
....#ooo##
....#ooo#.
..###ooo#.
....oooo#.
...ooooo#.
#########.
</code></pre>
<p>After a total of 24 units of sand fall:</p>
<pre><code>......+...
..........
......o...
.....ooo..
....#ooo##
...o#ooo#.
..###ooo#.
....oooo#.
.o.ooooo#.
#########.
</code></pre>
<p>Finally, using your scan, once a total of <strong>24</strong> units of sand come to rest, all further sand flows out the bottom, falling into the endless void. Just for fun, the path any new sand takes before falling forever is shown here with <code>~</code>:</p>
<pre><code>.......+...
.......~...
......~o...
.....~ooo..
....~#ooo##
...~o#ooo#.
..~###ooo#.
..~..oooo#.
.~o.ooooo#.
~#########.
~..........
~..........
~..........
</code></pre>
<p>For Part 1, once all 24 units of sand shown above come to rest, all further sand flows out the bottom, falling into the endless void.</p>
<h2 id="part-2-13"><a class="header" href="#part-2-13">Part 2</a></h2>
<p>You realize you misunderstood the scan. There isn't an endless void at the bottom of the scan - there's floor, and you're standing on it!</p>
<p>You don't have time to scan the floor, so just assume the floor is an infinite horizontal line with a y coordinate equal to <strong>two plus the highest y coordinate</strong> of any point in your scan.</p>
<p>In the example above, the highest y coordinate of any point is 9, and so the floor is at y=11. (This is as if your scan contained one extra rock path from <code>0,11</code> to <code>500,11</code>.)</p>
<p>With the added floor, the sand spreads to the left and right, reaching a position of rest if it encounters a higher sand unit. Because of this, more sand is able to come to rest before the source is blocked.</p>
<p>Using your scan and assuming the floor is an infinite horizontal line with a y coordinate equal to two plus the highest y coordinate of any point in your scan, <strong>how many units of sand come to rest?</strong></p>
<p>In the example from Part 1, after a total of 93 units of sand fall and come to rest, no more sand can come to rest. The source becomes blocked when sand unit 94 is produced:</p>
<pre><code>............o............
...........ooo...........
..........ooooo..........
.........ooooooo.........
........oo#ooo##o........
.......ooo#ooo#ooo.......
......oo###ooo#oooo......
.....oooo.oooo#ooooo.....
....oooooooooo#oooooo....
...ooo#########ooooooo...
..ooooo.......ooooooooo..
#########################
</code></pre>
<p>For Part 2, using your scan, <strong>how many units of sand come to rest</strong> before the source of the sand becomes blocked?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-14-solution-explanation"><a class="header" href="#day-14-solution-explanation">Day 14: Solution Explanation</a></h1>
<h2 id="approach-13"><a class="header" href="#approach-13">Approach</a></h2>
<p>Day 14 involves simulating falling sand in a cave system with rock formations. The solution needs to handle several key aspects:</p>
<ol>
<li><strong>Parsing the rock formations</strong>: Converting input lines into coordinates for rock paths</li>
<li><strong>Representing the cave</strong>: Creating a data structure to track materials (rock, sand, air) at each position</li>
<li><strong>Simulating sand movement</strong>: Implementing the rules for sand falling and coming to rest</li>
<li><strong>Handling two scenarios</strong>: Tracking sand units for both scenarios (with and without a floor)</li>
</ol>
<p>The solution uses a grid-based approach with custom data types for the board, materials, and sand grains.</p>
<h2 id="implementation-details-13"><a class="header" href="#implementation-details-13">Implementation Details</a></h2>
<h3 id="data-structures-4"><a class="header" href="#data-structures-4">Data Structures</a></h3>
<p>The solution uses several key data structures:</p>
<h4 id="board"><a class="header" href="#board">Board</a></h4>
<p>The <code>Board&lt;T&gt;</code> struct represents the cave system:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Board&lt;T&gt; {
    width: usize,
    height: usize,
    centre_x: usize,
    offset_x: usize,
    grid: HashMap&lt;Coord, T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This structure uses a hashmap to store the material at each position, which is more memory-efficient than a full 2D array when most of the cave is air.</p>
<h4 id="material"><a class="header" href="#material">Material</a></h4>
<p>An enum represents the different materials in the cave:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Material { Rock, Sand, Air }
<span class="boring">}</span></code></pre></pre>
<h4 id="grain"><a class="header" href="#grain">Grain</a></h4>
<p>The <code>Grain</code> struct represents a single unit of sand:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Grain {
    pos: Coord,
    settled: bool
}
<span class="boring">}</span></code></pre></pre>
<h3 id="parsing-rock-formations"><a class="header" href="#parsing-rock-formations">Parsing Rock Formations</a></h3>
<p>The input is parsed into a series of rock paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_plines(input:&amp;str) -&gt; (Coord, Coord, Vec&lt;Vec&lt;Coord&gt;&gt;) {
    let mut br = Coord{ x: usize::MIN, y: usize::MIN };
    let mut tl = Coord{ x: usize::MAX, y: 0 };
    let plines =
        input.lines()
            .map(|line|{
                line.split(" -&gt; ")
                    .map(|val| Coord::from_str(val).expect("Ops!"))
                    .inspect(|p|{
                        tl.x = std::cmp::min(tl.x, p.x);
                        br.x = std::cmp::max(br.x, p.x);
                        br.y = std::cmp::max(br.y, p.y);
                    })
                    .collect::&lt;Vec&lt;_&gt;&gt;()
            })
            .fold(vec![],|mut out, pline|{
                out.push(pline);
                out
            });
    (tl, br, plines)
}
<span class="boring">}</span></code></pre></pre>
<p>This function:</p>
<ol>
<li>Parses each line of the input into a sequence of coordinates</li>
<li>Tracks the bounding box of all coordinates (top-left and bottom-right)</li>
<li>Returns the bounding box and the list of rock paths</li>
</ol>
<h3 id="creating-the-cave-board"><a class="header" href="#creating-the-cave-board">Creating the Cave Board</a></h3>
<p>The board is created based on the bounding box:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(tl: Coord, br: Coord) -&gt; Self {
    let width = br.x - tl.x + 1 + 200;
    let offset_x = if tl.x &gt; 200 { tl.x - 100 } else { 0 };
    let centre_x = 500 - offset_x;
    Board {
        width,
        height: br.y + 3,
        centre_x,
        offset_x,
        grid: HashMap::new()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The board is sized to include all rock formations plus some extra space for sand to accumulate. The <code>offset_x</code> value is used to make the board more memory-efficient by not starting from x=0 when all the action happens near x=500.</p>
<h3 id="drawing-rock-formations"><a class="header" href="#drawing-rock-formations">Drawing Rock Formations</a></h3>
<p>Rock formations are drawn on the board using the <code>Painter</code> helper:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rock_walls(board: &amp;mut Board&lt;Material&gt;, points: &amp;Vec&lt;Coord&gt;) {
    points.windows(2)
        .for_each(|w|{
            if let [a, b] = w {
                Painter::wall(board, *a, *b, Material::Rock);
            }
        })
}
<span class="boring">}</span></code></pre></pre>
<p>This function takes a sequence of points and draws rock walls between each consecutive pair. The <code>wall</code> function handles drawing both horizontal and vertical lines:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn wall(board: &amp;mut Board&lt;Material&gt;, a: Coord, b: Coord, m: Material) {
    if a.x == b.x {
        // vertical wall
        for y in std::cmp::min(a.y, b.y)..=std::cmp::max(a.y, b.y) {
            *board.square_mut(Coord { x: a.x, y }).unwrap() = m;
        }
    } else if a.y == b.y {
        // horizontal wall
        for x in std::cmp::min(a.x, b.x)..=std::cmp::max(a.x, b.x) {
            *board.square_mut(Coord { x, y: a.y }).unwrap() = m;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="simulating-sand-movement"><a class="header" href="#simulating-sand-movement">Simulating Sand Movement</a></h3>
<p>The core of the solution is the sand simulation. A unit of sand falls according to specific rules until it comes to rest or falls into the abyss:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fall(&amp;mut self, board: &amp;Board&lt;Material&gt;) -&gt; Option&lt;()&gt; {
    // Try to move down
    let down = Coord { x: self.pos.x, y: self.pos.y + 1 };
    if let Some(Material::Air) = board.square(down) {
        self.pos = down;
        return Some(());
    }
    
    // Try to move down-left
    let down_left = Coord { x: self.pos.x - 1, y: self.pos.y + 1 };
    if let Some(Material::Air) = board.square(down_left) {
        self.pos = down_left;
        return Some(());
    }
    
    // Try to move down-right
    let down_right = Coord { x: self.pos.x + 1, y: self.pos.y + 1 };
    if let Some(Material::Air) = board.square(down_right) {
        self.pos = down_right;
        return Some(());
    }
    
    // Can't move further
    if board.in_bounds(self.pos) {
        self.settled = true;
        Some(())
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This method tries to move the sand grain in the priority order: down, down-left, down-right. If no move is possible, the grain comes to rest.</p>
<h3 id="running-the-simulation"><a class="header" href="#running-the-simulation">Running the Simulation</a></h3>
<p>The <code>run</code> method simulates falling sand until a specified condition is met:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run&lt;F&gt;(&amp;mut self, start: Coord, check_goal: F) where F: Fn(&amp;Grain) -&gt; bool {
    loop {
        let mut grain = Grain::release_grain(start);

        // let the grain fall until it either (a) settles or (b) falls off the board
        while grain.fall(self).is_some() {};

        // Have we reached an end state?
        // we use a closure that passes the stopped grain
        // for checking whether (a) it has fallen in the abyss or (b) reached the starting position
        if check_goal(&amp;grain) {
            // Mark settled grain position on the board
            *self.square_mut(grain.pos).unwrap() = Material::Sand;
            break
        }

        // Mark settled grain position on the board
        *self.square_mut(grain.pos).unwrap() = Material::Sand;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The method takes a closure <code>check_goal</code> that determines when to stop the simulation. This allows for different stopping conditions for Part 1 and Part 2.</p>
<h3 id="adding-a-floor-part-2"><a class="header" href="#adding-a-floor-part-2">Adding a Floor (Part 2)</a></h3>
<p>For Part 2, a floor is added at the bottom of the cave:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn toggle_floor(&amp;mut self) {
    let height = self.height-1;
    let left = Coord { x: self.offset_x, y: height };
    let right = Coord { x: self.offset_x + self.width - 1, y : height };
    match self.square(left) {
        Some(Material::Rock) =&gt; Painter::wall(self, left, right, Material::Air),
        _ =&gt; Painter::wall(self, left, right, Material::Rock)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This adds a horizontal rock wall at the bottom of the cave, simulating the floor described in Part 2.</p>
<h3 id="counting-sand-grains"><a class="header" href="#counting-sand-grains">Counting Sand Grains</a></h3>
<p>The solution counts the number of sand grains at rest:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn grains_at_rest(&amp;self) -&gt; usize {
    self.grid.values()
        .filter(|&amp;s| Material::Sand.eq(s))
        .count()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="solving-the-problem"><a class="header" href="#solving-the-problem">Solving the Problem</a></h3>
<p>The solution solves both parts of the problem:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Part 1: Count sand units until one falls into the abyss
board.run(start, |g| !g.is_settled());
println!("Scenario 1: Grains Rest: {}", board.grains_at_rest() - 1);

// Reset for Part 2
board.empty_sand();

// Part 2: Add floor and count until source is blocked
board.toggle_floor();
board.run(start, |g| g.pos.eq(&amp;start));
println!("Scenario 2: Grains Rest: {}", board.grains_at_rest());
<span class="boring">}</span></code></pre></pre>
<p>For Part 1, the simulation stops when a grain fails to settle (falls into the abyss).
For Part 2, the simulation stops when a grain settles at the source position, blocking further sand.</p>
<h2 id="visualization-1"><a class="header" href="#visualization-1">Visualization</a></h2>
<p>The solution includes a visualization component using the bracket-lib library, allowing you to see the sand falling in real-time.</p>
<h2 id="algorithm-analysis-4"><a class="header" href="#algorithm-analysis-4">Algorithm Analysis</a></h2>
<h3 id="time-complexity-9"><a class="header" href="#time-complexity-9">Time Complexity</a></h3>
<ul>
<li><strong>Parsing</strong>: O(n) where n is the number of coordinates in the input</li>
<li><strong>Sand Simulation</strong>: O(s u00d7 h) where s is the number of sand grains and h is the height of the cave</li>
<li><strong>Overall</strong>: O(s u00d7 h) since the sand simulation dominates</li>
</ul>
<h3 id="space-complexity-9"><a class="header" href="#space-complexity-9">Space Complexity</a></h3>
<ul>
<li><strong>Board Storage</strong>: O(r + s) where r is the number of rock positions and s is the number of sand positions</li>
<li><strong>Path Storage</strong>: O(n) for storing the rock paths</li>
</ul>
<h2 id="alternative-approaches-12"><a class="header" href="#alternative-approaches-12">Alternative Approaches</a></h2>
<h3 id="array-based-grid"><a class="header" href="#array-based-grid">Array-Based Grid</a></h3>
<p>Instead of using a hashmap for the grid, we could use a 2D array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ArrayBoard {
    width: usize,
    height: usize,
    grid: Vec&lt;Vec&lt;Material&gt;&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>This would have faster access times (O(1) vs. hashmap's average O(1) but worst-case O(n)), but would use more memory for sparse caves.</p>
<h3 id="scan-lines"><a class="header" href="#scan-lines">Scan Lines</a></h3>
<p>Another approach would be to use a scan line algorithm to more efficiently determine where sand will come to rest without simulating each step:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_rest_position(board: &amp;Board, start: Coord) -&gt; Option&lt;Coord&gt; {
    // Find the first rock/sand below the start position
    // Check if sand can flow left or right
    // Return the final rest position
}
<span class="boring">}</span></code></pre></pre>
<p>This could be faster for certain scenarios but would be more complex to implement correctly, especially for Part 2.</p>
<h2 id="conclusion-11"><a class="header" href="#conclusion-11">Conclusion</a></h2>
<p>This solution demonstrates a comprehensive approach to physical simulation in a grid-based environment. The use of a hashmap for the grid provides memory efficiency, while the simulation logic accurately captures the problem's constraints. The solution is also flexible enough to handle both parts of the problem with minimal changes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-14-code"><a class="header" href="#day-14-code">Day 14: Code</a></h1>
<p>Below is the complete code explanation for Day 14's solution, which simulates falling sand in a cave system with rock formations.</p>
<h2 id="code-structure"><a class="header" href="#code-structure">Code Structure</a></h2>
<p>The solution is quite extensive and uses several key components:</p>
<ol>
<li>A <code>Board&lt;T&gt;</code> struct to represent the cave grid</li>
<li>A <code>Material</code> enum for different types of material (rock, sand, air)</li>
<li>A <code>Grain</code> struct to track individual sand units</li>
<li>A <code>Painter</code> helper to draw rock formations</li>
<li>Simulation logic for falling sand</li>
<li>Visualization components using bracket-lib</li>
</ol>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<h3 id="board-and-materials"><a class="header" href="#board-and-materials">Board and Materials</a></h3>
<p>The cave is represented by a <code>Board</code> struct with a hashmap grid:</p>
<pre><code class="language-rust no_run noplayground">struct Board&lt;T&gt; {
    width: usize,
    height: usize,
    centre_x: usize,
    offset_x: usize,
    grid: HashMap&lt;Coord,T&gt;,
}</code></pre>
<p>The materials in the cave are represented by an enum:</p>
<pre><code class="language-rust no_run noplayground">enum Material { Rock, Sand, Air }
impl Default for Material {
    fn default() -&gt; Self { Material::Air }
}</code></pre>
<h3 id="sand-grain-representation"><a class="header" href="#sand-grain-representation">Sand Grain Representation</a></h3>
<p>Each unit of sand is represented by a <code>Grain</code> struct:</p>
<pre><code class="language-rust no_run noplayground">struct Grain {
    pos: Coord,
    settled: bool
}</code></pre>
<h3 id="parsing-rock-formations-1"><a class="header" href="#parsing-rock-formations-1">Parsing Rock Formations</a></h3>
<p>The input is parsed into rock formations:</p>
<pre><code class="language-rust no_run noplayground">fn parse_plines(input:&amp;str) -&gt; (Coord, Coord, Vec&lt;Vec&lt;Coord&gt;&gt;) {
    let mut br = Coord{ x: usize::MIN, y: usize::MIN };
    let mut tl = Coord{ x: usize::MAX, y: 0 };
    let plines =
        input.lines()
            .map(|line|{
                line.split(" -&gt; ")
                    .map(|val| Coord::from_str(val).expect("Ops!"))
                    .inspect(|p|{
                        tl.x = std::cmp::min(tl.x, p.x);
                        br.x = std::cmp::max(br.x, p.x);
                        br.y = std::cmp::max(br.y, p.y);
                    })
                    .collect::&lt;Vec&lt;_&gt;&gt;()
            })
            .fold(vec![],|mut out, pline|{
                out.push(pline);
                out
            });
    (tl, br, plines)
}</code></pre>
<h3 id="drawing-rock-walls"><a class="header" href="#drawing-rock-walls">Drawing Rock Walls</a></h3>
<p>Rock walls are drawn between consecutive points:</p>
<pre><code class="language-rust no_run noplayground">    fn rock_walls(board: &amp;mut Board&lt;Material&gt;, c: &amp;[Coord]) {
        c.windows(2)
            .for_each(| p|
                Painter::wall(board, p[0], p[1], Material::Rock)
            );
    }</code></pre>
<h3 id="sand-movement-simulation"><a class="header" href="#sand-movement-simulation">Sand Movement Simulation</a></h3>
<p>The core of the solution is the sand movement logic:</p>
<pre><code class="language-rust no_run noplayground">    fn fall(&amp;mut self, board: &amp;Board&lt;Material&gt;) -&gt; Option&lt;Coord&gt; {

        if self.settled { return None }

        let Coord{ x, y} = self.pos;

        let [lc, uc, rc] = [(x-1, y+1).into(), (x, y+1).into(), (x+1, y+1).into()];

        let l = board.square( lc );
        let u = board.square( uc );
        let r = board.square( rc );

        match (l,u,r) {
            (_, None, _) =&gt; None,
            (_, Some(Material::Air), _) =&gt; { self.pos = uc; Some(self.pos) },
            (Some(Material::Air), _, _) =&gt; { self.pos = lc; Some(self.pos) },
            (_, _, Some(Material::Air)) =&gt; { self.pos = rc; Some(self.pos) },
            (_, _, _) =&gt; { self.settled = true; None }
        }
    }
    fn is_settled(&amp;self) -&gt; bool {
        self.settled
    }
}</code></pre>
<h3 id="running-the-simulation-1"><a class="header" href="#running-the-simulation-1">Running the Simulation</a></h3>
<p>The simulation runs until a specified condition is met:</p>
<pre><code class="language-rust no_run noplayground">    fn run&lt;F&gt;(&amp;mut self, start: Coord, check_goal: F) where F: Fn(&amp;Grain) -&gt; bool {

        loop {
            let mut grain = Grain::release_grain(start);

            // let the grain fall until it either (a) settles or (b) falls off the board
            while grain.fall(self).is_some() {};

            // Have we reached an end state ?
                // we use a closure that passes the stopped grain
                // for checking whether (a) it has fallen in the abyss or (b) reached the starting position
            if check_goal(&amp;grain) {
                // Mark settled grain position on the board
                *self.square_mut(grain.pos).unwrap() = Material::Sand;
                break
            }

            // Mark settled grain position on the board
            *self.square_mut(grain.pos).unwrap() = Material::Sand;
        }
    }</code></pre>
<h3 id="managing-the-floor-part-2"><a class="header" href="#managing-the-floor-part-2">Managing the Floor (Part 2)</a></h3>
<p>A floor is added for Part 2:</p>
<pre><code class="language-rust no_run noplayground">    fn toggle_floor(&amp;mut self) {
        let height = self.height-1;
        let left = Coord { x: self.offset_x, y: height };
        let right = Coord { x: self.offset_x + self.width - 1, y : height };
        match self.square(left) {
            Some(Material::Rock) =&gt; Painter::wall(self, left, right, Material::Air),
            _ =&gt; Painter::wall(self, left, right, Material::Rock)
        }
    }</code></pre>
<h3 id="counting-sand-grains-1"><a class="header" href="#counting-sand-grains-1">Counting Sand Grains</a></h3>
<p>The solution counts sand grains at rest:</p>
<pre><code class="language-rust no_run noplayground">    fn grains_at_rest(&amp;self) -&gt; usize {
        self.grid.values()
            .filter(|&amp;s| Material::Sand.eq(s) )
            .count()
    }</code></pre>
<h3 id="main-function-6"><a class="header" href="#main-function-6">Main Function</a></h3>
<p>The main function sets up the simulation and runs both parts of the problem:</p>
<pre><code class="language-rust no_run noplayground">fn main() -&gt; BResult&lt;()&gt; {

    // let input = "498,4 -&gt; 498,6 -&gt; 496,6\n503,4 -&gt; 502,4 -&gt; 502,9 -&gt; 494,9".to_string();
    let input = std::fs::read_to_string("src/bin/day14_input.txt").expect("ops!");

    // parse the board's wall layout
    let (tl, br, plines) = parse_plines(input.as_str());

    let mut board = Board::new(tl, br);

    // paint layout on the board
    plines.into_iter()
        .for_each(|pline|
            Painter::rock_walls(&amp;mut board, &amp;pline)
        );

    // run the sand simulation until we reach the abyss, that is, grain stopped but not settled
    let start = (board.centre_x, 0).into();
    board.run(
        start, |g| !g.is_settled()
    );
    println!("Scenario 1: Grains Rest: {}\n{:?}", board.grains_at_rest() - 1, board);

    board.empty_sand();
    // add rock floor
    board.toggle_floor();
    // run the sand simulation until grain settled position == starting position
    board.run(
        start, |g| g.pos.eq(&amp;start)
    );
    println!("Scenario 2: Grains Rest: {}\n{:?}", board.grains_at_rest(), board);</code></pre>
<h2 id="visualization-2"><a class="header" href="#visualization-2">Visualization</a></h2>
<p>The solution includes a visualization component using bracket-lib:</p>
<pre><code class="language-rust no_run noplayground">    let ctx = BTermBuilder::simple(board.width &gt;&gt; 1, board.height &gt;&gt; 1)?
        .with_simple_console(board.width, board.height, "terminal8x8.png")
        .with_simple_console_no_bg(board.width, board.height, "terminal8x8.png")
        .with_simple_console_no_bg(board.width &gt;&gt; 2, board.height &gt;&gt; 2, "terminal8x8.png")
        .with_fps_cap(60f32)
        .with_title("S: Reset, R: Run, G: Grain: Q: Quit")
        .build()?;

    let mut app = App::init(
        Store {
            board,
            grains: VecDeque::new(),
            start
        },
        Levels::MENU
    );
    app.register_level(Levels::MENU, Menu);
    app.register_level(Levels::LEVEL1, ExerciseOne {run:false, abyss:false} );
    app.register_level(Levels::LEVEL2, ExerciseTwo {ceiling:false} );

    main_loop(ctx, app)</code></pre>
<h2 id="implementation-notes-12"><a class="header" href="#implementation-notes-12">Implementation Notes</a></h2>
<ul>
<li><strong>Grid Representation</strong>: The solution uses a hashmap for the grid, which is memory-efficient for sparse grids</li>
<li><strong>Flexible Simulation</strong>: The <code>run</code> method takes a closure parameter to allow different stopping conditions</li>
<li><strong>Visualization</strong>: The solution includes a real-time visualization of the falling sand</li>
<li><strong>Movement Logic</strong>: Sand follows specific rules with a priority order of movement directions</li>
</ul>
<p>The code elegantly handles both parts of the problem using a comprehensive simulation of the physical process described in the problem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-15-beacon-exclusion-zone"><a class="header" href="#day-15-beacon-exclusion-zone">Day 15: Beacon Exclusion Zone</a></h1>
<p>Day 15 involves analyzing sensor coverage to find positions where beacons cannot be present.</p>
<h2 id="problem-overview-14"><a class="header" href="#problem-overview-14">Problem Overview</a></h2>
<p>You need to help locate a distress beacon in a cave system. There are several sensors that can detect the nearest beacon, and you need to use this information to:</p>
<ol>
<li>Determine positions where a beacon cannot possibly be located</li>
<li>Find the one position in a specific area where the distress beacon must be located</li>
</ol>
<p>The key aspects of this problem are:</p>
<ul>
<li>Each sensor reports its position and the position of the nearest beacon</li>
<li>The distance between a sensor and its nearest beacon is calculated using Manhattan distance</li>
<li>For Part 1, you need to count positions that cannot contain a beacon in a specific row</li>
<li>For Part 2, you need to find the only possible position for the distress beacon in a large area</li>
</ul>
<p>This problem tests your ability to work with ranges and coordinate systems efficiently.</p>
<h2 id="navigation-14"><a class="header" href="#navigation-14">Navigation</a></h2>
<ul>
<li><a href="day15/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day15/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day15/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-15-problem-description"><a class="header" href="#day-15-problem-description">Day 15: Problem Description</a></h1>
<h2 id="beacon-exclusion-zone"><a class="header" href="#beacon-exclusion-zone">Beacon Exclusion Zone</a></h2>
<p>You feel the ground rumble again as the distress signal leads you to a large network of subterranean tunnels. You don't have time to search them all, but you don't need to: your pack contains a set of deployable <strong>sensors</strong> that you imagine were originally built to locate lost Elves.</p>
<p>The sensors aren't very powerful, but that's okay; your handheld device indicates that you're close enough to the source of the distress signal. You pull the emergency sensor system out of your pack, hit the big button on top, and the sensors zoom off down the tunnels.</p>
<p>Once a sensor finds a spot it thinks will give it a good reading, it attaches itself to a hard surface and begins monitoring for the nearest signal source <strong>beacon</strong>. Sensors and beacons always exist at integer coordinates. Each sensor knows its own position and can <strong>determine the position of a beacon precisely</strong>; however, sensors can only lock on to the one beacon <strong>closest to the sensor</strong> as measured by the <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distance</a>. (There is never a tie where two beacons are the same distance to a sensor.)</p>
<p>It doesn't take long for the sensors to report back their positions and closest beacons (your puzzle input). For example:</p>
<pre><code>Sensor at x=2, y=18: closest beacon is at x=-2, y=15
Sensor at x=9, y=16: closest beacon is at x=10, y=16
Sensor at x=13, y=2: closest beacon is at x=15, y=3
Sensor at x=12, y=14: closest beacon is at x=10, y=16
Sensor at x=10, y=20: closest beacon is at x=10, y=16
Sensor at x=14, y=17: closest beacon is at x=10, y=16
Sensor at x=8, y=7: closest beacon is at x=2, y=10
Sensor at x=2, y=0: closest beacon is at x=2, y=10
Sensor at x=0, y=11: closest beacon is at x=2, y=10
Sensor at x=20, y=14: closest beacon is at x=25, y=17
Sensor at x=17, y=20: closest beacon is at x=21, y=22
Sensor at x=16, y=7: closest beacon is at x=15, y=3
Sensor at x=14, y=3: closest beacon is at x=15, y=3
Sensor at x=20, y=1: closest beacon is at x=15, y=3
</code></pre>
<p>So, consider the sensor at <code>2,18</code>; the closest beacon to it is at <code>-2,15</code>. For the sensor at <code>9,16</code>, the closest beacon to it is at <code>10,16</code>.</p>
<p>Drawing sensors as <code>S</code> and beacons as <code>B</code>, the above arrangement of sensors and beacons looks like this:</p>
<pre><code>               1    1    2    2
     0    5    0    5    0    5
 0 ....S.................
 1 .......................
 2 ...............S.......
 3 ......................B
 4 .......................
 5 .......................
 6 .......................
 7 ..........S.......B....
 8 .......................
 9 .......................
10 ....B..................
11 ..S....................
12 .......................
13 .......................
14 ..............S...S....
15 B......................
16 ...........SB..........
17 ................S......
18 ....S.................
19 .......................
20 ............S......S...
21 .......................
22 .......................B
</code></pre>
<p>This isn't necessarily a comprehensive map of all beacons in the area, though. Because each sensor only identifies its closest beacon, if a sensor detects a beacon, you know there are no other beacons that close or closer to that sensor. There could still be beacons that just happen to not be the closest beacon to any sensor. Consider the sensor at <code>8,7</code>:</p>
<pre><code>               1    1    2    2
     0    5    0    5    0    5
-2 ..........#.............
-1 .........###............
 0 ....S...#####...........
 1 .......#######........S.
 2 ......#########S........
 3 .....###########B.......
 4 ....#############.......
 5 ...###############......
 6 ..#################.....
 7 .#########S#######.....
 8 ..#################.....
 9 ...###############......
10 ....B############.......
11 ..S..###########........
12 ......#########.........
13 .......#######..........
14 ........#####..S........
15 B........###............
16 ..........#SB...........
17 ................S.......
18 ....S.................
19 .......................
20 ............S......S...
21 .......................
22 .......................B
</code></pre>
<p>This sensor's closest beacon is at <code>2,10</code>, and so you know there are no beacons that close or closer (in any positions marked <code>#</code>).</p>
<p>None of the detected beacons seem to be producing the distress signal, so you'll need to work out where the distress beacon is by working out where it <strong>isn't</strong>. For now, keep things simple by counting the positions where a beacon cannot possibly be along just a single row.</p>
<p>So, suppose you have an arrangement of beacons and sensors like in the example above and, just in the row where <code>y=10</code>, you'd like to count the number of positions a beacon cannot possibly exist. The coverage from all sensors near that row looks like this:</p>
<pre><code>                 1    1    2    2
       0    5    0    5    0    5
 9 ...#########################...
10 ..####B######################..
11 .###S#############.###########.
</code></pre>
<p>In this example, in the row where <code>y=10</code>, there are <strong>26</strong> positions where a beacon cannot be present.</p>
<h2 id="part-1-13"><a class="header" href="#part-1-13">Part 1</a></h2>
<p>Consult the report from the sensors you just deployed. <strong>In the row where y=2000000, how many positions cannot contain a beacon?</strong></p>
<h2 id="part-2-14"><a class="header" href="#part-2-14">Part 2</a></h2>
<p>Your handheld device indicates that the distress signal is coming from a beacon nearby. The distress beacon is not detected by any sensor, but the distress beacon must have x and y coordinates each no lower than <code>0</code> and no larger than <code>4000000</code>.</p>
<p>To isolate the distress beacon's signal, you need to determine its <strong>tuning frequency</strong>, which can be found by multiplying its x coordinate by <code>4000000</code> and then adding its y coordinate.</p>
<p>In the example above, the search space is smaller: instead, the x and y coordinates can each be at most <code>20</code>. With this reduced search area, there is only a single position that could have a beacon: <code>x=14, y=11</code>. The tuning frequency for this distress beacon is <strong>56000011</strong>.</p>
<p><strong>Find the only possible position for the distress beacon. What is its tuning frequency?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-15-solution-explanation"><a class="header" href="#day-15-solution-explanation">Day 15: Solution Explanation</a></h1>
<h2 id="approach-14"><a class="header" href="#approach-14">Approach</a></h2>
<p>Day 15 involves analyzing sensor coverage to find positions where beacons cannot be present. The key challenge is efficiently handling the potentially large search space.</p>
<p>The solution breaks down into several components:</p>
<ol>
<li><strong>Parsing the input data</strong>: Extract sensor and beacon positions from the input</li>
<li><strong>Calculating sensor coverage</strong>: Determine the area each sensor can cover based on Manhattan distance</li>
<li><strong>Analyzing coverage on specific rows</strong>: Find ranges of positions that cannot contain a beacon</li>
<li><strong>Finding the distress beacon</strong>: Identify the one position where the distress beacon must be located</li>
</ol>
<p>The key insight is to work with ranges rather than individual positions, which allows for much more efficient processing.</p>
<h2 id="implementation-details-14"><a class="header" href="#implementation-details-14">Implementation Details</a></h2>
<h3 id="data-structures-5"><a class="header" href="#data-structures-5">Data Structures</a></h3>
<p>The solution uses several key data structures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Ord, PartialOrd, Copy, Clone, Eq, PartialEq, Hash)]
struct Coord {
    x: isize,
    y: isize
}

#[derive(Eq, PartialEq, Hash)]
struct Sensor {
    pos: Coord,
    beacon: Coord,
    dist: usize
}

struct Area {
    sensors: Vec&lt;Sensor&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>These structures represent coordinates, sensors, and the overall area being analyzed.</p>
<h3 id="parsing-the-input-5"><a class="header" href="#parsing-the-input-5">Parsing the Input</a></h3>
<p>The input is parsed into a collection of sensors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn deploy_sensors(sensors: &amp;str) -&gt; Area {
    Area {
        sensors: sensors.lines()
            .map(|line|
                line.split(&amp;[' ','=',',',':'])
                    .filter(|item| !item.trim().is_empty())
                    .filter(|item| item.chars().all(|d| d.is_numeric() || d == '-'))
                    .filter_map(|n| isize::from_str(n).ok())
                    .collect::&lt;Vec&lt;_&gt;&gt;()
            )
            .map(|comb|
                Sensor {
                    pos: (comb[0], comb[1]).into(),
                    beacon: (comb[2], comb[3]).into(),
                    dist: comb[0].abs_diff(comb[2]) + comb[1].abs_diff(comb[3])
                }
            )
            .collect::&lt;Vec&lt;_&gt;&gt;()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This function extracts the coordinates from each line and calculates the Manhattan distance between each sensor and its nearest beacon.</p>
<h3 id="calculating-sensor-coverage"><a class="header" href="#calculating-sensor-coverage">Calculating Sensor Coverage</a></h3>
<p>For each sensor, we need to determine its coverage at a specific y-coordinate. This is done by calculating a range of x-coordinates that the sensor can cover:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn coverage_at(&amp;self, d: isize) -&gt; Option&lt;RangeInclusive&lt;isize&gt;&gt; {
    let Coord{x, y} = self.pos;
    let diff = y.abs_diff(d);
    if diff &lt;= self.dist {
        Some(RangeInclusive::new(
            x.saturating_sub_unsigned(self.dist - diff),
            x.saturating_add_unsigned(self.dist - diff))
        )
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This method:</p>
<ol>
<li>Calculates the vertical distance from the sensor to the specified y-coordinate</li>
<li>If this distance is within the sensor's range, calculates the horizontal range the sensor can cover at that y-coordinate</li>
<li>Returns the range as a <code>RangeInclusive&lt;isize&gt;</code>, or <code>None</code> if the y-coordinate is out of range</li>
</ol>
<h3 id="analyzing-coverage-on-a-row"><a class="header" href="#analyzing-coverage-on-a-row">Analyzing Coverage on a Row</a></h3>
<p>To determine the coverage on a specific row, we need to combine the ranges from all sensors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sensor_coverage_at(&amp;self, line: isize) -&gt; Vec&lt;RangeInclusive&lt;isize&gt;&gt; {
    let mut result = vec![];

    let mut ranges = self.sensors.iter()
            .filter_map(|sensor| sensor.coverage_at(line))
            .collect::&lt;Vec&lt;_&gt;&gt;();

    ranges.sort_by_key(|a| *a.start());

    if let Some(last) = ranges.into_iter()
        .reduce(|a, b|
            if a.end() &gt;= &amp;(b.start()-1) {
                if a.end() &lt; b.end() {
                    *a.start()..=*b.end()
                } else { a }
            } else {
                // We got a range gap here hence we must save range A
                // while we pass on Range B to the next iteration
                result.push(a);
                b
            }
        ) {
        result.push(last);
    }
    result
}
<span class="boring">}</span></code></pre></pre>
<p>This method:</p>
<ol>
<li>Collects the coverage ranges from all sensors for the specified row</li>
<li>Sorts the ranges by their start position</li>
<li>Merges overlapping or adjacent ranges</li>
<li>Returns a list of non-overlapping ranges representing the total coverage</li>
</ol>
<p>The merging step is crucial for efficiency, as it allows us to represent large areas of coverage with just a few ranges.</p>
<h3 id="finding-beacons-on-a-row"><a class="header" href="#finding-beacons-on-a-row">Finding Beacons on a Row</a></h3>
<p>We also need to identify beacons that are already on the specified row:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn beacons_at(&amp;self, line: isize) -&gt; HashSet&lt;Coord&gt; {
    self.sensors.iter()
        .filter_map(|s| if s.beacon.y == line { Some(s.beacon) } else { None })
        .collect::&lt;HashSet&lt;_&gt;&gt;()
}
<span class="boring">}</span></code></pre></pre>
<p>This is used to exclude beacon positions from the count of positions where a beacon cannot be present.</p>
<h3 id="finding-the-distress-beacon-part-2"><a class="header" href="#finding-the-distress-beacon-part-2">Finding the Distress Beacon (Part 2)</a></h3>
<p>For Part 2, we need to find the one position in a large area where the distress beacon must be located. The key insight is that this position must be just outside the range of multiple sensors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (line, v) = (0..=4000000)
    .map(|line| (line, area.sensor_coverage_at(line)))
    .filter(|(_, v)| v.len() &gt; 1)
    .filter(|(_, v)| v[1].start() - v[0].end() &gt; 1)
    .next().unwrap();

let total = (v[0].end() + 1) * 4000000 + line;
<span class="boring">}</span></code></pre></pre>
<p>This code:</p>
<ol>
<li>Checks each row in the search area</li>
<li>Identifies rows where the coverage is split into multiple ranges</li>
<li>Finds the first row where there's a gap of exactly one position between ranges</li>
<li>Calculates the tuning frequency based on the position in the gap</li>
</ol>
<p>This approach is much more efficient than checking every possible position, as it only needs to examine rows where the coverage is not continuous.</p>
<h2 id="algorithmic-analysis-4"><a class="header" href="#algorithmic-analysis-4">Algorithmic Analysis</a></h2>
<h3 id="time-complexity-10"><a class="header" href="#time-complexity-10">Time Complexity</a></h3>
<ul>
<li><strong>Parsing</strong>: O(n) where n is the number of sensors</li>
<li><strong>Coverage Calculation</strong>: O(n) for each row analyzed</li>
<li><strong>Range Merging</strong>: O(n log n) due to the sorting step</li>
<li><strong>Part 1</strong>: O(n log n)</li>
<li><strong>Part 2</strong>: O(y * n log n) where y is the number of rows in the search area</li>
</ul>
<h3 id="space-complexity-10"><a class="header" href="#space-complexity-10">Space Complexity</a></h3>
<ul>
<li><strong>Storage</strong>: O(n) for storing the sensors and their information</li>
<li><strong>Range Processing</strong>: O(n) for storing the ranges during processing</li>
</ul>
<h2 id="alternative-approaches-13"><a class="header" href="#alternative-approaches-13">Alternative Approaches</a></h2>
<h3 id="grid-based-approach"><a class="header" href="#grid-based-approach">Grid-Based Approach</a></h3>
<p>A naive approach would be to use a grid to track each position:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn count_positions_without_beacon(sensors: &amp;[Sensor], y: isize, x_range: RangeInclusive&lt;isize&gt;) -&gt; usize {
    let mut count = 0;
    for x in x_range {
        let pos = Coord { x, y };
        if sensors.iter().any(|s| s.covers(pos)) &amp;&amp; !sensors.iter().any(|s| s.beacon == pos) {
            count += 1;
        }
    }
    count
}
<span class="boring">}</span></code></pre></pre>
<p>This would be much less efficient for large search areas, with a time complexity of O(x * n) where x is the width of the search area.</p>
<h3 id="binary-search-for-part-2"><a class="header" href="#binary-search-for-part-2">Binary Search for Part 2</a></h3>
<p>Another approach for Part 2 would be to use binary search to find the gap more efficiently:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_gap(ranges: &amp;[RangeInclusive&lt;isize&gt;], min: isize, max: isize) -&gt; Option&lt;isize&gt; {
    // Binary search for a gap in the ranges
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>This could potentially reduce the time complexity for finding the gap, but would be more complex to implement correctly.</p>
<h3 id="geometric-approach"><a class="header" href="#geometric-approach">Geometric Approach</a></h3>
<p>A more sophisticated approach would be to use computational geometry techniques:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_distress_beacon(sensors: &amp;[Sensor], bounds: (isize, isize)) -&gt; Coord {
    // Find intersection points of sensor boundaries
    // Check positions just outside the boundary of each sensor
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>This would be more efficient for very large search areas but would require more complex geometric calculations.</p>
<h2 id="conclusion-12"><a class="header" href="#conclusion-12">Conclusion</a></h2>
<p>This solution demonstrates an efficient approach to a problem that involves analyzing large ranges of positions. By working with ranges rather than individual positions, we can efficiently solve both parts of the problem. The range merging technique is particularly effective for Part 1, while the gap-finding approach allows us to solve Part 2 without exhaustively checking every position.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-15-code"><a class="header" href="#day-15-code">Day 15: Code</a></h1>
<p>Below is the complete code for Day 15's solution, which analyzes sensor coverage to find positions where beacons cannot be present.</p>
<h2 id="full-solution-13"><a class="header" href="#full-solution-13">Full Solution</a></h2>
<pre><code class="language-rust no_run noplayground">use std::collections::HashSet;
use std::fmt::{Debug, Formatter};
use std::ops::RangeInclusive;
use std::str::FromStr;

// const INPUT : &amp;str = "Sensor at x=2, y=18: closest beacon is at x=-2, y=15
// Sensor at x=9, y=16: closest beacon is at x=10, y=16
// Sensor at x=13, y=2: closest beacon is at x=15, y=3
// Sensor at x=12, y=14: closest beacon is at x=10, y=16
// Sensor at x=10, y=20: closest beacon is at x=10, y=16
// Sensor at x=14, y=17: closest beacon is at x=10, y=16
// Sensor at x=8, y=7: closest beacon is at x=2, y=10
// Sensor at x=2, y=0: closest beacon is at x=2, y=10
// Sensor at x=0, y=11: closest beacon is at x=2, y=10
// Sensor at x=20, y=14: closest beacon is at x=25, y=17
// Sensor at x=17, y=20: closest beacon is at x=21, y=22
// Sensor at x=16, y=7: closest beacon is at x=15, y=3
// Sensor at x=14, y=3: closest beacon is at x=15, y=3
// Sensor at x=20, y=1: closest beacon is at x=15, y=3";

fn main() {
    let input = std::fs::read_to_string("src/bin/day15_input.txt").expect("Ops!");

    let area = Area::deploy_sensors(input.as_str());

    // Component 1
    let res = area.sensor_coverage_at(2000000);
    println!("Signal Coverage @2000000 = {:?}",res);
    let beacons = area.beacons_at(2000000);
    println!("Beacons = {:?}",beacons);

    let positions = res.into_iter()
        .map(|r| r.count())
        .sum::&lt;usize&gt;();
    println!("{}-{}={} (4793062)", positions,beacons.len(),positions-beacons.len());

    // Component 2
    let (line, v) = (0..=4000000)
        .map(|line| (line,area.sensor_coverage_at(line)))
        .filter(|(_,v)| v.len() &gt; 1 )
        .filter(|(_,v)| v[1].start() - v[0].end() &gt; 1 )
        .next().unwrap();

    let total = (v[0].end() + 1) * 4000000 + line;
    println!("Signal Coverage @{line} = {:?} \nFreq of distress beacon: {total}", v);
}

struct Area {
    sensors: Vec&lt;Sensor&gt;
}
impl Area {
    fn deploy_sensors(sensors:&amp;str ) -&gt; Area {
        Area {
            sensors: sensors.lines()
                .map(|line|
                    line.split(&amp;[' ','=',',',':'])
                        .filter(|item| !item.trim().is_empty() )
                        .filter(|item| item.chars().all(|d| d.is_numeric() || d == '-'))
                        .filter_map(|n| isize::from_str(n).ok())
                        .collect::&lt;Vec&lt;_&gt;&gt;()
                )
                .map(|comb|
                    Sensor {
                        pos: (comb[0],comb[1]).into(),
                        beacon: (comb[2],comb[3]).into(),
                        dist: comb[0].abs_diff(comb[2]) + comb[1].abs_diff(comb[3])
                    }
                )
                .collect::&lt;Vec&lt;_&gt;&gt;()
        }
    }
    fn beacons_at(&amp;self, line:isize) -&gt; HashSet&lt;Coord&gt; {
        self.sensors.iter().filter_map(|s| if s.beacon.y == line { Some(s.beacon)} else {None}).collect::&lt;HashSet&lt;_&gt;&gt;()
    }
    fn sensor_coverage_at(&amp;self, line: isize) -&gt; Vec&lt;RangeInclusive&lt;isize&gt;&gt; {

        let mut result = vec![];

        let mut ranges = self.sensors.iter()
                .filter_map(|sensor| sensor.coverage_at(line))
                .collect::&lt;Vec&lt;_&gt;&gt;();

        ranges.sort_by_key(|a| *a.start());

        if let Some(last) = ranges.into_iter()
            .reduce(|a, b|
                if a.end() &gt;= &amp;(b.start()-1) {
                    if a.end() &lt; b.end() {
                        *a.start()..=*b.end()
                    } else { a }
                } else {
                    // We got a range gap here hence we must save range A
                    // while we pass on Range B to the next iteration
                    result.push(a);
                    b
                }
            ) {
            result.push(last);
        }
        result
    }
}

#[derive(Eq, PartialEq, Hash)]
struct Sensor {
    pos: Coord,
    beacon: Coord,
    dist: usize
}
impl Sensor {
    fn coverage_at(&amp;self, d: isize) -&gt; Option&lt;RangeInclusive&lt;isize&gt;&gt; {
        let Coord{x,y} = self.pos;
        let diff = y.abs_diff(d);
        if diff &lt;= self.dist {
            Some(RangeInclusive::new(
                x.saturating_sub_unsigned(self.dist - diff),
                x.saturating_add_unsigned(self.dist - diff))
            )
        } else {
            None
        }
    }
}

impl Debug for Sensor {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "S{:?} {:?} B{:?}",self.pos, self.dist, self.beacon)
    }
}

/// Generics
///

#[derive(Ord, PartialOrd,Copy, Clone, Eq, PartialEq,Hash)]
struct Coord {
    x: isize,
    y: isize
}
impl Debug for Coord {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "({},{})",self.x,self.y)
    }
}
impl From&lt;(isize,isize)&gt; for Coord {
    fn from(p: (isize, isize)) -&gt; Self {
        Coord { x:p.0, y:p.1 }
    }
}</code></pre>
<h2 id="code-walkthrough-13"><a class="header" href="#code-walkthrough-13">Code Walkthrough</a></h2>
<h3 id="core-data-structures-3"><a class="header" href="#core-data-structures-3">Core Data Structures</a></h3>
<pre><code class="language-rust no_run noplayground">#[derive(Ord, PartialOrd,Copy, Clone, Eq, PartialEq,Hash)]
struct Coord {
    x: isize,
    y: isize
}
impl Debug for Coord {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "({},{})",self.x,self.y)
    }
}</code></pre>
<p>The <code>Coord</code> struct represents a 2D coordinate with x and y values. It implements several traits to make it comparable, hashable, and printable.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Eq, PartialEq, Hash)]
struct Sensor {
    pos: Coord,
    beacon: Coord,
    dist: usize
}</code></pre>
<p>The <code>Sensor</code> struct contains information about a sensor's position, its closest beacon's position, and the Manhattan distance between them.</p>
<pre><code class="language-rust no_run noplayground">struct Area {
    sensors: Vec&lt;Sensor&gt;
}</code></pre>
<p>The <code>Area</code> struct is a container for all sensors in the input.</p>
<h3 id="sensor-coverage-calculation"><a class="header" href="#sensor-coverage-calculation">Sensor Coverage Calculation</a></h3>
<pre><code class="language-rust no_run noplayground">impl Sensor {
    fn coverage_at(&amp;self, d: isize) -&gt; Option&lt;RangeInclusive&lt;isize&gt;&gt; {
        let Coord{x,y} = self.pos;
        let diff = y.abs_diff(d);
        if diff &lt;= self.dist {
            Some(RangeInclusive::new(
                x.saturating_sub_unsigned(self.dist - diff),
                x.saturating_add_unsigned(self.dist - diff))
            )
        } else {
            None
        }
    }
}</code></pre>
<p>This method calculates the x-coordinate range that a sensor can cover at a specific y-coordinate. It:</p>
<ol>
<li>Calculates the vertical distance to the target line</li>
<li>If this distance is within the sensor's range, calculates the horizontal range</li>
<li>Returns the range, or <code>None</code> if the line is out of range</li>
</ol>
<h3 id="analyzing-sensor-coverage-on-a-row"><a class="header" href="#analyzing-sensor-coverage-on-a-row">Analyzing Sensor Coverage on a Row</a></h3>
<pre><code class="language-rust no_run noplayground">    fn sensor_coverage_at(&amp;self, line: isize) -&gt; Vec&lt;RangeInclusive&lt;isize&gt;&gt; {

        let mut result = vec![];

        let mut ranges = self.sensors.iter()
                .filter_map(|sensor| sensor.coverage_at(line))
                .collect::&lt;Vec&lt;_&gt;&gt;();

        ranges.sort_by_key(|a| *a.start());

        if let Some(last) = ranges.into_iter()
            .reduce(|a, b|
                if a.end() &gt;= &amp;(b.start()-1) {
                    if a.end() &lt; b.end() {
                        *a.start()..=*b.end()
                    } else { a }
                } else {
                    // We got a range gap here hence we must save range A
                    // while we pass on Range B to the next iteration
                    result.push(a);
                    b
                }
            ) {
            result.push(last);
        }
        result
    }</code></pre>
<p>This method aggregates coverage from all sensors on a specific row:</p>
<ol>
<li>Collects ranges from all sensors that cover the specified row</li>
<li>Sorts the ranges by their start position</li>
<li>Merges overlapping ranges using a <code>reduce</code> operation</li>
<li>Returns a vector of non-overlapping ranges representing total coverage</li>
</ol>
<h3 id="finding-beacons-on-a-row-1"><a class="header" href="#finding-beacons-on-a-row-1">Finding Beacons on a Row</a></h3>
<pre><code class="language-rust no_run noplayground">    fn beacons_at(&amp;self, line:isize) -&gt; HashSet&lt;Coord&gt; {
        self.sensors.iter().filter_map(|s| if s.beacon.y == line { Some(s.beacon)} else {None}).collect::&lt;HashSet&lt;_&gt;&gt;()
    }</code></pre>
<p>This method identifies all beacons located on a specific row.</p>
<h3 id="parsing-input-5"><a class="header" href="#parsing-input-5">Parsing Input</a></h3>
<pre><code class="language-rust no_run noplayground">    fn deploy_sensors(sensors:&amp;str ) -&gt; Area {
        Area {
            sensors: sensors.lines()
                .map(|line|
                    line.split(&amp;[' ','=',',',':'])
                        .filter(|item| !item.trim().is_empty() )
                        .filter(|item| item.chars().all(|d| d.is_numeric() || d == '-'))
                        .filter_map(|n| isize::from_str(n).ok())
                        .collect::&lt;Vec&lt;_&gt;&gt;()
                )
                .map(|comb|
                    Sensor {
                        pos: (comb[0],comb[1]).into(),
                        beacon: (comb[2],comb[3]).into(),
                        dist: comb[0].abs_diff(comb[2]) + comb[1].abs_diff(comb[3])
                    }
                )
                .collect::&lt;Vec&lt;_&gt;&gt;()
        }
    }</code></pre>
<p>This method parses the input text into <code>Sensor</code> objects by:</p>
<ol>
<li>Splitting each line into parts</li>
<li>Filtering out non-numeric parts</li>
<li>Converting numeric strings to integers</li>
<li>Constructing sensors with their positions, beacon positions, and distances</li>
</ol>
<h3 id="main-function-7"><a class="header" href="#main-function-7">Main Function</a></h3>
<pre><code class="language-rust no_run noplayground">fn main() {
    let input = std::fs::read_to_string("src/bin/day15_input.txt").expect("Ops!");

    let area = Area::deploy_sensors(input.as_str());

    // Component 1
    let res = area.sensor_coverage_at(2000000);
    println!("Signal Coverage @2000000 = {:?}",res);
    let beacons = area.beacons_at(2000000);
    println!("Beacons = {:?}",beacons);

    let positions = res.into_iter()
        .map(|r| r.count())
        .sum::&lt;usize&gt;();
    println!("{}-{}={} (4793062)", positions,beacons.len(),positions-beacons.len());

    // Component 2
    let (line, v) = (0..=4000000)
        .map(|line| (line,area.sensor_coverage_at(line)))
        .filter(|(_,v)| v.len() &gt; 1 )
        .filter(|(_,v)| v[1].start() - v[0].end() &gt; 1 )
        .next().unwrap();

    let total = (v[0].end() + 1) * 4000000 + line;
    println!("Signal Coverage @{line} = {:?} \nFreq of distress beacon: {total}", v);
}</code></pre>
<p>The main function:</p>
<ol>
<li>Reads and parses the input file</li>
<li>For Part 1:
<ul>
<li>Gets the sensor coverage on row 2000000</li>
<li>Identifies beacons already on that row</li>
<li>Calculates the number of positions that cannot contain a beacon</li>
</ul>
</li>
<li>For Part 2:
<ul>
<li>Checks each row in the search area (0 to 4000000)</li>
<li>Finds a row where the coverage is split with a gap of exactly one position</li>
<li>Calculates the tuning frequency of the distress beacon</li>
</ul>
</li>
</ol>
<p>The key insight for Part 2 is that the distress beacon must be in a position that is just outside the range of multiple sensors, which appears as a gap in the coverage.</p>
<h2 id="implementation-notes-13"><a class="header" href="#implementation-notes-13">Implementation Notes</a></h2>
<ul>
<li><strong>Range Representation</strong>: The solution uses <code>RangeInclusive&lt;isize&gt;</code> to represent coverage ranges efficiently</li>
<li><strong>Merge Algorithm</strong>: Overlapping ranges are merged, significantly reducing the number of ranges needed to represent coverage</li>
<li><strong>Efficient Searching</strong>: The solution for Part 2 efficiently finds the gap by examining rows with split coverage rather than checking every position</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-16-proboscidea-volcanium"><a class="header" href="#day-16-proboscidea-volcanium">Day 16: Proboscidea Volcanium</a></h1>
<p>Day 16 involves finding the optimal sequence for opening valves to release maximum pressure in a cave system.</p>
<h2 id="problem-overview-15"><a class="header" href="#problem-overview-15">Problem Overview</a></h2>
<p>You're trying to escape a volcano through a network of tunnels with pressure-release valves. Your goal is to maximize the pressure released before time runs out. Key aspects include:</p>
<ol>
<li>Valves have different flow rates, and many have a flow rate of zero</li>
<li>Moving between valves takes 1 minute, and opening a valve takes 1 minute</li>
<li>For Part 1, you have 30 minutes to release as much pressure as possible</li>
<li>For Part 2, you work with an elephant for 26 minutes to release maximum pressure</li>
</ol>
<p>This problem is essentially a pathfinding optimization problem where the goal is to find the sequence of valve openings that maximizes the total pressure released.</p>
<h2 id="navigation-15"><a class="header" href="#navigation-15">Navigation</a></h2>
<ul>
<li><a href="day16/./problem.html">Problem Description</a>: Detailed description of the day's challenge</li>
<li><a href="day16/./solution.html">Solution Explanation</a>: Walkthrough of the approach used</li>
<li><a href="day16/./code.html">Code</a>: The complete implementation with comments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-16-problem-description"><a class="header" href="#day-16-problem-description">Day 16: Problem Description</a></h1>
<h2 id="proboscidea-volcanium"><a class="header" href="#proboscidea-volcanium">Proboscidea Volcanium</a></h2>
<p>The sensors have led you to the origin of the distress signal at the top of a large mountain. The mountain is made up of hot springs and waterfalls, but the terrain is otherwise treacherous and difficult to navigate.</p>
<p>As the expedition team begins climbing the mountain, you notice a trail of <strong>steam</strong> that ends at the entrance to a large cave. As you begin to make your way there, wolves with glowing red eyes begin circling you.</p>
<p>Just then, a sudden gust of freezing wind blows a small locket with a picture of you in front of you onto the ground. As you pick it up, you begin to hear echoing all around you â€” a distress message from the Elves about danger in the underground cave. You consider the wolves and begin broadcasting your own danger message on a frequency the wolves can't hear.</p>
<p>The distress message includes information about how the cave currently works in its present non-volcanic state. If you can calculate the potential pressure releases just in time, you might have a chance to stop the volcano from erupting.</p>
<p>You scan the cave for potential pressure release valves. Through your scan, you detect a network of pipes and valves. There's a pressure-release <strong>valve</strong> at each junction of pipes, a component that can be remotely operated over radio (your puzzle input). Each one of these valves has a flow rate: the number of pressure units it can release <strong>per minute</strong> (from 0, for a valve that can't be opened, to a reasonably large number).  You calculate how long you and an elephant could work together to move around the cave system, open valves, and release pressure.</p>
<p>To save time, you open the valves with non-zero flow rates. The rules for each of you moving and opening valves are:</p>
<ul>
<li>You start at valve <code>AA</code>.</li>
<li>It takes you <strong>1 minute</strong> to move between valves.</li>
<li>It takes you <strong>1 minute</strong> to open a valve.</li>
<li>Moving and opening valves occurs in whole-number integer minutes.</li>
</ul>
<p>To better plan your route, you note the flow rate of each valve from your scan. You're going to spend <strong>30 minutes</strong> opening valves to release as much pressure as possible.</p>
<p>For example, suppose you have the following scan output:</p>
<pre><code>Valve AA has flow rate=0; tunnels lead to valves DD, II, BB
Valve BB has flow rate=13; tunnels lead to valves CC, AA
Valve CC has flow rate=2; tunnels lead to valves DD, BB
Valve DD has flow rate=20; tunnels lead to valves CC, AA, EE
Valve EE has flow rate=3; tunnels lead to valves FF, DD
Valve FF has flow rate=0; tunnels lead to valves EE, GG
Valve GG has flow rate=0; tunnels lead to valves FF, HH
Valve HH has flow rate=22; tunnel leads to valve GG
Valve II has flow rate=0; tunnels lead to valves AA, JJ
Valve JJ has flow rate=21; tunnel leads to valve II
</code></pre>
<p>All of the valves begin <strong>closed</strong>. You start at valve <code>AA</code>, but it must be damaged or jammed or something: its flow rate is <code>0</code>, so there's no point in opening it. However, you could spend one minute moving to valve <code>BB</code> and another minute opening it; doing so would release pressure during the remaining <strong>28 minutes</strong> at a flow rate of <code>13</code>, a total eventual pressure release of <code>28 * 13 = 364</code>. Then, you could spend your remaining 26 minutes moving to and opening the remaining valves with positive flow rates (<code>CC</code>, <code>DD</code>, <code>EE</code>, <code>HH</code>, and <code>JJ</code>) to maximize pressure released (which would be 1707).</p>
<p>However, there's a more efficient approach. One way to maximize pressure is:</p>
<pre><code>== Minute 1 ==
You open valve DD.
The elephant waits.

== Minute 2 ==
You move to valve CC.
The elephant moves to valve JJ.

== Minute 3 ==
You open valve CC.
The elephant opens valve JJ.

== Minute 4 ==
You move to valve BB.
The elephant waits.

== Minute 5 ==
You open valve BB.
The elephant moves to valve II.

== Minute 6 ==
You move to valve AA.
The elephant moves to valve AA.

== Minute 7 ==
You move to valve II.
The elephant moves to valve DD.

== Minute 8 ==
You move to valve JJ.
The elephant opens valve DD.

== Minute 9 ==
You open valve JJ.
The elephant moves to valve EE.

...
</code></pre>
<h2 id="part-1-14"><a class="header" href="#part-1-14">Part 1</a></h2>
<p>Work out the steps to release the most pressure in 30 minutes. <strong>What is the most pressure you can release?</strong></p>
<h2 id="part-2-15"><a class="header" href="#part-2-15">Part 2</a></h2>
<p>You're worried that even with an optimal approach, the pressure released won't be enough. What if you got one of the elephants to help you?</p>
<p>It would take you 4 minutes to teach an elephant how to open the right valves in the right order, leaving you with only <strong>26 minutes</strong> to actually execute your plan. Would having two of you working together be better, even if it means having less time? (Assume the elephant is just as capable as you are at moving and opening valves.)</p>
<p>In the example above, you could teach the elephant your plan, which would take 4 minutes:</p>
<pre><code>== Minute 1 ==
You move to valve II.
The elephant moves to valve DD.

== Minute 2 ==
You move to valve JJ.
The elephant opens valve DD.

== Minute 3 ==
You open valve JJ.
The elephant moves to valve EE.

== Minute 4 ==
You wait.
The elephant opens valve EE.

...
</code></pre>
<p>With the elephant helping, after opening valves <code>BB</code>, <code>CC</code>, <code>DD</code>, <code>EE</code>, <code>HH</code>, and <code>JJ</code>, you could achieve a flow rate of <strong><code>81</code></strong>.</p>
<p>However, you and the elephant need to be careful not to interfere with each other. As a result, you need to meticulously coordinate your actions to make sure that you and the elephant are never both trying to open the same valve, or move to the same valve.</p>
<p>With both you and the elephant working together for 26 minutes, <strong>what is the most pressure you could release?</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-16-solution-explanation"><a class="header" href="#day-16-solution-explanation">Day 16: Solution Explanation</a></h1>
<h2 id="approach-15"><a class="header" href="#approach-15">Approach</a></h2>
<p>Day 16 involves optimizing a sequence of valve openings to maximize the pressure released in a limited time. This is a complex optimization problem that can be approached in several ways. The solution uses a combination of techniques:</p>
<ol>
<li><strong>Graph Representation</strong>: Modeling the valve network as a graph where valves are nodes and tunnels are edges</li>
<li><strong>Distance Caching</strong>: Pre-computing the distances between all relevant valves to avoid redundant calculations</li>
<li><strong>Recursive Backtracking</strong>: Exploring different valve opening sequences to find the optimal solution</li>
<li><strong>Pruning</strong>: Eliminating non-productive paths to reduce the search space</li>
</ol>
<p>The key insight is recognizing that valves with zero flow rate never need to be opened, which significantly reduces the search space.</p>
<h2 id="implementation-details-15"><a class="header" href="#implementation-details-15">Implementation Details</a></h2>
<h3 id="data-structures-6"><a class="header" href="#data-structures-6">Data Structures</a></h3>
<p>The solution uses several key data structures:</p>
<h4 id="valvenet"><a class="header" href="#valvenet">ValveNet</a></h4>
<p>This structure represents the network of valves and tunnels:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ValveNet&lt;'a&gt; {
    graph: HashMap&lt;&amp;'a str, Vec&lt;&amp;'a str&gt;&gt;,  // Adjacency list representation
    flow: HashMap&lt;&amp;'a str, Valve&gt;,           // Flow rate for each valve
    cache: Cache&lt;(&amp;'a str, &amp;'a str)&gt;         // Distance cache
}
<span class="boring">}</span></code></pre></pre>
<h4 id="valve"><a class="header" href="#valve">Valve</a></h4>
<p>This structure represents a single valve:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Valve {
    pressure: usize,  // Flow rate
    open: bool        // Whether the valve is open
}
<span class="boring">}</span></code></pre></pre>
<h4 id="valvebacktrack"><a class="header" href="#valvebacktrack">ValveBacktrack</a></h4>
<p>This structure handles the backtracking algorithm to find the optimal solution:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ValveBacktrack {
    net: &amp;'a ValveNet&lt;'a&gt;,        // Reference to the valve network
    path: Vec&lt;&amp;'a str&gt;,           // Current path being explored
    solution: Vec&lt;&amp;'a str&gt;,       // Best solution found so far
    max: usize,                   // Maximum pressure released
    pressure: usize,              // Current pressure in this path
    time: Cell&lt;SystemTime&gt;        // For timing the solution
}
<span class="boring">}</span></code></pre></pre>
<h3 id="preprocessing"><a class="header" href="#preprocessing">Preprocessing</a></h3>
<p>Before running the main algorithm, the solution performs several preprocessing steps:</p>
<ol>
<li><strong>Parsing the input</strong>: Converting the text input into a graph representation</li>
<li><strong>Identifying relevant valves</strong>: Finding all valves with non-zero flow rates</li>
<li><strong>Building a distance cache</strong>: Pre-computing the distances between all relevant valves</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn nonzero_valves(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
    self.flow.iter()
        .filter(|(_, v)| v.pressure &gt; 0)
        .fold(vec![], |mut out, (name, _)| {
            out.push(name);
            out
        })
}

fn build_cache(&amp;self, valves: &amp;[&amp;'a str]) {
    for &amp;a in valves {
        for &amp;b in valves {
            if a != b {
                self.cache.push(
                    (a, b),
                    self.travel_distance(a, b).unwrap()
                );
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The distance cache is crucial for performance, as it allows the algorithm to quickly look up the time required to move between valves without recalculating paths.</p>
<h3 id="distance-calculation"><a class="header" href="#distance-calculation">Distance Calculation</a></h3>
<p>The distances between valves are calculated using breadth-first search (BFS):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn travel_distance(&amp;self, start: &amp;'a str, end: &amp;'a str) -&gt; Option&lt;usize&gt; {
    // Check if distance is already cached
    if let Some(cost) = self.cache.pull((start, end)) {
        return Some(cost);
    }

    // Perform BFS to find shortest path
    let mut queue = VecDeque::new();
    let mut state: HashMap&lt;&amp;str, (bool, Option&lt;&amp;str&gt;)&gt; = /* initialize state */;

    queue.push_back(start);
    while let Some(valve) = queue.pop_front() {
        if valve.eq(end) {
            // Path found, calculate cost
            // ...
            return Some(path_cost);
        }

        // Process neighbors
        // ...
    }

    None // No path found
}
<span class="boring">}</span></code></pre></pre>
<h3 id="backtracking-algorithm-for-part-1"><a class="header" href="#backtracking-algorithm-for-part-1">Backtracking Algorithm for Part 1</a></h3>
<p>The main algorithm for Part 1 (single player) uses backtracking to explore different valve opening sequences:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn combinations_elf(&amp;mut self, time_left: usize, start: &amp;'a str, valves: &amp;[&amp;'a str]) {
    // Base case: no more valves to visit or no more time
    if valves.is_empty() || time_left == 0 {
        if self.max &lt; self.pressure {
            self.max = self.pressure;
            self.solution = self.path.clone();
            // Update best solution
        }
        return;
    }

    // Try each remaining valve
    for (i, &amp;valve) in valves.iter().enumerate() {
        // Calculate cost to move to valve and open it
        let cost = self.net.travel_distance(start, valve).unwrap() + 1;

        // Skip if not enough time
        if cost &gt; time_left {
            continue;
        }

        // Calculate pressure released
        let new_time_left = time_left - cost;
        let pressure_released = self.net.flow[&amp;valve].pressure * new_time_left;

        // Add to current path
        self.path.push(valve);
        self.pressure += pressure_released;

        // Recursive call with remaining valves
        let remaining_valves = valves.iter()
            .enumerate()
            .filter_map(|(j, &amp;v)| if j != i { Some(v) } else { None })
            .collect::&lt;Vec&lt;&amp;str&gt;&gt;();

        self.combinations_elf(new_time_left, valve, &amp;remaining_valves);

        // Backtrack
        self.path.pop();
        self.pressure -= pressure_released;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="backtracking-algorithm-for-part-2"><a class="header" href="#backtracking-algorithm-for-part-2">Backtracking Algorithm for Part 2</a></h3>
<p>For Part 2 (with an elephant), the algorithm is extended to handle two actors moving simultaneously:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn combinations_elf_elephant(&amp;mut self, time_left: &amp;[usize], start: &amp;[&amp;'a str], valves: &amp;[&amp;'a str]) {
    // Base case: no more valves to visit
    if valves.is_empty() {
        if self.max &lt; self.pressure {
            self.max = self.pressure;
            self.solution = self.path.clone();
            // Update best solution
        }
        return;
    }

    // Add current positions to path
    self.path.extend(start);

    // Try all combinations of valves for elf and elephant
    for elf in 0..valves.len() {
        for elephant in 0..valves.len() {
            // Skip if both try to visit the same valve
            if elf == elephant {
                continue;
            }

            let elf_target = valves[elf];
            let elephant_target = valves[elephant];

            // Calculate costs
            let elf_cost = self.net.travel_distance(start[0], elf_target).unwrap();
            let elephant_cost = self.net.travel_distance(start[1], elephant_target).unwrap();

            // Skip if not enough time
            if elf_cost &gt; time_left[0] || elephant_cost &gt; time_left[1] {
                continue;
            }

            // Calculate new time and pressure
            let elf_time = time_left[0] - elf_cost;
            let elephant_time = time_left[1] - elephant_cost;

            let pressure =
                self.net.flow[&amp;elf_target].pressure * elf_time +
                self.net.flow[&amp;elephant_target].pressure * elephant_time;

            // Add pressure
            self.pressure += pressure;

            // Recursive call with remaining valves
            let remaining_valves = valves.iter()
                .enumerate()
                .filter_map(|(i, &amp;v)| if i != elf &amp;&amp; i != elephant { Some(v) } else { None })
                .collect::&lt;Vec&lt;&amp;str&gt;&gt;();

            self.combinations_elf_elephant(
                &amp;[elf_time, elephant_time],
                &amp;[elf_target, elephant_target],
                &amp;remaining_valves
            );

            // Backtrack
            self.pressure -= pressure;
        }
    }

    // Remove current positions from path
    for _ in 0..start.len() {
        self.path.pop();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This approach explores all possible combinations of valve assignments between the player and elephant.</p>
<h3 id="optimizations"><a class="header" href="#optimizations">Optimizations</a></h3>
<p>Several optimizations make the solution feasible:</p>
<ol>
<li><strong>Filtering Zero-Flow Valves</strong>: Only valves with non-zero flow rates are considered for opening</li>
<li><strong>Distance Caching</strong>: Distances between valves are cached to avoid redundant calculations</li>
<li><strong>Early Pruning</strong>: Paths that can't possibly beat the current best solution are pruned early</li>
<li><strong>Time Checking</strong>: Valves that can't be reached in the remaining time are skipped</li>
</ol>
<p>These optimizations significantly reduce the search space, making an otherwise intractable problem solvable in a reasonable time.</p>
<h2 id="algorithm-analysis-5"><a class="header" href="#algorithm-analysis-5">Algorithm Analysis</a></h2>
<h3 id="time-complexity-11"><a class="header" href="#time-complexity-11">Time Complexity</a></h3>
<p>The time complexity is primarily determined by the backtracking algorithm:</p>
<ul>
<li><strong>Part 1</strong>: O(N!) where N is the number of non-zero flow valves, due to exploring all permutations</li>
<li><strong>Part 2</strong>: O(N! Ã— N!) in the worst case, due to exploring all combinations of assignments between the player and elephant</li>
</ul>
<p>However, the pruning optimizations significantly reduce the actual runtime.</p>
<h3 id="space-complexity-11"><a class="header" href="#space-complexity-11">Space Complexity</a></h3>
<ul>
<li><strong>Graph Representation</strong>: O(V + E) where V is the number of valves and E is the number of tunnels</li>
<li><strong>Distance Cache</strong>: O(VÂ²) for storing distances between all pairs of valves</li>
<li><strong>Backtracking State</strong>: O(V) for storing the current path and solution</li>
</ul>
<h2 id="alternative-approaches-14"><a class="header" href="#alternative-approaches-14">Alternative Approaches</a></h2>
<h3 id="dynamic-programming-1"><a class="header" href="#dynamic-programming-1">Dynamic Programming</a></h3>
<p>A dynamic programming approach could potentially solve this problem by using a state representation that includes the current position, time remaining, and valves opened:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type State = (String, usize, BitSet);

fn max_pressure(state: State, memo: &amp;mut HashMap&lt;State, usize&gt;) -&gt; usize {
    // Base case
    if state.1 == 0 {
        return 0;
    }

    // Check memo
    if let Some(&amp;result) = memo.get(&amp;state) {
        return result;
    }

    // Calculate maximum pressure
    let mut best = 0;

    // Try opening the current valve
    // Try moving to each adjacent valve

    // Store result
    memo.insert(state, best);
    return best;
}
<span class="boring">}</span></code></pre></pre>
<p>This approach would have a more predictable runtime but requires careful state representation to avoid memory issues.</p>
<h3 id="greedy-algorithm"><a class="header" href="#greedy-algorithm">Greedy Algorithm</a></h3>
<p>A simpler but <strong>less optimal</strong> approach would be a greedy algorithm that always chooses the valve with the highest potential pressure release (flow rate Ã— remaining time after reaching it):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greedy_solution(net: &amp;ValveNet, start: &amp;str, time: usize) -&gt; usize {
    let mut current = start;
    let mut time_left = time;
    let mut total_pressure = 0;
    let mut opened = HashSet::new();

    while time_left &gt; 0 {
        // Find best valve to open next
        let best_valve = net.valves()
            .filter(|v| !opened.contains(v) &amp;&amp; net.flow[v].pressure &gt; 0)
            .max_by_key(|v| {
                let cost = net.distance(current, v) + 1;
                if cost &gt;= time_left {
                    0
                } else {
                    net.flow[v].pressure * (time_left - cost)
                }
            });

        // No more valves worth opening
        if let Some(valve) = best_valve {
            // Move to valve and open it
            // Update state
        } else {
            break;
        }
    }

    total_pressure
}
<span class="boring">}</span></code></pre></pre>
<p>This would run much faster but would likely produce <strong>suboptimal</strong> results.</p>
<h2 id="conclusion-13"><a class="header" href="#conclusion-13">Conclusion</a></h2>
<p>This solution demonstrates an effective approach to a complex optimization problem. By combining graph algorithms, caching, and backtracking with pruning, it finds the optimal valve opening sequence in a reasonable time. The extension to Part 2 shows how the algorithm can be adapted to handle multiple actors working simultaneously.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-16-code"><a class="header" href="#day-16-code">Day 16: Code</a></h1>
<p>Below is an explanation of the code for Day 16's solution, which finds the optimal valve opening sequence to maximize pressure release.</p>
<h2 id="code-structure-1"><a class="header" href="#code-structure-1">Code Structure</a></h2>
<p>The solution for Day 16 is quite complex and uses several key components:</p>
<ol>
<li><code>ValveNet</code>: Represents the network of valves and tunnels</li>
<li><code>Valve</code>: Represents a single valve with its flow rate</li>
<li><code>ValveBacktrack</code>: Implements the backtracking algorithm to find optimal paths</li>
<li><code>Cache</code>: Provides efficient caching of distances between valves</li>
</ol>
<h2 id="key-components-1"><a class="header" href="#key-components-1">Key Components</a></h2>
<h3 id="valve-and-valvenet-structures"><a class="header" href="#valve-and-valvenet-structures">Valve and ValveNet Structures</a></h3>
<pre><code class="language-rust no_run noplayground">#[derive(Copy, Clone)]
struct Valve {
    pressure: usize,
    open: bool
}

struct ValveNet&lt;'a&gt; {
    graph: HashMap&lt;&amp;'a str,Vec&lt;&amp;'a str&gt;&gt;,
    flow: HashMap&lt;&amp;'a str, Valve&gt;,
    cache: Cache&lt;(&amp;'a str, &amp;'a str)&gt;
}</code></pre>
<p>The <code>Valve</code> struct represents a single valve with its flow rate and status. The <code>ValveNet</code> struct represents the entire network, using hashmaps to store the graph structure and valve information, along with a cache for distances.</p>
<h3 id="valve-network-methods"><a class="header" href="#valve-network-methods">Valve Network Methods</a></h3>
<p>The <code>ValveNet</code> implementation includes several key methods:</p>
<pre><code class="language-rust no_run noplayground">impl&lt;'a&gt; ValveNet&lt;'a&gt; {
    fn backtrack(&amp;'a self) -&gt; ValveBacktrack {
        ValveBacktrack {
            net: self,
            path: Vec::with_capacity(self.flow.len()),
            solution: Vec::with_capacity(self.flow.len()),
            pressure: 0,
            max: 0,
            time: Cell::new(std::time::SystemTime::now())
        }
    }
    fn build_cache(&amp;self, valves: &amp;[&amp;'a str]) {
        for &amp;a in valves {
            for &amp;b in valves {
                if a != b {
                    self.cache.push(
                        (a, b),
                        self.travel_distance(a, b).unwrap()
                    );
                }
            }
        }

    }
    fn nonzero_valves(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.flow.iter()
            .filter(|(_, v)| v.pressure &gt; 0 )
            .fold( vec![],|mut out, (name, _)| {
                out.push(name);
                out
            })
    }</code></pre>
<p>These methods set up the backtracking algorithm, build a cache of distances between valves, and identify the valves with non-zero flow rates.</p>
<h3 id="backtracking-implementation"><a class="header" href="#backtracking-implementation">Backtracking Implementation</a></h3>
<p>The core of the solution is the backtracking algorithm implemented in <code>ValveBacktrack</code>. For Part 2 (with an elephant), the implementation explores combinations of valve assignments:</p>
<pre><code class="language-rust no_run noplayground">    fn combinations_elf_elephant(&amp;mut self, time_left: &amp;[usize], start: &amp;[&amp;'a str], valves: &amp;[&amp;'a str]) {

        // have we run out of valve destinations ?
        if valves.is_empty() {
            // we have a candidate solution; valve combination within 30"
            if self.max &lt; self.pressure {
                self.max = self.pressure;
                self.solution = self.path.clone();
                self.solution.extend(start);

                let time = self.time.replace(std::time::SystemTime::now());
                print!("Found (EoV): {:?},{:?}", self.pressure, &amp;self.path);
                println!(" - {:.2?},", std::time::SystemTime::now().duration_since(time).unwrap());
            }
            // END OF RECURSION HERE
            return;
        }

        // Entering a valves
        self.path.extend(start);

        // Run combinations of valves
        // valves visited by Elf
        (0..valves.len())
            .for_each( |elf| {
                // valves visited by Elephant
                (0..valves.len())
                    .for_each(|elephant| {
                        // Are they both on the same valve ?
                        if elf == elephant {return;}

                        // pick the target valves to walk towards
                        let (elf_target,eleph_target) = ( valves[elf], valves[elephant] );

                        let (elf_cost, eleph_cost) = (
                            self.net.travel_distance(start[0], elf_target).unwrap(),
                            self.net.travel_distance(start[1], eleph_target).unwrap()
                        );

                        // do we have time to move to target valves ?
                        if elf_cost &lt;= time_left[0] &amp;&amp; eleph_cost &lt;= time_left[1] {

                            let (elf_time, eleph_time) = ( time_left[0] - elf_cost, time_left[1] - eleph_cost );

                            // calculate the total pressure resulting from this move
                            let pressure=
                                self.net.flow[&amp;elf_target].pressure * elf_time
                                    + self.net.flow[&amp;eleph_target].pressure * eleph_time;

                            // Store the total pressure released
                            self.pressure += pressure;

                            // remove the elf &amp; elephant targets from the valves to visit
                            let valves_remain= valves.iter()
                                .enumerate()
                                .filter_map(|(i,&amp;v)| if i != elf &amp;&amp; i != elephant {Some(v)} else { None } )
                                .collect::&lt;Vec&lt;&amp;str&gt;&gt;();

                            // println!("\tElf:{:?}, Eleph:{:?} - {:?},[{:?},{:?}]",
                            //          (start[0], elf_target, elf_cost, time_left[0]),
                            //          (start[1], eleph_target, eleph_cost, time_left[1]),
                            //          (self.max,self.pressure+self.path_pressure(elf_time, &amp;valves_remain)), (elf_target, eleph_target), &amp;valves_remain
                            // );
                            self.combinations_elf_elephant(
                                &amp;[elf_time, eleph_time],
                                &amp;[elf_target, eleph_target],
                                &amp;valves_remain
                            );
                            // we've finished with this combination hence remove from total pressure
                            self.pressure -= pressure;
                        } else {
                            // We've run out of time so we've finished and store the total pressure for this combination
                            if self.pressure &gt; self.max {
                                self.max = self.pressure;
                                self.solution = self.path.clone();

                                let time = self.time.replace(std::time::SystemTime::now());
                                print!("Found (OoT): {:?},{:?}", self.pressure, self.path);
                                println!(" - {:.2?},", std::time::SystemTime::now().duration_since(time).unwrap());
                            }
                        }
                    });
            });
        // Leaving the valve we entered; finished testing combinations
        self.path.pop();
        self.path.pop();
    }</code></pre>
<p>This method recursively explores different combinations of valve assignments between the player and elephant, calculating the total pressure released for each combination.</p>
<h3 id="distance-calculation-1"><a class="header" href="#distance-calculation-1">Distance Calculation</a></h3>
<p>The solution calculates distances between valves using breadth-first search and caches the results for efficiency:</p>
<pre><code class="language-rust no_run noplayground">    fn travel_distance(&amp;self, start:&amp;'a str, end:&amp;'a str) -&gt; Option&lt;usize&gt; {

        if let Some(cost) = self.cache.pull((start,end)) {
            return Some(cost)
        }

        let mut queue = VecDeque::new();
        let mut state: HashMap&lt;&amp;str,(bool,Option&lt;&amp;str&gt;)&gt; =
            self.flow.iter()
                .map(|(&amp;key,_)| (key, (false, None)))
                .collect::&lt;HashMap&lt;_,_&gt;&gt;();
        let mut path_cost = 0;

        queue.push_back(start);
        while let Some(valve) = queue.pop_front() {

            if valve.eq(end) {
                let mut cur = valve;
                while let Some(par) = state[&amp;cur].1 {
                    path_cost += 1;
                    cur = par;
                }
                path_cost += 1;
                self.cache.push((start, end), path_cost);
                return Some(path_cost);
            }
            state.get_mut(valve).unwrap().0 = true;
            for &amp;v in &amp;self.graph[valve] {
                if !state[v].0 {
                    state.get_mut(v).unwrap().1 = Some(valve);
                    queue.push_back(v)
                }
            }
        }
        None
    }</code></pre>
<p>This function performs a breadth-first search to find the shortest path between valves, then caches the result to avoid redundant calculations.</p>
<h3 id="main-function-8"><a class="header" href="#main-function-8">Main Function</a></h3>
<p>The main function sets up and runs the solution:</p>
<pre><code class="language-rust no_run noplayground">fn main() {

    // Found 2059,["AA", "II", "JI", "VC", "TE", "XF", "WT", "DM", "ZK", "KI", "VF", "DU", "BD", "XS", "IY"]
    let input = std::fs::read_to_string("src/bin/day16_input.txt").expect("ops!");
    let net = ValveNet::parse(input.as_str());

    let start = "AA";
    let mut valves = net.nonzero_valves();
    println!("Valves: {:?}",valves);

    valves.push(start);
    net.build_cache(&amp;valves);
    valves.pop();

    let time = std::time::SystemTime::now();

    // create all valve visit order combinations
    let mut btrack = net.backtrack();
    btrack.combinations_elf_elephant(&amp;[TIME-4,TIME-4], &amp;[start,start], &amp;valves);
    println!("Lapse time: {:?}",std::time::SystemTime::now().duration_since(time));
    println!("Max flow {:?}\nSolution: {:?}\n", btrack.max, (&amp;btrack.solution,btrack.path));
}</code></pre>
<p>The main function:</p>
<ol>
<li>Parses the input to create the valve network</li>
<li>Identifies valves with non-zero flow rates</li>
<li>Builds a cache of distances between valves</li>
<li>Runs the backtracking algorithm for Part 2 (with an elephant)</li>
<li>Prints the maximum pressure that can be released and the optimal path</li>
</ol>
<h2 id="implementation-notes-14"><a class="header" href="#implementation-notes-14">Implementation Notes</a></h2>
<ul>
<li><strong>Caching Strategy</strong>: The solution uses extensive caching to avoid redundant calculations</li>
<li><strong>Pruning</strong>: The algorithm prunes paths that can't possibly lead to better solutions</li>
<li><strong>Two-Actor Coordination</strong>: The solution handles coordination between two actors (player and elephant) to avoid conflicting actions</li>
<li><strong>Backtracking Approach</strong>: The core algorithm uses a recursive backtracking approach to explore the solution space</li>
</ul>
<p>The solution efficiently handles the complex optimization problem by focusing on the most relevant valves and using appropriate data structures and algorithms.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
