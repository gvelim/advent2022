<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Solution Explanation - Advent of Code 2022 Solutions</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation and explanations for Advent of Code 2022 solutions">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Advent of Code 2022 Solutions</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day-12-solution-explanation"><a class="header" href="#day-12-solution-explanation">Day 12: Solution Explanation</a></h1>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<p>Day 12 involves finding the shortest path through a grid with elevation constraints. The key to solving this problem is to use a breadth-first search (BFS) algorithm, which is optimal for finding the shortest path in an unweighted graph.</p>
<p>The solution breaks down into several key components:</p>
<ol>
<li><strong>Representing the heightmap</strong>: We need to parse the input into a grid of elevation values</li>
<li><strong>Implementing BFS</strong>: We need to find the shortest path from start to end, respecting elevation constraints</li>
<li><strong>Reversing the problem for Part 2</strong>: We can efficiently solve Part 2 by starting from the end point and finding the closest square with elevation 'a'</li>
<li><strong>Visualizing the path</strong>: As a bonus, the solution includes visualization using the bracket-lib library</li>
</ol>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="grid-representation"><a class="header" href="#grid-representation">Grid Representation</a></h3>
<p>The solution uses a custom <code>Grid</code> structure to represent the heightmap:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ElevationGrid(Grid&lt;u8&gt;);
<span class="boring">}</span></code></pre></pre>
<p>This wraps a generic <code>Grid&lt;u8&gt;</code> from a shared library, with elevation values represented as unsigned bytes. During parsing, letters 'a' to 'z' are converted to values 1 to 26, with 'S' (start) mapped to 0 and 'E' (end) mapped to 27.</p>
<h3 id="parsing-the-input"><a class="header" href="#parsing-the-input">Parsing the Input</a></h3>
<p>The input is parsed into an <code>ElevationGrid</code>, with special handling for the start ('S') and end ('E') positions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_elevation(data: &amp;str) -&gt; (ElevationGrid, Coord, Coord) {
    let width = data.lines().next().unwrap().len();
    let height = data.lines().count();
    let mut grid = Grid::new(width,height);
    let (mut start, mut finish) = ((0,0).into(),(0,0).into());

    for (y,line) in data.lines().enumerate() {
        for (x, val) in line.bytes().enumerate() {
            match val {
                b'S' =&gt; {
                    start = (x, y).into();
                    *grid.square_mut(start).unwrap() = 0;
                },
                b'E' =&gt; {
                    finish = (x, y).into();
                    *grid.square_mut(finish).unwrap() = b'z'-b'a'+2;
                }
                _ =&gt; *grid.square_mut((x, y).into()).unwrap() = val - b'a' + 1
            }
        }
    }
    (ElevationGrid(grid), start, finish)
}
<span class="boring">}</span></code></pre></pre>
<p>This function returns the grid, start coordinate, and end coordinate.</p>
<h3 id="path-finding-with-bfs"><a class="header" href="#path-finding-with-bfs">Path Finding with BFS</a></h3>
<p>The core of the solution is the <code>shortest_path</code> method on <code>ElevationGrid</code>, which implements BFS to find the shortest path satisfying a given goal condition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shortest_path&lt;F&gt;(&amp;self, start: Coord, goal:F ) -&gt; Vec&lt;Coord&gt; where F: Fn(Coord)-&gt;bool {
    let mut ps = PathSearch::init(self);
    // push start in the queue
    ps.queue.push_back(start);

    // pop from top &amp; while still nodes in the queue
    while let Some(cs) = ps.queue.pop_front() {
        // position matches target
        if goal(cs) {
            // extract parent position from target
            let mut cur = cs;
            while let Some(par) = ps.visited.square(cur).unwrap().1 {
                ps.path.push(par);
                cur = par;
            }
            // remove start position from path
            ps.path.pop();
            break
        }

        // mark square as visited
        ps.visited.square_mut(cs).unwrap().0 = true;

        let &amp;square = self.0.square(cs).unwrap();

        // evaluate neighbour squares and
        // push to the queue if the have elevation delta &lt;= 1
        self.0.neighbouring(cs)
            .for_each(|(ns, &amp;elevation)| {
                if let Some((false, None)) = ps.visited.square(ns) {
                    if elevation &lt;= square + 1 {
                        // capture the square we arrived from
                        ps.visited.square_mut(ns).unwrap().1 = Some(cs);
                        ps.queue.push_back(ns)
                    }
                }
            })
    }
    ps.path
}
<span class="boring">}</span></code></pre></pre>
<p>Key aspects of this implementation:</p>
<ol>
<li>It uses a queue for BFS traversal, starting from the specified position</li>
<li>It checks each position against a goal function passed as a parameter</li>
<li>It respects the elevation constraint (can only move to positions with elevation at most 1 higher)</li>
<li>It reconstructs the path from end to start using parent pointers</li>
</ol>
<h3 id="path-search-data-structure"><a class="header" href="#path-search-data-structure">Path Search Data Structure</a></h3>
<p>The BFS algorithm is supported by a <code>PathSearch</code> struct that manages the search state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PathSearch {
    queue: VecDeque&lt;Coord&gt;,
    visited: Grid&lt;(bool,Option&lt;Coord&gt;)&gt;,
    path: Vec&lt;Coord&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>This structure maintains:</p>
<ul>
<li>A queue of coordinates to explore</li>
<li>A grid tracking visited positions and their parent positions (for path reconstruction)</li>
<li>A vector to store the final path</li>
</ul>
<h3 id="solving-part-1"><a class="header" href="#solving-part-1">Solving Part 1</a></h3>
<p>For Part 1, we find the shortest path from the start position to the end position:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// find path with closure fn() goal set at reaching the target coordinate
let path = grid.shortest_path(start, |cs| cs.eq(&amp;target));
<span class="boring">}</span></code></pre></pre>
<p>We use a closure that checks if the current position matches the target position.</p>
<h3 id="solving-part-2"><a class="header" href="#solving-part-2">Solving Part 2</a></h3>
<p>For Part 2, we need to find the shortest path from any position with elevation 'a' to the end position. Instead of running BFS from each possible starting position, we reverse the problem:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// reverse the elevation so E(0) and S(27)
grid.reverse_elevation();

// find path with closure fn() goal set as reaching elevation(26) = a
let path = grid.shortest_path(target, |cs| 26.eq(grid.0.square(cs).unwrap()));
<span class="boring">}</span></code></pre></pre>
<p>This elegant approach:</p>
<ol>
<li>Reverses the elevation values (making 'a' the highest and 'z' the lowest)</li>
<li>Starts BFS from the end position</li>
<li>Looks for the first position with elevation value 26 (which corresponds to 'a' after reversal)</li>
</ol>
<p>The elevation reversal is implemented as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reverse_elevation(&amp;mut self) {
    let &amp;max = self.0.iter().max().unwrap();
    self.0.iter_mut()
        .map(|val|{
            *val = max - *val;
        })
        .all(|_| true);
}
<span class="boring">}</span></code></pre></pre>
<p>This effectively flips the elevation constraint, allowing us to find the shortest path from the end position to any 'a' position.</p>
<h3 id="visualization"><a class="header" href="#visualization">Visualization</a></h3>
<p>The solution includes visualization using the bracket-lib library, which renders the grid and path in a graphical window. This is not essential for solving the problem but provides a nice way to see the results.</p>
<h2 id="algorithmic-analysis"><a class="header" href="#algorithmic-analysis">Algorithmic Analysis</a></h2>
<h3 id="time-complexity"><a class="header" href="#time-complexity">Time Complexity</a></h3>
<ul>
<li><strong>BFS</strong>: O(V + E) where V is the number of vertices (grid cells) and E is the number of edges (adjacent cell pairs). In a grid, this simplifies to O(n) where n is the number of cells.</li>
<li><strong>Path Reconstruction</strong>: O(p) where p is the length of the path.</li>
<li><strong>Overall</strong>: O(n) for each part, where n is the number of grid cells.</li>
</ul>
<h3 id="space-complexity"><a class="header" href="#space-complexity">Space Complexity</a></h3>
<ul>
<li><strong>Grid Storage</strong>: O(n) to store the grid</li>
<li><strong>BFS Data Structures</strong>: O(n) for the queue and visited tracking</li>
<li><strong>Path Storage</strong>: O(p) where p is the path length</li>
<li><strong>Overall</strong>: O(n)</li>
</ul>
<h2 id="alternative-approaches"><a class="header" href="#alternative-approaches">Alternative Approaches</a></h2>
<h3 id="dijkstras-algorithm-or-a"><a class="header" href="#dijkstras-algorithm-or-a">Dijkstra's Algorithm or A*</a></h3>
<p>While BFS is optimal for unweighted graphs, we could also use Dijkstra's algorithm or A* if we wanted to add more complex cost calculations. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shortest_path_astar(&amp;self, start: Coord, end: Coord) -&gt; Vec&lt;Coord&gt; {
    let mut open_set = BinaryHeap::new();
    let mut came_from = HashMap::new();
    let mut g_score = HashMap::new();
    let mut f_score = HashMap::new();
    
    g_score.insert(start, 0);
    f_score.insert(start, manhattan_distance(start, end));
    open_set.push(Node { pos: start, f_score: *f_score.get(&amp;start).unwrap() });
    
    // A* algorithm implementation...
}

fn manhattan_distance(a: Coord, b: Coord) -&gt; u32 {
    ((a.x as i32 - b.x as i32).abs() + (a.y as i32 - b.y as i32).abs()) as u32
}
<span class="boring">}</span></code></pre></pre>
<p>However, for this problem, BFS is sufficient and more efficient.</p>
<h3 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic Programming</a></h3>
<p>Another approach could be to use dynamic programming to calculate the shortest distance to each cell from the starting point:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shortest_distance_dp(&amp;self, start: Coord) -&gt; Grid&lt;Option&lt;usize&gt;&gt; {
    let mut distances = Grid::new(self.width(), self.height());
    distances.square_mut(start).unwrap() = Some(0);
    
    let mut changed = true;
    while changed {
        changed = false;
        // For each cell, update distances based on neighbors
        // ...
    }
    
    distances
}
<span class="boring">}</span></code></pre></pre>
<p>This would be more complex and less efficient than BFS for this problem.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This solution demonstrates an efficient approach to pathfinding in a grid with elevation constraints. By using BFS and cleverly reversing the problem for Part 2, we achieve a clean and performant solution. The visualization component adds an interesting way to see the results of the algorithm in action.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day12/problem.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../day12/code.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day12/problem.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../day12/code.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
