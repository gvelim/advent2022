<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Solution Explanation - Advent of Code 2022 Solutions</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation and explanations for Advent of Code 2022 solutions">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Advent of Code 2022 Solutions</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day-10-solution-explanation"><a class="header" href="#day-10-solution-explanation">Day 10: Solution Explanation</a></h1>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<p>Day 10 involves simulating a simple CPU with a basic instruction set and a CRT display. The solution requires us to:</p>
<ol>
<li><strong>Parse the instructions</strong>: Read the input and convert it to a series of CPU instructions</li>
<li><strong>Simulate the CPU</strong>: Execute instructions while tracking the X register value</li>
<li><strong>Monitor signal strength</strong>: Calculate signal strength at specific cycles</li>
<li><strong>Render the CRT</strong>: Draw pixels based on the X register value</li>
</ol>
<p>The solution models the CPU, its execution cycle, and the CRT display as separate components that interact with each other.</p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="instruction-set"><a class="header" href="#instruction-set">Instruction Set</a></h3>
<p>We start by defining the instruction set and what each instruction does:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Cycles = usize;

#[derive(Debug,Copy, Clone)]
enum InstructionSet { Noop, AddX(isize) }

#[derive(Debug,Copy, Clone)]
struct Instruction {
    op: InstructionSet,
    ticks: Cycles
}
impl Instruction {
    fn result(&amp;self) -&gt; isize {
        match self.op {
            InstructionSet::Noop =&gt; 0,
            InstructionSet::AddX(val) =&gt; val
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>InstructionSet</code> enum represents the two possible instructions:</p>
<ul>
<li><code>Noop</code>: Does nothing</li>
<li><code>AddX(isize)</code>: Adds the specified value to the X register</li>
</ul>
<p>The <code>Instruction</code> struct combines an operation with the number of cycles it takes to execute. The <code>result</code> method returns the value that should be added to the X register after execution.</p>
<h3 id="cpu-simulation"><a class="header" href="#cpu-simulation">CPU Simulation</a></h3>
<p>The CPU is modeled as a state machine with several components:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Register(isize);

struct CPU {
    x: Register,             // X register
    buffer: Option&lt;Instruction&gt;, // Currently executing instruction
    exec_cycles: Cycles,      // Remaining cycles for current instruction
    ip: Option&lt;IntoIter&lt;Instruction&gt;&gt; // Instruction pointer
}
<span class="boring">}</span></code></pre></pre>
<p>The CPU implementation includes methods for loading instructions, fetching the next instruction, executing instructions, and advancing the clock:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl CPU {
    fn new() -&gt; CPU {
        CPU { x: Register(1), buffer: None, exec_cycles: 0, ip: None }
    }
    
    fn load(&amp;mut self, ops: Vec&lt;Instruction&gt;) {
        self.ip = Some(ops.into_iter());
    }
    
    fn fetch(&amp;mut self, op: Instruction) {
        self.exec_cycles = op.ticks;
        self.buffer = Some(op);
    }
    
    fn execute(&amp;mut self) -&gt; bool {
        match self.buffer {                         // Check instruction buffer
            None =&gt; false,                          // empty, not exec, go and load
            Some(op) =&gt; {                 // Instruction loaded
                self.exec_cycles -= 1;               // execution cycle #
                if self.exec_cycles == 0 {           // exec cycles reached?
                    self.x.0 += op.result();            // move Val to Reg X
                    self.buffer = None;                 // flush instruction buffer
                    false                           // not exec, go and load
                } else { true }                     // Busy executing
            }
        }
    }
    
    fn tick(&amp;mut self) {
        if !self.execute() {
            let mut ip = self.ip.take().unwrap();
            self.fetch(ip.next().unwrap());
            self.ip.replace(ip);
        }
    }
    
    fn reg_x(&amp;self) -&gt; isize {
        self.x.0
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This implementation models the CPU's behavior:</p>
<ul>
<li><code>execute</code> processes one cycle of the current instruction and returns whether execution is ongoing</li>
<li><code>tick</code> advances the CPU by one cycle, either continuing execution of the current instruction or fetching a new one</li>
<li><code>reg_x</code> provides access to the current value of the X register</li>
</ul>
<h3 id="crt-display"><a class="header" href="#crt-display">CRT Display</a></h3>
<p>The CRT display is modeled as a separate component:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CRT {
    width: usize,
    clock: Cycles
}

impl CRT {
    fn new(width: usize) -&gt; CRT {
        CRT{ width, clock: 0 }
    }
    
    fn draw(&amp;mut self, pos: isize) {
        let col = self.clock % self.width;
        print!("{}",
            if (pos-1..=pos+1).contains(&amp;(col as isize)) { '#' } else { '.' }
        );
        if col == self.width-1 { println!() }
    }
    
    fn tick(&amp;mut self, pos:isize) {
        self.draw(pos);
        self.clock += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The CRT:</p>
<ul>
<li>Tracks its own clock cycle</li>
<li>Draws a pixel based on the current cycle and the X register value</li>
<li>Automatically handles line breaks when reaching the end of a row</li>
</ul>
<h3 id="parsing-instructions"><a class="header" href="#parsing-instructions">Parsing Instructions</a></h3>
<p>The input is parsed into a sequence of instructions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_instructions(inp: &amp;str) -&gt; (Vec&lt;Instruction&gt;, usize) {
    inp.lines()
        .map(|line| {
            let mut iter = line.split(' ');
            match iter.next() {
                Some("noop") =&gt; Instruction { op: InstructionSet::Noop, ticks: 1 },
                Some("addx") =&gt; {
                    let val = isize::from_str(
                        iter.next().expect("parse_instructions: addx is missing its value!")
                    ).expect("parse_instructions: addx not followed by numeric value!");
                    Instruction { op: InstructionSet::AddX(val), ticks: 2 }
                },
                _ =&gt; panic!("parse_instructions: unknown instruction caught!")
            }
        })
        .fold((vec![],0), |(mut out,mut total), op| {
            total += op.ticks;
            out.push(op);
            (out,total)
        })
}
<span class="boring">}</span></code></pre></pre>
<p>This function:</p>
<ol>
<li>Converts each line into an <code>Instruction</code></li>
<li>Sets the appropriate number of cycles for each instruction type (1 for <code>noop</code>, 2 for <code>addx</code>)</li>
<li>Returns both the instructions and the total number of cycles they'll take to execute</li>
</ol>
<h3 id="main-simulation"><a class="header" href="#main-simulation">Main Simulation</a></h3>
<p>The main simulation brings everything together:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let input = std::fs::read_to_string("src/bin/day10_input.txt").expect("Ops!");

    let sample_intervals = vec![20usize, 60, 100, 140, 180, 220];
    let mut sampling_interval = sample_intervals.iter().peekable();

    let mut crt = CRT::new(40);
    let mut cpu = CPU::new();

    let (opcode, clock) = parse_instructions(input.as_str() );
    cpu.load(opcode);

    let sum = (1..=clock)
        .map(|cycle| {
            cpu.tick();
            crt.tick(cpu.reg_x());
            ( cycle, cpu.reg_x() )
        })
        .filter(|(cycle,_)|
            match sampling_interval.peek() {
                Some(&amp;to_sample) if to_sample.eq(cycle) =&gt; { sampling_interval.next(); true }
                _ =&gt; false
            }
        )
        .map(|(clock, x)| x * clock as isize)
        .sum::&lt;isize&gt;();

    println!("{sum} is the sum of signal strengths at {:?}", sample_intervals);
}</code></pre></pre>
<p>The main function:</p>
<ol>
<li>Sets up the sample intervals for signal strength measurement</li>
<li>Creates the CPU and CRT</li>
<li>Parses the instructions and loads them into the CPU</li>
<li>Runs the simulation for the specified number of cycles, ticking both CPU and CRT each cycle</li>
<li>Filters for the specific cycles we need to sample</li>
<li>Calculates the signal strength at those cycles</li>
<li>Sums the signal strengths for Part 1</li>
</ol>
<p>Part 2's output is handled automatically by the CRT's <code>draw</code> method, which prints the characters directly to the console.</p>
<h2 id="algorithm-analysis"><a class="header" href="#algorithm-analysis">Algorithm Analysis</a></h2>
<h3 id="time-complexity"><a class="header" href="#time-complexity">Time Complexity</a></h3>
<ul>
<li>Parsing the input: O(n) where n is the number of instructions</li>
<li>Simulating the CPU: O(c) where c is the total number of cycles</li>
<li>Overall: O(n + c), which is effectively O(c) since the number of cycles is proportional to the number of instructions</li>
</ul>
<h3 id="space-complexity"><a class="header" href="#space-complexity">Space Complexity</a></h3>
<ul>
<li>Storing instructions: O(n) where n is the number of instructions</li>
<li>CPU state: O(1)</li>
<li>CRT state: O(1)</li>
<li>Overall: O(n)</li>
</ul>
<h2 id="alternative-approaches"><a class="header" href="#alternative-approaches">Alternative Approaches</a></h2>
<h3 id="simplified-cpu-model"><a class="header" href="#simplified-cpu-model">Simplified CPU Model</a></h3>
<p>Instead of modeling the CPU with an instruction buffer and execution cycles, we could use a simpler approach that just keeps track of the current instruction and cycles:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SimplifiedCPU {
    x: isize,
    cycle: usize,
    instructions: Vec&lt;(String, isize)&gt;
}

impl SimplifiedCPU {
    fn run(&amp;mut self) -&gt; Vec&lt;(usize, isize)&gt; {
        let mut history = Vec::new();
        let mut pc = 0;
        
        while pc &lt; self.instructions.len() {
            let (instr, val) = &amp;self.instructions[pc];
            
            match instr.as_str() {
                "noop" =&gt; {
                    self.cycle += 1;
                    history.push((self.cycle, self.x));
                }
                "addx" =&gt; {
                    self.cycle += 1;
                    history.push((self.cycle, self.x));
                    self.cycle += 1;
                    history.push((self.cycle, self.x));
                    self.x += val;
                }
                _ =&gt; panic!("Unknown instruction")
            }
            
            pc += 1;
        }
        
        history
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This approach is more straightforward but less flexible if we wanted to add more instructions or change the behavior.</p>
<h3 id="crt-as-a-string-buffer"><a class="header" href="#crt-as-a-string-buffer">CRT as a String Buffer</a></h3>
<p>Instead of printing directly, the CRT could build a string buffer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BufferedCRT {
    width: usize,
    height: usize,
    buffer: Vec&lt;char&gt;,
    position: usize
}

impl BufferedCRT {
    fn new(width: usize, height: usize) -&gt; Self {
        Self {
            width,
            height,
            buffer: vec!['.'; width * height],
            position: 0
        }
    }
    
    fn draw(&amp;mut self, sprite_pos: isize) {
        let col = self.position % self.width;
        if (sprite_pos-1..=sprite_pos+1).contains(&amp;(col as isize)) {
            self.buffer[self.position] = '#';
        }
        self.position += 1;
    }
    
    fn display(&amp;self) -&gt; String {
        self.buffer.chunks(self.width)
            .map(|row| row.iter().collect::&lt;String&gt;())
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .join("\n")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This would allow us to build up the entire display and then render it all at once, which might be preferable for some applications.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This solution demonstrates how to simulate a simple CPU and CRT display. The modular approach with separate CPU and CRT components makes the code clean and maintainable. The use of Rust's pattern matching and option handling helps elegantly manage the CPU's state and instruction execution.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day10/problem.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../day10/code.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day10/problem.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../day10/code.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
