<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Solution Explanation - Advent of Code 2022 Solutions</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation and explanations for Advent of Code 2022 solutions">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Advent of Code 2022 Solutions</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day-15-solution-explanation"><a class="header" href="#day-15-solution-explanation">Day 15: Solution Explanation</a></h1>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<p>Day 15 involves analyzing sensor coverage to find positions where beacons cannot be present. The key challenge is efficiently handling the potentially large search space.</p>
<p>The solution breaks down into several components:</p>
<ol>
<li><strong>Parsing the input data</strong>: Extract sensor and beacon positions from the input</li>
<li><strong>Calculating sensor coverage</strong>: Determine the area each sensor can cover based on Manhattan distance</li>
<li><strong>Analyzing coverage on specific rows</strong>: Find ranges of positions that cannot contain a beacon</li>
<li><strong>Finding the distress beacon</strong>: Identify the one position where the distress beacon must be located</li>
</ol>
<p>The key insight is to work with ranges rather than individual positions, which allows for much more efficient processing.</p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h3>
<p>The solution uses several key data structures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Ord, PartialOrd, Copy, Clone, Eq, PartialEq, Hash)]
struct Coord {
    x: isize,
    y: isize
}

#[derive(Eq, PartialEq, Hash)]
struct Sensor {
    pos: Coord,
    beacon: Coord,
    dist: usize
}

struct Area {
    sensors: Vec&lt;Sensor&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>These structures represent coordinates, sensors, and the overall area being analyzed.</p>
<h3 id="parsing-the-input"><a class="header" href="#parsing-the-input">Parsing the Input</a></h3>
<p>The input is parsed into a collection of sensors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn deploy_sensors(sensors: &amp;str) -&gt; Area {
    Area {
        sensors: sensors.lines()
            .map(|line|
                line.split(&amp;[' ','=',',',':'])
                    .filter(|item| !item.trim().is_empty())
                    .filter(|item| item.chars().all(|d| d.is_numeric() || d == '-'))
                    .filter_map(|n| isize::from_str(n).ok())
                    .collect::&lt;Vec&lt;_&gt;&gt;()
            )
            .map(|comb|
                Sensor {
                    pos: (comb[0], comb[1]).into(),
                    beacon: (comb[2], comb[3]).into(),
                    dist: comb[0].abs_diff(comb[2]) + comb[1].abs_diff(comb[3])
                }
            )
            .collect::&lt;Vec&lt;_&gt;&gt;()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This function extracts the coordinates from each line and calculates the Manhattan distance between each sensor and its nearest beacon.</p>
<h3 id="calculating-sensor-coverage"><a class="header" href="#calculating-sensor-coverage">Calculating Sensor Coverage</a></h3>
<p>For each sensor, we need to determine its coverage at a specific y-coordinate. This is done by calculating a range of x-coordinates that the sensor can cover:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn coverage_at(&amp;self, d: isize) -&gt; Option&lt;RangeInclusive&lt;isize&gt;&gt; {
    let Coord{x, y} = self.pos;
    let diff = y.abs_diff(d);
    if diff &lt;= self.dist {
        Some(RangeInclusive::new(
            x.saturating_sub_unsigned(self.dist - diff),
            x.saturating_add_unsigned(self.dist - diff))
        )
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This method:</p>
<ol>
<li>Calculates the vertical distance from the sensor to the specified y-coordinate</li>
<li>If this distance is within the sensor's range, calculates the horizontal range the sensor can cover at that y-coordinate</li>
<li>Returns the range as a <code>RangeInclusive&lt;isize&gt;</code>, or <code>None</code> if the y-coordinate is out of range</li>
</ol>
<h3 id="analyzing-coverage-on-a-row"><a class="header" href="#analyzing-coverage-on-a-row">Analyzing Coverage on a Row</a></h3>
<p>To determine the coverage on a specific row, we need to combine the ranges from all sensors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sensor_coverage_at(&amp;self, line: isize) -&gt; Vec&lt;RangeInclusive&lt;isize&gt;&gt; {
    let mut result = vec![];

    let mut ranges = self.sensors.iter()
            .filter_map(|sensor| sensor.coverage_at(line))
            .collect::&lt;Vec&lt;_&gt;&gt;();

    ranges.sort_by_key(|a| *a.start());

    if let Some(last) = ranges.into_iter()
        .reduce(|a, b|
            if a.end() &gt;= &amp;(b.start()-1) {
                if a.end() &lt; b.end() {
                    *a.start()..=*b.end()
                } else { a }
            } else {
                // We got a range gap here hence we must save range A
                // while we pass on Range B to the next iteration
                result.push(a);
                b
            }
        ) {
        result.push(last);
    }
    result
}
<span class="boring">}</span></code></pre></pre>
<p>This method:</p>
<ol>
<li>Collects the coverage ranges from all sensors for the specified row</li>
<li>Sorts the ranges by their start position</li>
<li>Merges overlapping or adjacent ranges</li>
<li>Returns a list of non-overlapping ranges representing the total coverage</li>
</ol>
<p>The merging step is crucial for efficiency, as it allows us to represent large areas of coverage with just a few ranges.</p>
<h3 id="finding-beacons-on-a-row"><a class="header" href="#finding-beacons-on-a-row">Finding Beacons on a Row</a></h3>
<p>We also need to identify beacons that are already on the specified row:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn beacons_at(&amp;self, line: isize) -&gt; HashSet&lt;Coord&gt; {
    self.sensors.iter()
        .filter_map(|s| if s.beacon.y == line { Some(s.beacon) } else { None })
        .collect::&lt;HashSet&lt;_&gt;&gt;()
}
<span class="boring">}</span></code></pre></pre>
<p>This is used to exclude beacon positions from the count of positions where a beacon cannot be present.</p>
<h3 id="finding-the-distress-beacon-part-2"><a class="header" href="#finding-the-distress-beacon-part-2">Finding the Distress Beacon (Part 2)</a></h3>
<p>For Part 2, we need to find the one position in a large area where the distress beacon must be located. The key insight is that this position must be just outside the range of multiple sensors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (line, v) = (0..=4000000)
    .map(|line| (line, area.sensor_coverage_at(line)))
    .filter(|(_, v)| v.len() &gt; 1)
    .filter(|(_, v)| v[1].start() - v[0].end() &gt; 1)
    .next().unwrap();

let total = (v[0].end() + 1) * 4000000 + line;
<span class="boring">}</span></code></pre></pre>
<p>This code:</p>
<ol>
<li>Checks each row in the search area</li>
<li>Identifies rows where the coverage is split into multiple ranges</li>
<li>Finds the first row where there's a gap of exactly one position between ranges</li>
<li>Calculates the tuning frequency based on the position in the gap</li>
</ol>
<p>This approach is much more efficient than checking every possible position, as it only needs to examine rows where the coverage is not continuous.</p>
<h2 id="algorithmic-analysis"><a class="header" href="#algorithmic-analysis">Algorithmic Analysis</a></h2>
<h3 id="time-complexity"><a class="header" href="#time-complexity">Time Complexity</a></h3>
<ul>
<li><strong>Parsing</strong>: O(n) where n is the number of sensors</li>
<li><strong>Coverage Calculation</strong>: O(n) for each row analyzed</li>
<li><strong>Range Merging</strong>: O(n log n) due to the sorting step</li>
<li><strong>Part 1</strong>: O(n log n)</li>
<li><strong>Part 2</strong>: O(y * n log n) where y is the number of rows in the search area</li>
</ul>
<h3 id="space-complexity"><a class="header" href="#space-complexity">Space Complexity</a></h3>
<ul>
<li><strong>Storage</strong>: O(n) for storing the sensors and their information</li>
<li><strong>Range Processing</strong>: O(n) for storing the ranges during processing</li>
</ul>
<h2 id="alternative-approaches"><a class="header" href="#alternative-approaches">Alternative Approaches</a></h2>
<h3 id="grid-based-approach"><a class="header" href="#grid-based-approach">Grid-Based Approach</a></h3>
<p>A naive approach would be to use a grid to track each position:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn count_positions_without_beacon(sensors: &amp;[Sensor], y: isize, x_range: RangeInclusive&lt;isize&gt;) -&gt; usize {
    let mut count = 0;
    for x in x_range {
        let pos = Coord { x, y };
        if sensors.iter().any(|s| s.covers(pos)) &amp;&amp; !sensors.iter().any(|s| s.beacon == pos) {
            count += 1;
        }
    }
    count
}
<span class="boring">}</span></code></pre></pre>
<p>This would be much less efficient for large search areas, with a time complexity of O(x * n) where x is the width of the search area.</p>
<h3 id="binary-search-for-part-2"><a class="header" href="#binary-search-for-part-2">Binary Search for Part 2</a></h3>
<p>Another approach for Part 2 would be to use binary search to find the gap more efficiently:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_gap(ranges: &amp;[RangeInclusive&lt;isize&gt;], min: isize, max: isize) -&gt; Option&lt;isize&gt; {
    // Binary search for a gap in the ranges
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>This could potentially reduce the time complexity for finding the gap, but would be more complex to implement correctly.</p>
<h3 id="geometric-approach"><a class="header" href="#geometric-approach">Geometric Approach</a></h3>
<p>A more sophisticated approach would be to use computational geometry techniques:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_distress_beacon(sensors: &amp;[Sensor], bounds: (isize, isize)) -&gt; Coord {
    // Find intersection points of sensor boundaries
    // Check positions just outside the boundary of each sensor
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>This would be more efficient for very large search areas but would require more complex geometric calculations.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This solution demonstrates an efficient approach to a problem that involves analyzing large ranges of positions. By working with ranges rather than individual positions, we can efficiently solve both parts of the problem. The range merging technique is particularly effective for Part 1, while the gap-finding approach allows us to solve Part 2 without exhaustively checking every position.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day15/problem.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../day15/code.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day15/problem.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../day15/code.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
