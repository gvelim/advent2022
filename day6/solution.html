<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Solution Explanation - Advent of Code 2022 Solutions</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation and explanations for Advent of Code 2022 solutions">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Advent of Code 2022 Solutions</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day-6-solution-explanation"><a class="header" href="#day-6-solution-explanation">Day 6: Solution Explanation</a></h1>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<p>Day 6's problem involves finding the first occurrence of a sequence of unique characters in a datastream. The approach is to:</p>
<ol>
<li>Process the input datastream as a sequence of bytes</li>
<li>Examine consecutive windows of characters (of length 4 for part 1, 14 for part 2)</li>
<li>Check each window for duplicate characters</li>
<li>Find the position of the first window that contains no duplicates</li>
</ol>
<p>The solution uses Rust's trait system to create reusable functionality for checking duplicates and finding marker positions.</p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="detecting-duplicates"><a class="header" href="#detecting-duplicates">Detecting Duplicates</a></h3>
<p>The first key component is a trait for checking whether a slice contains any duplicate elements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Duplicate {
    fn has_duplicates(&amp;self) -&gt; bool;
}

impl&lt;T&gt; Duplicate for [T] where T: Debug + Copy + PartialEq + Ord {
    fn has_duplicates(&amp;self) -&gt; bool {
        let mut tmp = self.to_vec();
        tmp.sort();
        tmp.windows(2).any(|a| a[0]==a[1])
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This implementation:</p>
<ol>
<li>Creates a copy of the slice</li>
<li>Sorts the copy (bringing identical elements next to each other)</li>
<li>Checks adjacent pairs for equality using <code>windows(2)</code></li>
</ol>
<p>The trait is implemented generically for any slice type <code>[T]</code> where <code>T</code> supports debugging, copying, equality comparison, and ordering.</p>
<h3 id="finding-marker-positions"><a class="header" href="#finding-marker-positions">Finding Marker Positions</a></h3>
<p>The second key component is a trait for finding the position of a marker in a datastream:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Signaling {
    fn marker_position(&amp;self, len:usize) -&gt; usize;
}

impl&lt;T&gt; Signaling for [T] where T : Debug + Copy + PartialEq + Ord {
    fn marker_position(&amp;self, len: usize) -&gt; usize {
        self.windows(len)
            .enumerate()
            .skip_while(|&amp;(_,stm)| stm.has_duplicates() )
            .next()
            .map(|(i,_)| i + len)
            .unwrap_or_else(|| panic!("marker_position(): Ops!"))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This implementation:</p>
<ol>
<li>Creates sliding windows of the specified length using <code>windows(len)</code></li>
<li>Pairs each window with its index using <code>enumerate()</code></li>
<li>Skips windows that contain duplicates using <code>skip_while</code></li>
<li>Takes the first window that has no duplicates</li>
<li>Returns the position after this window (index + window length)</li>
</ol>
<h3 id="main-solution"><a class="header" href="#main-solution">Main Solution</a></h3>
<p>With these traits defined, the main solution becomes remarkably simple:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let data = std::fs::read_to_string("src/bin/day6_input.txt").expect("");

    let out = data.bytes().collect::&lt;Vec&lt;_&gt;&gt;();
    println!("Marker Length @4 = {}", out.marker_position(4));
    println!("Marker Length @14 = {}", out.marker_position(14));
}</code></pre></pre>
<p>The solution reads the input file, converts it to a vector of bytes, and then calls <code>marker_position</code> with the appropriate lengths for part 1 (4) and part 2 (14).</p>
<h2 id="algorithm-analysis"><a class="header" href="#algorithm-analysis">Algorithm Analysis</a></h2>
<h3 id="time-complexity"><a class="header" href="#time-complexity">Time Complexity</a></h3>
<p>The time complexity of this solution depends on the length of the input (<code>n</code>) and the marker length (<code>m</code>):</p>
<ul>
<li>Checking for duplicates in a window takes O(m log m) time due to the sorting operation</li>
<li>In the worst case, we check every window in the input, giving us O(n) windows</li>
<li>Overall time complexity: O(n * m log m)</li>
</ul>
<p>For this problem, <code>m</code> is small (4 or 14), so the logarithmic factor isn't significant, making the effective complexity close to O(n).</p>
<h3 id="space-complexity"><a class="header" href="#space-complexity">Space Complexity</a></h3>
<p>The space complexity is O(n) to store the input as a vector of bytes, plus O(m) temporary storage for each duplicate check.</p>
<h2 id="alternative-approaches"><a class="header" href="#alternative-approaches">Alternative Approaches</a></h2>
<h3 id="using-a-hashset-for-duplicate-detection"><a class="header" href="#using-a-hashset-for-duplicate-detection">Using a HashSet for Duplicate Detection</a></h3>
<p>A common alternative approach would be to use a <code>HashSet</code> to check for duplicates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn has_unique_chars(window: &amp;[u8]) -&gt; bool {
    let mut set = HashSet::new();
    window.iter().all(|&amp;c| set.insert(c))
}
<span class="boring">}</span></code></pre></pre>
<p>This would have O(m) time complexity for checking duplicates instead of O(m log m), but at the cost of using <code>HashSet</code> which has more overhead than simple sorting for small datasets.</p>
<h3 id="using-frequency-counting"><a class="header" href="#using-frequency-counting">Using Frequency Counting</a></h3>
<p>Another approach would be to count the frequency of each character:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn has_unique_chars(window: &amp;[u8]) -&gt; bool {
    let mut counts = [0; 256]; // For ASCII
    for &amp;c in window {
        counts[c as usize] += 1;
        if counts[c as usize] &gt; 1 {
            return false;
        }
    }
    true
}
<span class="boring">}</span></code></pre></pre>
<p>This has O(m) time complexity and uses a fixed amount of space, but is limited to ASCII or other bounded character sets.</p>
<h3 id="using-a-bit-set"><a class="header" href="#using-a-bit-set">Using a Bit Set</a></h3>
<p>For even more efficiency, a bit set could be used for the specific case of lowercase ASCII characters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn has_unique_chars(window: &amp;[u8]) -&gt; bool {
    let mut bits = 0u32;
    for &amp;c in window {
        let mask = 1 &lt;&lt; (c - b'a');
        if (bits &amp; mask) != 0 {
            return false;
        }
        bits |= mask;
    }
    true
}
<span class="boring">}</span></code></pre></pre>
<p>This has O(m) time complexity and uses only a single integer for storage, but is limited to a single case of character set.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>The solution demonstrates the power of Rust's traits for creating reusable, generic functionality. By separating the concerns of duplicate detection and marker finding into traits, the code becomes more modular and expressive. The generic implementation allows the solution to work with any type of element, not just characters, making it more versatile than specialized approaches.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day6/problem.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../day6/code.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day6/problem.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../day6/code.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
